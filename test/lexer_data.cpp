// Copyright (C) 2020 T. Zachary Laine
//
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

// Warning! This file is autogenerated.
#include <boost/text/data/all.hpp>
#include <boost/text/detail/lexer.hpp>

#include <gtest/gtest.h>


TEST(lexer, data)
{

    // From af.txt:

    {
        auto const str = boost::text::data::af::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "af.hpp")
        );
    }


    // From am.txt:

    {
        auto const str = boost::text::data::am::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "am.hpp")
        );
    }


    // From ar.txt:

    {
        auto const str = boost::text::data::ar::compat_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "ar.hpp")
        );
    }
    {
        auto const str = boost::text::data::ar::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "ar.hpp")
        );
    }


    // From as.txt:

    {
        auto const str = boost::text::data::as::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "as.hpp")
        );
    }


    // From az.txt:

    {
        auto const str = boost::text::data::az::search_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "az.hpp")
        );
    }
    {
        auto const str = boost::text::data::az::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "az.hpp")
        );
    }


    // From be.txt:

    {
        auto const str = boost::text::data::be::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "be.hpp")
        );
    }


    // From bg.txt:

    {
        auto const str = boost::text::data::bg::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "bg.hpp")
        );
    }


    // From bn.txt:

    {
        auto const str = boost::text::data::bn::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "bn.hpp")
        );
    }
    {
        auto const str = boost::text::data::bn::traditional_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "bn.hpp")
        );
    }


    // From bs.txt:

    {
        auto const str = boost::text::data::bs::search_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "bs.hpp")
        );
    }
    {
        auto const str = boost::text::data::bs::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "bs.hpp")
        );
    }


    // From bs_Cyrl.txt:

    {
        auto const str = boost::text::data::bs_Cyrl::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "bs_Cyrl.hpp")
        );
    }


    // From ca.txt:

    {
        auto const str = boost::text::data::ca::search_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "ca.hpp")
        );
    }


    // From chr.txt:

    {
        auto const str = boost::text::data::chr::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "chr.hpp")
        );
    }


    // From cs.txt:

    {
        auto const str = boost::text::data::cs::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "cs.hpp")
        );
    }


    // From cy.txt:

    {
        auto const str = boost::text::data::cy::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "cy.hpp")
        );
    }


    // From da.txt:

    {
        auto const str = boost::text::data::da::search_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "da.hpp")
        );
    }
    {
        auto const str = boost::text::data::da::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "da.hpp")
        );
    }


    // From de.txt:

    {
        auto const str = boost::text::data::de::phonebook_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "de.hpp")
        );
    }
    {
        auto const str = boost::text::data::de::search_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "de.hpp")
        );
    }


    // From de_AT.txt:

    {
        auto const str = boost::text::data::de_AT::phonebook_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "de_AT.hpp")
        );
    }


    // From dsb.txt:

    {
        auto const str = boost::text::data::dsb::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "dsb.hpp")
        );
    }


    // From ee.txt:

    {
        auto const str = boost::text::data::ee::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "ee.hpp")
        );
    }


    // From el.txt:

    {
        auto const str = boost::text::data::el::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "el.hpp")
        );
    }


    // From en_US_POSIX.txt:

    {
        auto const str = boost::text::data::en_US_POSIX::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "en_US_POSIX.hpp")
        );
    }


    // From eo.txt:

    {
        auto const str = boost::text::data::eo::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "eo.hpp")
        );
    }


    // From es.txt:

    {
        auto const str = boost::text::data::es::search_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "es.hpp")
        );
    }
    {
        auto const str = boost::text::data::es::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "es.hpp")
        );
    }
    {
        auto const str = boost::text::data::es::traditional_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "es.hpp")
        );
    }


    // From et.txt:

    {
        auto const str = boost::text::data::et::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "et.hpp")
        );
    }


    // From fa.txt:

    {
        auto const str = boost::text::data::fa::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "fa.hpp")
        );
    }


    // From fa_AF.txt:

    {
        auto const str = boost::text::data::fa_AF::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "fa_AF.hpp")
        );
    }


    // From fi.txt:

    {
        auto const str = boost::text::data::fi::search_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "fi.hpp")
        );
    }
    {
        auto const str = boost::text::data::fi::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "fi.hpp")
        );
    }
    {
        auto const str = boost::text::data::fi::traditional_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "fi.hpp")
        );
    }


    // From fil.txt:

    {
        auto const str = boost::text::data::fil::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "fil.hpp")
        );
    }


    // From fo.txt:

    {
        auto const str = boost::text::data::fo::search_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "fo.hpp")
        );
    }
    {
        auto const str = boost::text::data::fo::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "fo.hpp")
        );
    }


    // From fr_CA.txt:

    {
        auto const str = boost::text::data::fr_CA::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "fr_CA.hpp")
        );
    }


    // From gl.txt:

    {
        auto const str = boost::text::data::gl::search_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "gl.hpp")
        );
    }
    {
        auto const str = boost::text::data::gl::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "gl.hpp")
        );
    }


    // From gu.txt:

    {
        auto const str = boost::text::data::gu::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "gu.hpp")
        );
    }


    // From ha.txt:

    {
        auto const str = boost::text::data::ha::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "ha.hpp")
        );
    }


    // From haw.txt:

    {
        auto const str = boost::text::data::haw::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "haw.hpp")
        );
    }


    // From he.txt:

    {
        auto const str = boost::text::data::he::search_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "he.hpp")
        );
    }
    {
        auto const str = boost::text::data::he::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "he.hpp")
        );
    }


    // From hi.txt:

    {
        auto const str = boost::text::data::hi::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "hi.hpp")
        );
    }


    // From hr.txt:

    {
        auto const str = boost::text::data::hr::search_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "hr.hpp")
        );
    }
    {
        auto const str = boost::text::data::hr::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "hr.hpp")
        );
    }


    // From hsb.txt:

    {
        auto const str = boost::text::data::hsb::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "hsb.hpp")
        );
    }


    // From hu.txt:

    {
        auto const str = boost::text::data::hu::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "hu.hpp")
        );
    }


    // From hy.txt:

    {
        auto const str = boost::text::data::hy::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "hy.hpp")
        );
    }


    // From ig.txt:

    {
        auto const str = boost::text::data::ig::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "ig.hpp")
        );
    }


    // From is.txt:

    {
        auto const str = boost::text::data::is::search_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "is.hpp")
        );
    }
    {
        auto const str = boost::text::data::is::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "is.hpp")
        );
    }


    // From ja.txt:

    {
        auto const str = boost::text::data::ja::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "ja.hpp")
        );
    }
    {
        auto const str = boost::text::data::ja::unihan_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "ja.hpp")
        );
    }


    // From ka.txt:

    {
        auto const str = boost::text::data::ka::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "ka.hpp")
        );
    }


    // From kk.txt:

    {
        auto const str = boost::text::data::kk::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "kk.hpp")
        );
    }


    // From kl.txt:

    {
        auto const str = boost::text::data::kl::search_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "kl.hpp")
        );
    }
    {
        auto const str = boost::text::data::kl::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "kl.hpp")
        );
    }


    // From km.txt:

    {
        auto const str = boost::text::data::km::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "km.hpp")
        );
    }


    // From kn.txt:

    {
        auto const str = boost::text::data::kn::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "kn.hpp")
        );
    }
    {
        auto const str = boost::text::data::kn::traditional_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "kn.hpp")
        );
    }


    // From ko.txt:

    {
        auto const str = boost::text::data::ko::search_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "ko.hpp")
        );
    }
    {
        auto const str = boost::text::data::ko::searchjl_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "ko.hpp")
        );
    }
    {
        auto const str = boost::text::data::ko::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "ko.hpp")
        );
    }
    {
        auto const str = boost::text::data::ko::unihan_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "ko.hpp")
        );
    }


    // From kok.txt:

    {
        auto const str = boost::text::data::kok::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "kok.hpp")
        );
    }


    // From ky.txt:

    {
        auto const str = boost::text::data::ky::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "ky.hpp")
        );
    }


    // From lkt.txt:

    {
        auto const str = boost::text::data::lkt::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "lkt.hpp")
        );
    }


    // From ln.txt:

    {
        auto const str = boost::text::data::ln::phonetic_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "ln.hpp")
        );
    }
    {
        auto const str = boost::text::data::ln::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "ln.hpp")
        );
    }


    // From lo.txt:

    {
        auto const str = boost::text::data::lo::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "lo.hpp")
        );
    }


    // From lt.txt:

    {
        auto const str = boost::text::data::lt::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "lt.hpp")
        );
    }


    // From lv.txt:

    {
        auto const str = boost::text::data::lv::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "lv.hpp")
        );
    }


    // From mk.txt:

    {
        auto const str = boost::text::data::mk::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "mk.hpp")
        );
    }


    // From ml.txt:

    {
        auto const str = boost::text::data::ml::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "ml.hpp")
        );
    }


    // From mn.txt:

    {
        auto const str = boost::text::data::mn::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "mn.hpp")
        );
    }


    // From mr.txt:

    {
        auto const str = boost::text::data::mr::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "mr.hpp")
        );
    }


    // From mt.txt:

    {
        auto const str = boost::text::data::mt::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "mt.hpp")
        );
    }


    // From my.txt:

    {
        auto const str = boost::text::data::my::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "my.hpp")
        );
    }


    // From nb.txt:

    {
        auto const str = boost::text::data::nb::search_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "nb.hpp")
        );
    }
    {
        auto const str = boost::text::data::nb::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "nb.hpp")
        );
    }


    // From ne.txt:

    {
        auto const str = boost::text::data::ne::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "ne.hpp")
        );
    }


    // From nn.txt:

    {
        auto const str = boost::text::data::nn::search_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "nn.hpp")
        );
    }
    {
        auto const str = boost::text::data::nn::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "nn.hpp")
        );
    }


    // From om.txt:

    {
        auto const str = boost::text::data::om::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "om.hpp")
        );
    }


    // From or.txt:

    {
        auto const str = boost::text::data::or_::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "or.hpp")
        );
    }


    // From pa.txt:

    {
        auto const str = boost::text::data::pa::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "pa.hpp")
        );
    }


    // From pl.txt:

    {
        auto const str = boost::text::data::pl::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "pl.hpp")
        );
    }


    // From ps.txt:

    {
        auto const str = boost::text::data::ps::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "ps.hpp")
        );
    }


    // From ro.txt:

    {
        auto const str = boost::text::data::ro::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "ro.hpp")
        );
    }


    // From ru.txt:

    {
        auto const str = boost::text::data::ru::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "ru.hpp")
        );
    }


    // From se.txt:

    {
        auto const str = boost::text::data::se::search_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "se.hpp")
        );
    }
    {
        auto const str = boost::text::data::se::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "se.hpp")
        );
    }


    // From si.txt:

    {
        auto const str = boost::text::data::si::dictionary_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "si.hpp")
        );
    }
    {
        auto const str = boost::text::data::si::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "si.hpp")
        );
    }


    // From sk.txt:

    {
        auto const str = boost::text::data::sk::search_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "sk.hpp")
        );
    }
    {
        auto const str = boost::text::data::sk::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "sk.hpp")
        );
    }


    // From sl.txt:

    {
        auto const str = boost::text::data::sl::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "sl.hpp")
        );
    }


    // From smn.txt:

    {
        auto const str = boost::text::data::smn::search_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "smn.hpp")
        );
    }
    {
        auto const str = boost::text::data::smn::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "smn.hpp")
        );
    }


    // From sq.txt:

    {
        auto const str = boost::text::data::sq::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "sq.hpp")
        );
    }


    // From sr.txt:

    {
        auto const str = boost::text::data::sr::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "sr.hpp")
        );
    }


    // From sr_Latn.txt:

    {
        auto const str = boost::text::data::sr_Latn::search_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "sr_Latn.hpp")
        );
    }
    {
        auto const str = boost::text::data::sr_Latn::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "sr_Latn.hpp")
        );
    }


    // From sv.txt:

    {
        auto const str = boost::text::data::sv::reformed_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "sv.hpp")
        );
    }
    {
        auto const str = boost::text::data::sv::search_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "sv.hpp")
        );
    }
    {
        auto const str = boost::text::data::sv::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "sv.hpp")
        );
    }


    // From ta.txt:

    {
        auto const str = boost::text::data::ta::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "ta.hpp")
        );
    }


    // From te.txt:

    {
        auto const str = boost::text::data::te::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "te.hpp")
        );
    }


    // From th.txt:

    {
        auto const str = boost::text::data::th::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "th.hpp")
        );
    }


    // From to.txt:

    {
        auto const str = boost::text::data::to::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "to.hpp")
        );
    }


    // From tr.txt:

    {
        auto const str = boost::text::data::tr::search_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "tr.hpp")
        );
    }
    {
        auto const str = boost::text::data::tr::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "tr.hpp")
        );
    }


    // From ug.txt:

    {
        auto const str = boost::text::data::ug::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "ug.hpp")
        );
    }


    // From uk.txt:

    {
        auto const str = boost::text::data::uk::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "uk.hpp")
        );
    }


    // From und.txt:

    {
        auto const str = boost::text::data::und::emoji_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "und.hpp")
        );
    }
    {
        auto const str = boost::text::data::und::eor_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "und.hpp")
        );
    }
    {
        auto const str = boost::text::data::und::search_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "und.hpp")
        );
    }


    // From ur.txt:

    {
        auto const str = boost::text::data::ur::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "ur.hpp")
        );
    }


    // From uz.txt:

    {
        auto const str = boost::text::data::uz::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "uz.hpp")
        );
    }


    // From vi.txt:

    {
        auto const str = boost::text::data::vi::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "vi.hpp")
        );
    }
    {
        auto const str = boost::text::data::vi::traditional_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "vi.hpp")
        );
    }


    // From wo.txt:

    {
        auto const str = boost::text::data::wo::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "wo.hpp")
        );
    }


    // From yi.txt:

    {
        auto const str = boost::text::data::yi::search_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "yi.hpp")
        );
    }
    {
        auto const str = boost::text::data::yi::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "yi.hpp")
        );
    }


    // From yo.txt:

    {
        auto const str = boost::text::data::yo::standard_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "yo.hpp")
        );
    }


    // From zh.txt:

    {
        auto const str = boost::text::data::zh::big5han_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "zh.hpp")
        );
    }
    {
        auto const str = boost::text::data::zh::gb2312han_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "zh.hpp")
        );
    }
    {
        auto const str = boost::text::data::zh::pinyin_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "zh.hpp")
        );
    }
    {
        auto const str = boost::text::data::zh::stroke_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "zh.hpp")
        );
    }
    {
        auto const str = boost::text::data::zh::unihan_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "zh.hpp")
        );
    }
    {
        auto const str = boost::text::data::zh::zhuyin_collation_tailoring();
        EXPECT_NO_THROW(
            boost::text::detail::lex(
                str.data(),
                str.data() + str.size(),
                [](std::string const & s) {
                    std::cout << s << std::endl;
                    throw std::runtime_error("Lexer produced an error!");
                },
                "zh.hpp")
        );
    }



}
