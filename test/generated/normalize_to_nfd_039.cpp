// Copyright (C) 2020 T. Zachary Laine
//
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

// Warning! This file is autogenerated.
#include <boost/text/normalize_string.hpp>
#include <boost/text/transcode_view.hpp>
#include <boost/text/string_utility.hpp>

#include <gtest/gtest.h>

#include <algorithm>



TEST(normalization, nfd_039_000)
{
    // C108;C108;1109 1164 11AF;C108;1109 1164 11AF; 
    // (섈; 섈; 섈; 섈; 섈; ) HANGUL SYLLABLE SYAEL
    {
        std::array<char32_t, 1> const c1 = {{ 0xC108 }};
        std::array<char32_t, 1> const c2 = {{ 0xC108 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1164, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xC108 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1164, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_001)
{
    // C109;C109;1109 1164 11B0;C109;1109 1164 11B0; 
    // (섉; 섉; 섉; 섉; 섉; ) HANGUL SYLLABLE SYAELG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC109 }};
        std::array<char32_t, 1> const c2 = {{ 0xC109 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1164, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xC109 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1164, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_002)
{
    // C10A;C10A;1109 1164 11B1;C10A;1109 1164 11B1; 
    // (섊; 섊; 섊; 섊; 섊; ) HANGUL SYLLABLE SYAELM
    {
        std::array<char32_t, 1> const c1 = {{ 0xC10A }};
        std::array<char32_t, 1> const c2 = {{ 0xC10A }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1164, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xC10A }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1164, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_003)
{
    // C10B;C10B;1109 1164 11B2;C10B;1109 1164 11B2; 
    // (섋; 섋; 섋; 섋; 섋; ) HANGUL SYLLABLE SYAELB
    {
        std::array<char32_t, 1> const c1 = {{ 0xC10B }};
        std::array<char32_t, 1> const c2 = {{ 0xC10B }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1164, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xC10B }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1164, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_004)
{
    // C10C;C10C;1109 1164 11B3;C10C;1109 1164 11B3; 
    // (섌; 섌; 섌; 섌; 섌; ) HANGUL SYLLABLE SYAELS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC10C }};
        std::array<char32_t, 1> const c2 = {{ 0xC10C }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1164, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xC10C }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1164, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_005)
{
    // C10D;C10D;1109 1164 11B4;C10D;1109 1164 11B4; 
    // (섍; 섍; 섍; 섍; 섍; ) HANGUL SYLLABLE SYAELT
    {
        std::array<char32_t, 1> const c1 = {{ 0xC10D }};
        std::array<char32_t, 1> const c2 = {{ 0xC10D }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1164, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xC10D }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1164, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_006)
{
    // C10E;C10E;1109 1164 11B5;C10E;1109 1164 11B5; 
    // (섎; 섎; 섎; 섎; 섎; ) HANGUL SYLLABLE SYAELP
    {
        std::array<char32_t, 1> const c1 = {{ 0xC10E }};
        std::array<char32_t, 1> const c2 = {{ 0xC10E }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1164, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xC10E }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1164, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_007)
{
    // C10F;C10F;1109 1164 11B6;C10F;1109 1164 11B6; 
    // (섏; 섏; 섏; 섏; 섏; ) HANGUL SYLLABLE SYAELH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC10F }};
        std::array<char32_t, 1> const c2 = {{ 0xC10F }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1164, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xC10F }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1164, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_008)
{
    // C110;C110;1109 1164 11B7;C110;1109 1164 11B7; 
    // (섐; 섐; 섐; 섐; 섐; ) HANGUL SYLLABLE SYAEM
    {
        std::array<char32_t, 1> const c1 = {{ 0xC110 }};
        std::array<char32_t, 1> const c2 = {{ 0xC110 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1164, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xC110 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1164, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_009)
{
    // C111;C111;1109 1164 11B8;C111;1109 1164 11B8; 
    // (섑; 섑; 섑; 섑; 섑; ) HANGUL SYLLABLE SYAEB
    {
        std::array<char32_t, 1> const c1 = {{ 0xC111 }};
        std::array<char32_t, 1> const c2 = {{ 0xC111 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1164, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xC111 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1164, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_010)
{
    // C112;C112;1109 1164 11B9;C112;1109 1164 11B9; 
    // (섒; 섒; 섒; 섒; 섒; ) HANGUL SYLLABLE SYAEBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC112 }};
        std::array<char32_t, 1> const c2 = {{ 0xC112 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1164, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xC112 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1164, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_011)
{
    // C113;C113;1109 1164 11BA;C113;1109 1164 11BA; 
    // (섓; 섓; 섓; 섓; 섓; ) HANGUL SYLLABLE SYAES
    {
        std::array<char32_t, 1> const c1 = {{ 0xC113 }};
        std::array<char32_t, 1> const c2 = {{ 0xC113 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1164, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xC113 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1164, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_012)
{
    // C114;C114;1109 1164 11BB;C114;1109 1164 11BB; 
    // (섔; 섔; 섔; 섔; 섔; ) HANGUL SYLLABLE SYAESS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC114 }};
        std::array<char32_t, 1> const c2 = {{ 0xC114 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1164, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xC114 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1164, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_013)
{
    // C115;C115;1109 1164 11BC;C115;1109 1164 11BC; 
    // (섕; 섕; 섕; 섕; 섕; ) HANGUL SYLLABLE SYAENG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC115 }};
        std::array<char32_t, 1> const c2 = {{ 0xC115 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1164, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xC115 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1164, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_014)
{
    // C116;C116;1109 1164 11BD;C116;1109 1164 11BD; 
    // (섖; 섖; 섖; 섖; 섖; ) HANGUL SYLLABLE SYAEJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xC116 }};
        std::array<char32_t, 1> const c2 = {{ 0xC116 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1164, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xC116 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1164, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_015)
{
    // C117;C117;1109 1164 11BE;C117;1109 1164 11BE; 
    // (섗; 섗; 섗; 섗; 섗; ) HANGUL SYLLABLE SYAEC
    {
        std::array<char32_t, 1> const c1 = {{ 0xC117 }};
        std::array<char32_t, 1> const c2 = {{ 0xC117 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1164, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xC117 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1164, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_016)
{
    // C118;C118;1109 1164 11BF;C118;1109 1164 11BF; 
    // (섘; 섘; 섘; 섘; 섘; ) HANGUL SYLLABLE SYAEK
    {
        std::array<char32_t, 1> const c1 = {{ 0xC118 }};
        std::array<char32_t, 1> const c2 = {{ 0xC118 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1164, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xC118 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1164, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_017)
{
    // C119;C119;1109 1164 11C0;C119;1109 1164 11C0; 
    // (섙; 섙; 섙; 섙; 섙; ) HANGUL SYLLABLE SYAET
    {
        std::array<char32_t, 1> const c1 = {{ 0xC119 }};
        std::array<char32_t, 1> const c2 = {{ 0xC119 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1164, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xC119 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1164, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_018)
{
    // C11A;C11A;1109 1164 11C1;C11A;1109 1164 11C1; 
    // (섚; 섚; 섚; 섚; 섚; ) HANGUL SYLLABLE SYAEP
    {
        std::array<char32_t, 1> const c1 = {{ 0xC11A }};
        std::array<char32_t, 1> const c2 = {{ 0xC11A }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1164, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xC11A }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1164, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_019)
{
    // C11B;C11B;1109 1164 11C2;C11B;1109 1164 11C2; 
    // (섛; 섛; 섛; 섛; 섛; ) HANGUL SYLLABLE SYAEH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC11B }};
        std::array<char32_t, 1> const c2 = {{ 0xC11B }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1164, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xC11B }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1164, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_020)
{
    // C11C;C11C;1109 1165;C11C;1109 1165; 
    // (서; 서; 서; 서; 서; ) HANGUL SYLLABLE SEO
    {
        std::array<char32_t, 1> const c1 = {{ 0xC11C }};
        std::array<char32_t, 1> const c2 = {{ 0xC11C }};
        std::array<char32_t, 2> const c3 = {{ 0x1109, 0x1165 }};
        std::array<char32_t, 1> const c4 = {{ 0xC11C }};
        std::array<char32_t, 2> const c5 = {{ 0x1109, 0x1165 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_021)
{
    // C11D;C11D;1109 1165 11A8;C11D;1109 1165 11A8; 
    // (석; 석; 석; 석; 석; ) HANGUL SYLLABLE SEOG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC11D }};
        std::array<char32_t, 1> const c2 = {{ 0xC11D }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xC11D }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_022)
{
    // C11E;C11E;1109 1165 11A9;C11E;1109 1165 11A9; 
    // (섞; 섞; 섞; 섞; 섞; ) HANGUL SYLLABLE SEOGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC11E }};
        std::array<char32_t, 1> const c2 = {{ 0xC11E }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xC11E }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_023)
{
    // C11F;C11F;1109 1165 11AA;C11F;1109 1165 11AA; 
    // (섟; 섟; 섟; 섟; 섟; ) HANGUL SYLLABLE SEOGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC11F }};
        std::array<char32_t, 1> const c2 = {{ 0xC11F }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xC11F }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_024)
{
    // C120;C120;1109 1165 11AB;C120;1109 1165 11AB; 
    // (선; 선; 선; 선; 선; ) HANGUL SYLLABLE SEON
    {
        std::array<char32_t, 1> const c1 = {{ 0xC120 }};
        std::array<char32_t, 1> const c2 = {{ 0xC120 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xC120 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_025)
{
    // C121;C121;1109 1165 11AC;C121;1109 1165 11AC; 
    // (섡; 섡; 섡; 섡; 섡; ) HANGUL SYLLABLE SEONJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xC121 }};
        std::array<char32_t, 1> const c2 = {{ 0xC121 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xC121 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_026)
{
    // C122;C122;1109 1165 11AD;C122;1109 1165 11AD; 
    // (섢; 섢; 섢; 섢; 섢; ) HANGUL SYLLABLE SEONH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC122 }};
        std::array<char32_t, 1> const c2 = {{ 0xC122 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xC122 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_027)
{
    // C123;C123;1109 1165 11AE;C123;1109 1165 11AE; 
    // (섣; 섣; 섣; 섣; 섣; ) HANGUL SYLLABLE SEOD
    {
        std::array<char32_t, 1> const c1 = {{ 0xC123 }};
        std::array<char32_t, 1> const c2 = {{ 0xC123 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xC123 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_028)
{
    // C124;C124;1109 1165 11AF;C124;1109 1165 11AF; 
    // (설; 설; 설; 설; 설; ) HANGUL SYLLABLE SEOL
    {
        std::array<char32_t, 1> const c1 = {{ 0xC124 }};
        std::array<char32_t, 1> const c2 = {{ 0xC124 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xC124 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_029)
{
    // C125;C125;1109 1165 11B0;C125;1109 1165 11B0; 
    // (섥; 섥; 섥; 섥; 섥; ) HANGUL SYLLABLE SEOLG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC125 }};
        std::array<char32_t, 1> const c2 = {{ 0xC125 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xC125 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_030)
{
    // C126;C126;1109 1165 11B1;C126;1109 1165 11B1; 
    // (섦; 섦; 섦; 섦; 섦; ) HANGUL SYLLABLE SEOLM
    {
        std::array<char32_t, 1> const c1 = {{ 0xC126 }};
        std::array<char32_t, 1> const c2 = {{ 0xC126 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xC126 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_031)
{
    // C127;C127;1109 1165 11B2;C127;1109 1165 11B2; 
    // (섧; 섧; 섧; 섧; 섧; ) HANGUL SYLLABLE SEOLB
    {
        std::array<char32_t, 1> const c1 = {{ 0xC127 }};
        std::array<char32_t, 1> const c2 = {{ 0xC127 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xC127 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_032)
{
    // C128;C128;1109 1165 11B3;C128;1109 1165 11B3; 
    // (섨; 섨; 섨; 섨; 섨; ) HANGUL SYLLABLE SEOLS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC128 }};
        std::array<char32_t, 1> const c2 = {{ 0xC128 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xC128 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_033)
{
    // C129;C129;1109 1165 11B4;C129;1109 1165 11B4; 
    // (섩; 섩; 섩; 섩; 섩; ) HANGUL SYLLABLE SEOLT
    {
        std::array<char32_t, 1> const c1 = {{ 0xC129 }};
        std::array<char32_t, 1> const c2 = {{ 0xC129 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xC129 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_034)
{
    // C12A;C12A;1109 1165 11B5;C12A;1109 1165 11B5; 
    // (섪; 섪; 섪; 섪; 섪; ) HANGUL SYLLABLE SEOLP
    {
        std::array<char32_t, 1> const c1 = {{ 0xC12A }};
        std::array<char32_t, 1> const c2 = {{ 0xC12A }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xC12A }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_035)
{
    // C12B;C12B;1109 1165 11B6;C12B;1109 1165 11B6; 
    // (섫; 섫; 섫; 섫; 섫; ) HANGUL SYLLABLE SEOLH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC12B }};
        std::array<char32_t, 1> const c2 = {{ 0xC12B }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xC12B }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_036)
{
    // C12C;C12C;1109 1165 11B7;C12C;1109 1165 11B7; 
    // (섬; 섬; 섬; 섬; 섬; ) HANGUL SYLLABLE SEOM
    {
        std::array<char32_t, 1> const c1 = {{ 0xC12C }};
        std::array<char32_t, 1> const c2 = {{ 0xC12C }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xC12C }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_037)
{
    // C12D;C12D;1109 1165 11B8;C12D;1109 1165 11B8; 
    // (섭; 섭; 섭; 섭; 섭; ) HANGUL SYLLABLE SEOB
    {
        std::array<char32_t, 1> const c1 = {{ 0xC12D }};
        std::array<char32_t, 1> const c2 = {{ 0xC12D }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xC12D }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_038)
{
    // C12E;C12E;1109 1165 11B9;C12E;1109 1165 11B9; 
    // (섮; 섮; 섮; 섮; 섮; ) HANGUL SYLLABLE SEOBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC12E }};
        std::array<char32_t, 1> const c2 = {{ 0xC12E }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xC12E }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_039)
{
    // C12F;C12F;1109 1165 11BA;C12F;1109 1165 11BA; 
    // (섯; 섯; 섯; 섯; 섯; ) HANGUL SYLLABLE SEOS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC12F }};
        std::array<char32_t, 1> const c2 = {{ 0xC12F }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xC12F }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_040)
{
    // C130;C130;1109 1165 11BB;C130;1109 1165 11BB; 
    // (섰; 섰; 섰; 섰; 섰; ) HANGUL SYLLABLE SEOSS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC130 }};
        std::array<char32_t, 1> const c2 = {{ 0xC130 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xC130 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_041)
{
    // C131;C131;1109 1165 11BC;C131;1109 1165 11BC; 
    // (성; 성; 성; 성; 성; ) HANGUL SYLLABLE SEONG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC131 }};
        std::array<char32_t, 1> const c2 = {{ 0xC131 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xC131 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_042)
{
    // C132;C132;1109 1165 11BD;C132;1109 1165 11BD; 
    // (섲; 섲; 섲; 섲; 섲; ) HANGUL SYLLABLE SEOJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xC132 }};
        std::array<char32_t, 1> const c2 = {{ 0xC132 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xC132 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_043)
{
    // C133;C133;1109 1165 11BE;C133;1109 1165 11BE; 
    // (섳; 섳; 섳; 섳; 섳; ) HANGUL SYLLABLE SEOC
    {
        std::array<char32_t, 1> const c1 = {{ 0xC133 }};
        std::array<char32_t, 1> const c2 = {{ 0xC133 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xC133 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_044)
{
    // C134;C134;1109 1165 11BF;C134;1109 1165 11BF; 
    // (섴; 섴; 섴; 섴; 섴; ) HANGUL SYLLABLE SEOK
    {
        std::array<char32_t, 1> const c1 = {{ 0xC134 }};
        std::array<char32_t, 1> const c2 = {{ 0xC134 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xC134 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_045)
{
    // C135;C135;1109 1165 11C0;C135;1109 1165 11C0; 
    // (섵; 섵; 섵; 섵; 섵; ) HANGUL SYLLABLE SEOT
    {
        std::array<char32_t, 1> const c1 = {{ 0xC135 }};
        std::array<char32_t, 1> const c2 = {{ 0xC135 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xC135 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_046)
{
    // C136;C136;1109 1165 11C1;C136;1109 1165 11C1; 
    // (섶; 섶; 섶; 섶; 섶; ) HANGUL SYLLABLE SEOP
    {
        std::array<char32_t, 1> const c1 = {{ 0xC136 }};
        std::array<char32_t, 1> const c2 = {{ 0xC136 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xC136 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_047)
{
    // C137;C137;1109 1165 11C2;C137;1109 1165 11C2; 
    // (섷; 섷; 섷; 섷; 섷; ) HANGUL SYLLABLE SEOH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC137 }};
        std::array<char32_t, 1> const c2 = {{ 0xC137 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1165, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xC137 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1165, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_048)
{
    // C138;C138;1109 1166;C138;1109 1166; 
    // (세; 세; 세; 세; 세; ) HANGUL SYLLABLE SE
    {
        std::array<char32_t, 1> const c1 = {{ 0xC138 }};
        std::array<char32_t, 1> const c2 = {{ 0xC138 }};
        std::array<char32_t, 2> const c3 = {{ 0x1109, 0x1166 }};
        std::array<char32_t, 1> const c4 = {{ 0xC138 }};
        std::array<char32_t, 2> const c5 = {{ 0x1109, 0x1166 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_049)
{
    // C139;C139;1109 1166 11A8;C139;1109 1166 11A8; 
    // (섹; 섹; 섹; 섹; 섹; ) HANGUL SYLLABLE SEG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC139 }};
        std::array<char32_t, 1> const c2 = {{ 0xC139 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xC139 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_050)
{
    // C13A;C13A;1109 1166 11A9;C13A;1109 1166 11A9; 
    // (섺; 섺; 섺; 섺; 섺; ) HANGUL SYLLABLE SEGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC13A }};
        std::array<char32_t, 1> const c2 = {{ 0xC13A }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xC13A }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_051)
{
    // C13B;C13B;1109 1166 11AA;C13B;1109 1166 11AA; 
    // (섻; 섻; 섻; 섻; 섻; ) HANGUL SYLLABLE SEGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC13B }};
        std::array<char32_t, 1> const c2 = {{ 0xC13B }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xC13B }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_052)
{
    // C13C;C13C;1109 1166 11AB;C13C;1109 1166 11AB; 
    // (센; 센; 센; 센; 센; ) HANGUL SYLLABLE SEN
    {
        std::array<char32_t, 1> const c1 = {{ 0xC13C }};
        std::array<char32_t, 1> const c2 = {{ 0xC13C }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xC13C }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_053)
{
    // C13D;C13D;1109 1166 11AC;C13D;1109 1166 11AC; 
    // (섽; 섽; 섽; 섽; 섽; ) HANGUL SYLLABLE SENJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xC13D }};
        std::array<char32_t, 1> const c2 = {{ 0xC13D }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xC13D }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_054)
{
    // C13E;C13E;1109 1166 11AD;C13E;1109 1166 11AD; 
    // (섾; 섾; 섾; 섾; 섾; ) HANGUL SYLLABLE SENH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC13E }};
        std::array<char32_t, 1> const c2 = {{ 0xC13E }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xC13E }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_055)
{
    // C13F;C13F;1109 1166 11AE;C13F;1109 1166 11AE; 
    // (섿; 섿; 섿; 섿; 섿; ) HANGUL SYLLABLE SED
    {
        std::array<char32_t, 1> const c1 = {{ 0xC13F }};
        std::array<char32_t, 1> const c2 = {{ 0xC13F }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xC13F }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_056)
{
    // C140;C140;1109 1166 11AF;C140;1109 1166 11AF; 
    // (셀; 셀; 셀; 셀; 셀; ) HANGUL SYLLABLE SEL
    {
        std::array<char32_t, 1> const c1 = {{ 0xC140 }};
        std::array<char32_t, 1> const c2 = {{ 0xC140 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xC140 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_057)
{
    // C141;C141;1109 1166 11B0;C141;1109 1166 11B0; 
    // (셁; 셁; 셁; 셁; 셁; ) HANGUL SYLLABLE SELG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC141 }};
        std::array<char32_t, 1> const c2 = {{ 0xC141 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xC141 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_058)
{
    // C142;C142;1109 1166 11B1;C142;1109 1166 11B1; 
    // (셂; 셂; 셂; 셂; 셂; ) HANGUL SYLLABLE SELM
    {
        std::array<char32_t, 1> const c1 = {{ 0xC142 }};
        std::array<char32_t, 1> const c2 = {{ 0xC142 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xC142 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_059)
{
    // C143;C143;1109 1166 11B2;C143;1109 1166 11B2; 
    // (셃; 셃; 셃; 셃; 셃; ) HANGUL SYLLABLE SELB
    {
        std::array<char32_t, 1> const c1 = {{ 0xC143 }};
        std::array<char32_t, 1> const c2 = {{ 0xC143 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xC143 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_060)
{
    // C144;C144;1109 1166 11B3;C144;1109 1166 11B3; 
    // (셄; 셄; 셄; 셄; 셄; ) HANGUL SYLLABLE SELS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC144 }};
        std::array<char32_t, 1> const c2 = {{ 0xC144 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xC144 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_061)
{
    // C145;C145;1109 1166 11B4;C145;1109 1166 11B4; 
    // (셅; 셅; 셅; 셅; 셅; ) HANGUL SYLLABLE SELT
    {
        std::array<char32_t, 1> const c1 = {{ 0xC145 }};
        std::array<char32_t, 1> const c2 = {{ 0xC145 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xC145 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_062)
{
    // C146;C146;1109 1166 11B5;C146;1109 1166 11B5; 
    // (셆; 셆; 셆; 셆; 셆; ) HANGUL SYLLABLE SELP
    {
        std::array<char32_t, 1> const c1 = {{ 0xC146 }};
        std::array<char32_t, 1> const c2 = {{ 0xC146 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xC146 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_063)
{
    // C147;C147;1109 1166 11B6;C147;1109 1166 11B6; 
    // (셇; 셇; 셇; 셇; 셇; ) HANGUL SYLLABLE SELH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC147 }};
        std::array<char32_t, 1> const c2 = {{ 0xC147 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xC147 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_064)
{
    // C148;C148;1109 1166 11B7;C148;1109 1166 11B7; 
    // (셈; 셈; 셈; 셈; 셈; ) HANGUL SYLLABLE SEM
    {
        std::array<char32_t, 1> const c1 = {{ 0xC148 }};
        std::array<char32_t, 1> const c2 = {{ 0xC148 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xC148 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_065)
{
    // C149;C149;1109 1166 11B8;C149;1109 1166 11B8; 
    // (셉; 셉; 셉; 셉; 셉; ) HANGUL SYLLABLE SEB
    {
        std::array<char32_t, 1> const c1 = {{ 0xC149 }};
        std::array<char32_t, 1> const c2 = {{ 0xC149 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xC149 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_066)
{
    // C14A;C14A;1109 1166 11B9;C14A;1109 1166 11B9; 
    // (셊; 셊; 셊; 셊; 셊; ) HANGUL SYLLABLE SEBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC14A }};
        std::array<char32_t, 1> const c2 = {{ 0xC14A }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xC14A }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_067)
{
    // C14B;C14B;1109 1166 11BA;C14B;1109 1166 11BA; 
    // (셋; 셋; 셋; 셋; 셋; ) HANGUL SYLLABLE SES
    {
        std::array<char32_t, 1> const c1 = {{ 0xC14B }};
        std::array<char32_t, 1> const c2 = {{ 0xC14B }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xC14B }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_068)
{
    // C14C;C14C;1109 1166 11BB;C14C;1109 1166 11BB; 
    // (셌; 셌; 셌; 셌; 셌; ) HANGUL SYLLABLE SESS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC14C }};
        std::array<char32_t, 1> const c2 = {{ 0xC14C }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xC14C }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_069)
{
    // C14D;C14D;1109 1166 11BC;C14D;1109 1166 11BC; 
    // (셍; 셍; 셍; 셍; 셍; ) HANGUL SYLLABLE SENG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC14D }};
        std::array<char32_t, 1> const c2 = {{ 0xC14D }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xC14D }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_070)
{
    // C14E;C14E;1109 1166 11BD;C14E;1109 1166 11BD; 
    // (셎; 셎; 셎; 셎; 셎; ) HANGUL SYLLABLE SEJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xC14E }};
        std::array<char32_t, 1> const c2 = {{ 0xC14E }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xC14E }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_071)
{
    // C14F;C14F;1109 1166 11BE;C14F;1109 1166 11BE; 
    // (셏; 셏; 셏; 셏; 셏; ) HANGUL SYLLABLE SEC
    {
        std::array<char32_t, 1> const c1 = {{ 0xC14F }};
        std::array<char32_t, 1> const c2 = {{ 0xC14F }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xC14F }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_072)
{
    // C150;C150;1109 1166 11BF;C150;1109 1166 11BF; 
    // (셐; 셐; 셐; 셐; 셐; ) HANGUL SYLLABLE SEK
    {
        std::array<char32_t, 1> const c1 = {{ 0xC150 }};
        std::array<char32_t, 1> const c2 = {{ 0xC150 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xC150 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_073)
{
    // C151;C151;1109 1166 11C0;C151;1109 1166 11C0; 
    // (셑; 셑; 셑; 셑; 셑; ) HANGUL SYLLABLE SET
    {
        std::array<char32_t, 1> const c1 = {{ 0xC151 }};
        std::array<char32_t, 1> const c2 = {{ 0xC151 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xC151 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_074)
{
    // C152;C152;1109 1166 11C1;C152;1109 1166 11C1; 
    // (셒; 셒; 셒; 셒; 셒; ) HANGUL SYLLABLE SEP
    {
        std::array<char32_t, 1> const c1 = {{ 0xC152 }};
        std::array<char32_t, 1> const c2 = {{ 0xC152 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xC152 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_075)
{
    // C153;C153;1109 1166 11C2;C153;1109 1166 11C2; 
    // (셓; 셓; 셓; 셓; 셓; ) HANGUL SYLLABLE SEH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC153 }};
        std::array<char32_t, 1> const c2 = {{ 0xC153 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1166, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xC153 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1166, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_076)
{
    // C154;C154;1109 1167;C154;1109 1167; 
    // (셔; 셔; 셔; 셔; 셔; ) HANGUL SYLLABLE SYEO
    {
        std::array<char32_t, 1> const c1 = {{ 0xC154 }};
        std::array<char32_t, 1> const c2 = {{ 0xC154 }};
        std::array<char32_t, 2> const c3 = {{ 0x1109, 0x1167 }};
        std::array<char32_t, 1> const c4 = {{ 0xC154 }};
        std::array<char32_t, 2> const c5 = {{ 0x1109, 0x1167 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_077)
{
    // C155;C155;1109 1167 11A8;C155;1109 1167 11A8; 
    // (셕; 셕; 셕; 셕; 셕; ) HANGUL SYLLABLE SYEOG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC155 }};
        std::array<char32_t, 1> const c2 = {{ 0xC155 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xC155 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_078)
{
    // C156;C156;1109 1167 11A9;C156;1109 1167 11A9; 
    // (셖; 셖; 셖; 셖; 셖; ) HANGUL SYLLABLE SYEOGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC156 }};
        std::array<char32_t, 1> const c2 = {{ 0xC156 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xC156 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_079)
{
    // C157;C157;1109 1167 11AA;C157;1109 1167 11AA; 
    // (셗; 셗; 셗; 셗; 셗; ) HANGUL SYLLABLE SYEOGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC157 }};
        std::array<char32_t, 1> const c2 = {{ 0xC157 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xC157 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_080)
{
    // C158;C158;1109 1167 11AB;C158;1109 1167 11AB; 
    // (션; 션; 션; 션; 션; ) HANGUL SYLLABLE SYEON
    {
        std::array<char32_t, 1> const c1 = {{ 0xC158 }};
        std::array<char32_t, 1> const c2 = {{ 0xC158 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xC158 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_081)
{
    // C159;C159;1109 1167 11AC;C159;1109 1167 11AC; 
    // (셙; 셙; 셙; 셙; 셙; ) HANGUL SYLLABLE SYEONJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xC159 }};
        std::array<char32_t, 1> const c2 = {{ 0xC159 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xC159 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_082)
{
    // C15A;C15A;1109 1167 11AD;C15A;1109 1167 11AD; 
    // (셚; 셚; 셚; 셚; 셚; ) HANGUL SYLLABLE SYEONH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC15A }};
        std::array<char32_t, 1> const c2 = {{ 0xC15A }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xC15A }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_083)
{
    // C15B;C15B;1109 1167 11AE;C15B;1109 1167 11AE; 
    // (셛; 셛; 셛; 셛; 셛; ) HANGUL SYLLABLE SYEOD
    {
        std::array<char32_t, 1> const c1 = {{ 0xC15B }};
        std::array<char32_t, 1> const c2 = {{ 0xC15B }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xC15B }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_084)
{
    // C15C;C15C;1109 1167 11AF;C15C;1109 1167 11AF; 
    // (셜; 셜; 셜; 셜; 셜; ) HANGUL SYLLABLE SYEOL
    {
        std::array<char32_t, 1> const c1 = {{ 0xC15C }};
        std::array<char32_t, 1> const c2 = {{ 0xC15C }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xC15C }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_085)
{
    // C15D;C15D;1109 1167 11B0;C15D;1109 1167 11B0; 
    // (셝; 셝; 셝; 셝; 셝; ) HANGUL SYLLABLE SYEOLG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC15D }};
        std::array<char32_t, 1> const c2 = {{ 0xC15D }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xC15D }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_086)
{
    // C15E;C15E;1109 1167 11B1;C15E;1109 1167 11B1; 
    // (셞; 셞; 셞; 셞; 셞; ) HANGUL SYLLABLE SYEOLM
    {
        std::array<char32_t, 1> const c1 = {{ 0xC15E }};
        std::array<char32_t, 1> const c2 = {{ 0xC15E }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xC15E }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_087)
{
    // C15F;C15F;1109 1167 11B2;C15F;1109 1167 11B2; 
    // (셟; 셟; 셟; 셟; 셟; ) HANGUL SYLLABLE SYEOLB
    {
        std::array<char32_t, 1> const c1 = {{ 0xC15F }};
        std::array<char32_t, 1> const c2 = {{ 0xC15F }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xC15F }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_088)
{
    // C160;C160;1109 1167 11B3;C160;1109 1167 11B3; 
    // (셠; 셠; 셠; 셠; 셠; ) HANGUL SYLLABLE SYEOLS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC160 }};
        std::array<char32_t, 1> const c2 = {{ 0xC160 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xC160 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_089)
{
    // C161;C161;1109 1167 11B4;C161;1109 1167 11B4; 
    // (셡; 셡; 셡; 셡; 셡; ) HANGUL SYLLABLE SYEOLT
    {
        std::array<char32_t, 1> const c1 = {{ 0xC161 }};
        std::array<char32_t, 1> const c2 = {{ 0xC161 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xC161 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_090)
{
    // C162;C162;1109 1167 11B5;C162;1109 1167 11B5; 
    // (셢; 셢; 셢; 셢; 셢; ) HANGUL SYLLABLE SYEOLP
    {
        std::array<char32_t, 1> const c1 = {{ 0xC162 }};
        std::array<char32_t, 1> const c2 = {{ 0xC162 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xC162 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_091)
{
    // C163;C163;1109 1167 11B6;C163;1109 1167 11B6; 
    // (셣; 셣; 셣; 셣; 셣; ) HANGUL SYLLABLE SYEOLH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC163 }};
        std::array<char32_t, 1> const c2 = {{ 0xC163 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xC163 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_092)
{
    // C164;C164;1109 1167 11B7;C164;1109 1167 11B7; 
    // (셤; 셤; 셤; 셤; 셤; ) HANGUL SYLLABLE SYEOM
    {
        std::array<char32_t, 1> const c1 = {{ 0xC164 }};
        std::array<char32_t, 1> const c2 = {{ 0xC164 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xC164 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_093)
{
    // C165;C165;1109 1167 11B8;C165;1109 1167 11B8; 
    // (셥; 셥; 셥; 셥; 셥; ) HANGUL SYLLABLE SYEOB
    {
        std::array<char32_t, 1> const c1 = {{ 0xC165 }};
        std::array<char32_t, 1> const c2 = {{ 0xC165 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xC165 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_094)
{
    // C166;C166;1109 1167 11B9;C166;1109 1167 11B9; 
    // (셦; 셦; 셦; 셦; 셦; ) HANGUL SYLLABLE SYEOBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC166 }};
        std::array<char32_t, 1> const c2 = {{ 0xC166 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xC166 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_095)
{
    // C167;C167;1109 1167 11BA;C167;1109 1167 11BA; 
    // (셧; 셧; 셧; 셧; 셧; ) HANGUL SYLLABLE SYEOS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC167 }};
        std::array<char32_t, 1> const c2 = {{ 0xC167 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xC167 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_096)
{
    // C168;C168;1109 1167 11BB;C168;1109 1167 11BB; 
    // (셨; 셨; 셨; 셨; 셨; ) HANGUL SYLLABLE SYEOSS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC168 }};
        std::array<char32_t, 1> const c2 = {{ 0xC168 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xC168 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_097)
{
    // C169;C169;1109 1167 11BC;C169;1109 1167 11BC; 
    // (셩; 셩; 셩; 셩; 셩; ) HANGUL SYLLABLE SYEONG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC169 }};
        std::array<char32_t, 1> const c2 = {{ 0xC169 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xC169 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_098)
{
    // C16A;C16A;1109 1167 11BD;C16A;1109 1167 11BD; 
    // (셪; 셪; 셪; 셪; 셪; ) HANGUL SYLLABLE SYEOJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xC16A }};
        std::array<char32_t, 1> const c2 = {{ 0xC16A }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xC16A }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_099)
{
    // C16B;C16B;1109 1167 11BE;C16B;1109 1167 11BE; 
    // (셫; 셫; 셫; 셫; 셫; ) HANGUL SYLLABLE SYEOC
    {
        std::array<char32_t, 1> const c1 = {{ 0xC16B }};
        std::array<char32_t, 1> const c2 = {{ 0xC16B }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xC16B }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_100)
{
    // C16C;C16C;1109 1167 11BF;C16C;1109 1167 11BF; 
    // (셬; 셬; 셬; 셬; 셬; ) HANGUL SYLLABLE SYEOK
    {
        std::array<char32_t, 1> const c1 = {{ 0xC16C }};
        std::array<char32_t, 1> const c2 = {{ 0xC16C }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xC16C }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_101)
{
    // C16D;C16D;1109 1167 11C0;C16D;1109 1167 11C0; 
    // (셭; 셭; 셭; 셭; 셭; ) HANGUL SYLLABLE SYEOT
    {
        std::array<char32_t, 1> const c1 = {{ 0xC16D }};
        std::array<char32_t, 1> const c2 = {{ 0xC16D }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xC16D }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_102)
{
    // C16E;C16E;1109 1167 11C1;C16E;1109 1167 11C1; 
    // (셮; 셮; 셮; 셮; 셮; ) HANGUL SYLLABLE SYEOP
    {
        std::array<char32_t, 1> const c1 = {{ 0xC16E }};
        std::array<char32_t, 1> const c2 = {{ 0xC16E }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xC16E }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_103)
{
    // C16F;C16F;1109 1167 11C2;C16F;1109 1167 11C2; 
    // (셯; 셯; 셯; 셯; 셯; ) HANGUL SYLLABLE SYEOH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC16F }};
        std::array<char32_t, 1> const c2 = {{ 0xC16F }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1167, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xC16F }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1167, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_104)
{
    // C170;C170;1109 1168;C170;1109 1168; 
    // (셰; 셰; 셰; 셰; 셰; ) HANGUL SYLLABLE SYE
    {
        std::array<char32_t, 1> const c1 = {{ 0xC170 }};
        std::array<char32_t, 1> const c2 = {{ 0xC170 }};
        std::array<char32_t, 2> const c3 = {{ 0x1109, 0x1168 }};
        std::array<char32_t, 1> const c4 = {{ 0xC170 }};
        std::array<char32_t, 2> const c5 = {{ 0x1109, 0x1168 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_105)
{
    // C171;C171;1109 1168 11A8;C171;1109 1168 11A8; 
    // (셱; 셱; 셱; 셱; 셱; ) HANGUL SYLLABLE SYEG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC171 }};
        std::array<char32_t, 1> const c2 = {{ 0xC171 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xC171 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_106)
{
    // C172;C172;1109 1168 11A9;C172;1109 1168 11A9; 
    // (셲; 셲; 셲; 셲; 셲; ) HANGUL SYLLABLE SYEGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC172 }};
        std::array<char32_t, 1> const c2 = {{ 0xC172 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xC172 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_107)
{
    // C173;C173;1109 1168 11AA;C173;1109 1168 11AA; 
    // (셳; 셳; 셳; 셳; 셳; ) HANGUL SYLLABLE SYEGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC173 }};
        std::array<char32_t, 1> const c2 = {{ 0xC173 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xC173 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_108)
{
    // C174;C174;1109 1168 11AB;C174;1109 1168 11AB; 
    // (셴; 셴; 셴; 셴; 셴; ) HANGUL SYLLABLE SYEN
    {
        std::array<char32_t, 1> const c1 = {{ 0xC174 }};
        std::array<char32_t, 1> const c2 = {{ 0xC174 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xC174 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_109)
{
    // C175;C175;1109 1168 11AC;C175;1109 1168 11AC; 
    // (셵; 셵; 셵; 셵; 셵; ) HANGUL SYLLABLE SYENJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xC175 }};
        std::array<char32_t, 1> const c2 = {{ 0xC175 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xC175 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_110)
{
    // C176;C176;1109 1168 11AD;C176;1109 1168 11AD; 
    // (셶; 셶; 셶; 셶; 셶; ) HANGUL SYLLABLE SYENH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC176 }};
        std::array<char32_t, 1> const c2 = {{ 0xC176 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xC176 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_111)
{
    // C177;C177;1109 1168 11AE;C177;1109 1168 11AE; 
    // (셷; 셷; 셷; 셷; 셷; ) HANGUL SYLLABLE SYED
    {
        std::array<char32_t, 1> const c1 = {{ 0xC177 }};
        std::array<char32_t, 1> const c2 = {{ 0xC177 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xC177 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_112)
{
    // C178;C178;1109 1168 11AF;C178;1109 1168 11AF; 
    // (셸; 셸; 셸; 셸; 셸; ) HANGUL SYLLABLE SYEL
    {
        std::array<char32_t, 1> const c1 = {{ 0xC178 }};
        std::array<char32_t, 1> const c2 = {{ 0xC178 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xC178 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_113)
{
    // C179;C179;1109 1168 11B0;C179;1109 1168 11B0; 
    // (셹; 셹; 셹; 셹; 셹; ) HANGUL SYLLABLE SYELG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC179 }};
        std::array<char32_t, 1> const c2 = {{ 0xC179 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xC179 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_114)
{
    // C17A;C17A;1109 1168 11B1;C17A;1109 1168 11B1; 
    // (셺; 셺; 셺; 셺; 셺; ) HANGUL SYLLABLE SYELM
    {
        std::array<char32_t, 1> const c1 = {{ 0xC17A }};
        std::array<char32_t, 1> const c2 = {{ 0xC17A }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xC17A }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_115)
{
    // C17B;C17B;1109 1168 11B2;C17B;1109 1168 11B2; 
    // (셻; 셻; 셻; 셻; 셻; ) HANGUL SYLLABLE SYELB
    {
        std::array<char32_t, 1> const c1 = {{ 0xC17B }};
        std::array<char32_t, 1> const c2 = {{ 0xC17B }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xC17B }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_116)
{
    // C17C;C17C;1109 1168 11B3;C17C;1109 1168 11B3; 
    // (셼; 셼; 셼; 셼; 셼; ) HANGUL SYLLABLE SYELS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC17C }};
        std::array<char32_t, 1> const c2 = {{ 0xC17C }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xC17C }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_117)
{
    // C17D;C17D;1109 1168 11B4;C17D;1109 1168 11B4; 
    // (셽; 셽; 셽; 셽; 셽; ) HANGUL SYLLABLE SYELT
    {
        std::array<char32_t, 1> const c1 = {{ 0xC17D }};
        std::array<char32_t, 1> const c2 = {{ 0xC17D }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xC17D }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_118)
{
    // C17E;C17E;1109 1168 11B5;C17E;1109 1168 11B5; 
    // (셾; 셾; 셾; 셾; 셾; ) HANGUL SYLLABLE SYELP
    {
        std::array<char32_t, 1> const c1 = {{ 0xC17E }};
        std::array<char32_t, 1> const c2 = {{ 0xC17E }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xC17E }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_119)
{
    // C17F;C17F;1109 1168 11B6;C17F;1109 1168 11B6; 
    // (셿; 셿; 셿; 셿; 셿; ) HANGUL SYLLABLE SYELH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC17F }};
        std::array<char32_t, 1> const c2 = {{ 0xC17F }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xC17F }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_120)
{
    // C180;C180;1109 1168 11B7;C180;1109 1168 11B7; 
    // (솀; 솀; 솀; 솀; 솀; ) HANGUL SYLLABLE SYEM
    {
        std::array<char32_t, 1> const c1 = {{ 0xC180 }};
        std::array<char32_t, 1> const c2 = {{ 0xC180 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xC180 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_121)
{
    // C181;C181;1109 1168 11B8;C181;1109 1168 11B8; 
    // (솁; 솁; 솁; 솁; 솁; ) HANGUL SYLLABLE SYEB
    {
        std::array<char32_t, 1> const c1 = {{ 0xC181 }};
        std::array<char32_t, 1> const c2 = {{ 0xC181 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xC181 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_122)
{
    // C182;C182;1109 1168 11B9;C182;1109 1168 11B9; 
    // (솂; 솂; 솂; 솂; 솂; ) HANGUL SYLLABLE SYEBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC182 }};
        std::array<char32_t, 1> const c2 = {{ 0xC182 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xC182 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_123)
{
    // C183;C183;1109 1168 11BA;C183;1109 1168 11BA; 
    // (솃; 솃; 솃; 솃; 솃; ) HANGUL SYLLABLE SYES
    {
        std::array<char32_t, 1> const c1 = {{ 0xC183 }};
        std::array<char32_t, 1> const c2 = {{ 0xC183 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xC183 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_124)
{
    // C184;C184;1109 1168 11BB;C184;1109 1168 11BB; 
    // (솄; 솄; 솄; 솄; 솄; ) HANGUL SYLLABLE SYESS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC184 }};
        std::array<char32_t, 1> const c2 = {{ 0xC184 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xC184 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_125)
{
    // C185;C185;1109 1168 11BC;C185;1109 1168 11BC; 
    // (솅; 솅; 솅; 솅; 솅; ) HANGUL SYLLABLE SYENG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC185 }};
        std::array<char32_t, 1> const c2 = {{ 0xC185 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xC185 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_126)
{
    // C186;C186;1109 1168 11BD;C186;1109 1168 11BD; 
    // (솆; 솆; 솆; 솆; 솆; ) HANGUL SYLLABLE SYEJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xC186 }};
        std::array<char32_t, 1> const c2 = {{ 0xC186 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xC186 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_127)
{
    // C187;C187;1109 1168 11BE;C187;1109 1168 11BE; 
    // (솇; 솇; 솇; 솇; 솇; ) HANGUL SYLLABLE SYEC
    {
        std::array<char32_t, 1> const c1 = {{ 0xC187 }};
        std::array<char32_t, 1> const c2 = {{ 0xC187 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xC187 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_128)
{
    // C188;C188;1109 1168 11BF;C188;1109 1168 11BF; 
    // (솈; 솈; 솈; 솈; 솈; ) HANGUL SYLLABLE SYEK
    {
        std::array<char32_t, 1> const c1 = {{ 0xC188 }};
        std::array<char32_t, 1> const c2 = {{ 0xC188 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xC188 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_129)
{
    // C189;C189;1109 1168 11C0;C189;1109 1168 11C0; 
    // (솉; 솉; 솉; 솉; 솉; ) HANGUL SYLLABLE SYET
    {
        std::array<char32_t, 1> const c1 = {{ 0xC189 }};
        std::array<char32_t, 1> const c2 = {{ 0xC189 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xC189 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_130)
{
    // C18A;C18A;1109 1168 11C1;C18A;1109 1168 11C1; 
    // (솊; 솊; 솊; 솊; 솊; ) HANGUL SYLLABLE SYEP
    {
        std::array<char32_t, 1> const c1 = {{ 0xC18A }};
        std::array<char32_t, 1> const c2 = {{ 0xC18A }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xC18A }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_131)
{
    // C18B;C18B;1109 1168 11C2;C18B;1109 1168 11C2; 
    // (솋; 솋; 솋; 솋; 솋; ) HANGUL SYLLABLE SYEH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC18B }};
        std::array<char32_t, 1> const c2 = {{ 0xC18B }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1168, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xC18B }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1168, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_132)
{
    // C18C;C18C;1109 1169;C18C;1109 1169; 
    // (소; 소; 소; 소; 소; ) HANGUL SYLLABLE SO
    {
        std::array<char32_t, 1> const c1 = {{ 0xC18C }};
        std::array<char32_t, 1> const c2 = {{ 0xC18C }};
        std::array<char32_t, 2> const c3 = {{ 0x1109, 0x1169 }};
        std::array<char32_t, 1> const c4 = {{ 0xC18C }};
        std::array<char32_t, 2> const c5 = {{ 0x1109, 0x1169 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_133)
{
    // C18D;C18D;1109 1169 11A8;C18D;1109 1169 11A8; 
    // (속; 속; 속; 속; 속; ) HANGUL SYLLABLE SOG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC18D }};
        std::array<char32_t, 1> const c2 = {{ 0xC18D }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xC18D }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_134)
{
    // C18E;C18E;1109 1169 11A9;C18E;1109 1169 11A9; 
    // (솎; 솎; 솎; 솎; 솎; ) HANGUL SYLLABLE SOGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC18E }};
        std::array<char32_t, 1> const c2 = {{ 0xC18E }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xC18E }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_135)
{
    // C18F;C18F;1109 1169 11AA;C18F;1109 1169 11AA; 
    // (솏; 솏; 솏; 솏; 솏; ) HANGUL SYLLABLE SOGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC18F }};
        std::array<char32_t, 1> const c2 = {{ 0xC18F }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xC18F }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_136)
{
    // C190;C190;1109 1169 11AB;C190;1109 1169 11AB; 
    // (손; 손; 손; 손; 손; ) HANGUL SYLLABLE SON
    {
        std::array<char32_t, 1> const c1 = {{ 0xC190 }};
        std::array<char32_t, 1> const c2 = {{ 0xC190 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xC190 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_137)
{
    // C191;C191;1109 1169 11AC;C191;1109 1169 11AC; 
    // (솑; 솑; 솑; 솑; 솑; ) HANGUL SYLLABLE SONJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xC191 }};
        std::array<char32_t, 1> const c2 = {{ 0xC191 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xC191 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_138)
{
    // C192;C192;1109 1169 11AD;C192;1109 1169 11AD; 
    // (솒; 솒; 솒; 솒; 솒; ) HANGUL SYLLABLE SONH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC192 }};
        std::array<char32_t, 1> const c2 = {{ 0xC192 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xC192 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_139)
{
    // C193;C193;1109 1169 11AE;C193;1109 1169 11AE; 
    // (솓; 솓; 솓; 솓; 솓; ) HANGUL SYLLABLE SOD
    {
        std::array<char32_t, 1> const c1 = {{ 0xC193 }};
        std::array<char32_t, 1> const c2 = {{ 0xC193 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xC193 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_140)
{
    // C194;C194;1109 1169 11AF;C194;1109 1169 11AF; 
    // (솔; 솔; 솔; 솔; 솔; ) HANGUL SYLLABLE SOL
    {
        std::array<char32_t, 1> const c1 = {{ 0xC194 }};
        std::array<char32_t, 1> const c2 = {{ 0xC194 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xC194 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_141)
{
    // C195;C195;1109 1169 11B0;C195;1109 1169 11B0; 
    // (솕; 솕; 솕; 솕; 솕; ) HANGUL SYLLABLE SOLG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC195 }};
        std::array<char32_t, 1> const c2 = {{ 0xC195 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xC195 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_142)
{
    // C196;C196;1109 1169 11B1;C196;1109 1169 11B1; 
    // (솖; 솖; 솖; 솖; 솖; ) HANGUL SYLLABLE SOLM
    {
        std::array<char32_t, 1> const c1 = {{ 0xC196 }};
        std::array<char32_t, 1> const c2 = {{ 0xC196 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xC196 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_143)
{
    // C197;C197;1109 1169 11B2;C197;1109 1169 11B2; 
    // (솗; 솗; 솗; 솗; 솗; ) HANGUL SYLLABLE SOLB
    {
        std::array<char32_t, 1> const c1 = {{ 0xC197 }};
        std::array<char32_t, 1> const c2 = {{ 0xC197 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xC197 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_144)
{
    // C198;C198;1109 1169 11B3;C198;1109 1169 11B3; 
    // (솘; 솘; 솘; 솘; 솘; ) HANGUL SYLLABLE SOLS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC198 }};
        std::array<char32_t, 1> const c2 = {{ 0xC198 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xC198 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_145)
{
    // C199;C199;1109 1169 11B4;C199;1109 1169 11B4; 
    // (솙; 솙; 솙; 솙; 솙; ) HANGUL SYLLABLE SOLT
    {
        std::array<char32_t, 1> const c1 = {{ 0xC199 }};
        std::array<char32_t, 1> const c2 = {{ 0xC199 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xC199 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_146)
{
    // C19A;C19A;1109 1169 11B5;C19A;1109 1169 11B5; 
    // (솚; 솚; 솚; 솚; 솚; ) HANGUL SYLLABLE SOLP
    {
        std::array<char32_t, 1> const c1 = {{ 0xC19A }};
        std::array<char32_t, 1> const c2 = {{ 0xC19A }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xC19A }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_147)
{
    // C19B;C19B;1109 1169 11B6;C19B;1109 1169 11B6; 
    // (솛; 솛; 솛; 솛; 솛; ) HANGUL SYLLABLE SOLH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC19B }};
        std::array<char32_t, 1> const c2 = {{ 0xC19B }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xC19B }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_148)
{
    // C19C;C19C;1109 1169 11B7;C19C;1109 1169 11B7; 
    // (솜; 솜; 솜; 솜; 솜; ) HANGUL SYLLABLE SOM
    {
        std::array<char32_t, 1> const c1 = {{ 0xC19C }};
        std::array<char32_t, 1> const c2 = {{ 0xC19C }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xC19C }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_149)
{
    // C19D;C19D;1109 1169 11B8;C19D;1109 1169 11B8; 
    // (솝; 솝; 솝; 솝; 솝; ) HANGUL SYLLABLE SOB
    {
        std::array<char32_t, 1> const c1 = {{ 0xC19D }};
        std::array<char32_t, 1> const c2 = {{ 0xC19D }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xC19D }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_150)
{
    // C19E;C19E;1109 1169 11B9;C19E;1109 1169 11B9; 
    // (솞; 솞; 솞; 솞; 솞; ) HANGUL SYLLABLE SOBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC19E }};
        std::array<char32_t, 1> const c2 = {{ 0xC19E }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xC19E }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_151)
{
    // C19F;C19F;1109 1169 11BA;C19F;1109 1169 11BA; 
    // (솟; 솟; 솟; 솟; 솟; ) HANGUL SYLLABLE SOS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC19F }};
        std::array<char32_t, 1> const c2 = {{ 0xC19F }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xC19F }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_152)
{
    // C1A0;C1A0;1109 1169 11BB;C1A0;1109 1169 11BB; 
    // (솠; 솠; 솠; 솠; 솠; ) HANGUL SYLLABLE SOSS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1A0 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1A0 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xC1A0 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_153)
{
    // C1A1;C1A1;1109 1169 11BC;C1A1;1109 1169 11BC; 
    // (송; 송; 송; 송; 송; ) HANGUL SYLLABLE SONG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1A1 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1A1 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xC1A1 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_154)
{
    // C1A2;C1A2;1109 1169 11BD;C1A2;1109 1169 11BD; 
    // (솢; 솢; 솢; 솢; 솢; ) HANGUL SYLLABLE SOJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1A2 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1A2 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xC1A2 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_155)
{
    // C1A3;C1A3;1109 1169 11BE;C1A3;1109 1169 11BE; 
    // (솣; 솣; 솣; 솣; 솣; ) HANGUL SYLLABLE SOC
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1A3 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1A3 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xC1A3 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_156)
{
    // C1A4;C1A4;1109 1169 11BF;C1A4;1109 1169 11BF; 
    // (솤; 솤; 솤; 솤; 솤; ) HANGUL SYLLABLE SOK
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1A4 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1A4 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xC1A4 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_157)
{
    // C1A5;C1A5;1109 1169 11C0;C1A5;1109 1169 11C0; 
    // (솥; 솥; 솥; 솥; 솥; ) HANGUL SYLLABLE SOT
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1A5 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1A5 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xC1A5 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_158)
{
    // C1A6;C1A6;1109 1169 11C1;C1A6;1109 1169 11C1; 
    // (솦; 솦; 솦; 솦; 솦; ) HANGUL SYLLABLE SOP
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1A6 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1A6 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xC1A6 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_159)
{
    // C1A7;C1A7;1109 1169 11C2;C1A7;1109 1169 11C2; 
    // (솧; 솧; 솧; 솧; 솧; ) HANGUL SYLLABLE SOH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1A7 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1A7 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x1169, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xC1A7 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x1169, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_160)
{
    // C1A8;C1A8;1109 116A;C1A8;1109 116A; 
    // (솨; 솨; 솨; 솨; 솨; ) HANGUL SYLLABLE SWA
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1A8 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1A8 }};
        std::array<char32_t, 2> const c3 = {{ 0x1109, 0x116A }};
        std::array<char32_t, 1> const c4 = {{ 0xC1A8 }};
        std::array<char32_t, 2> const c5 = {{ 0x1109, 0x116A }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_161)
{
    // C1A9;C1A9;1109 116A 11A8;C1A9;1109 116A 11A8; 
    // (솩; 솩; 솩; 솩; 솩; ) HANGUL SYLLABLE SWAG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1A9 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1A9 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xC1A9 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_162)
{
    // C1AA;C1AA;1109 116A 11A9;C1AA;1109 116A 11A9; 
    // (솪; 솪; 솪; 솪; 솪; ) HANGUL SYLLABLE SWAGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1AA }};
        std::array<char32_t, 1> const c2 = {{ 0xC1AA }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xC1AA }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_163)
{
    // C1AB;C1AB;1109 116A 11AA;C1AB;1109 116A 11AA; 
    // (솫; 솫; 솫; 솫; 솫; ) HANGUL SYLLABLE SWAGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1AB }};
        std::array<char32_t, 1> const c2 = {{ 0xC1AB }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xC1AB }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_164)
{
    // C1AC;C1AC;1109 116A 11AB;C1AC;1109 116A 11AB; 
    // (솬; 솬; 솬; 솬; 솬; ) HANGUL SYLLABLE SWAN
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1AC }};
        std::array<char32_t, 1> const c2 = {{ 0xC1AC }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xC1AC }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_165)
{
    // C1AD;C1AD;1109 116A 11AC;C1AD;1109 116A 11AC; 
    // (솭; 솭; 솭; 솭; 솭; ) HANGUL SYLLABLE SWANJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1AD }};
        std::array<char32_t, 1> const c2 = {{ 0xC1AD }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xC1AD }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_166)
{
    // C1AE;C1AE;1109 116A 11AD;C1AE;1109 116A 11AD; 
    // (솮; 솮; 솮; 솮; 솮; ) HANGUL SYLLABLE SWANH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1AE }};
        std::array<char32_t, 1> const c2 = {{ 0xC1AE }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xC1AE }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_167)
{
    // C1AF;C1AF;1109 116A 11AE;C1AF;1109 116A 11AE; 
    // (솯; 솯; 솯; 솯; 솯; ) HANGUL SYLLABLE SWAD
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1AF }};
        std::array<char32_t, 1> const c2 = {{ 0xC1AF }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xC1AF }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_168)
{
    // C1B0;C1B0;1109 116A 11AF;C1B0;1109 116A 11AF; 
    // (솰; 솰; 솰; 솰; 솰; ) HANGUL SYLLABLE SWAL
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1B0 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1B0 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xC1B0 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_169)
{
    // C1B1;C1B1;1109 116A 11B0;C1B1;1109 116A 11B0; 
    // (솱; 솱; 솱; 솱; 솱; ) HANGUL SYLLABLE SWALG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1B1 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1B1 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xC1B1 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_170)
{
    // C1B2;C1B2;1109 116A 11B1;C1B2;1109 116A 11B1; 
    // (솲; 솲; 솲; 솲; 솲; ) HANGUL SYLLABLE SWALM
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1B2 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1B2 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xC1B2 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_171)
{
    // C1B3;C1B3;1109 116A 11B2;C1B3;1109 116A 11B2; 
    // (솳; 솳; 솳; 솳; 솳; ) HANGUL SYLLABLE SWALB
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1B3 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1B3 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xC1B3 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_172)
{
    // C1B4;C1B4;1109 116A 11B3;C1B4;1109 116A 11B3; 
    // (솴; 솴; 솴; 솴; 솴; ) HANGUL SYLLABLE SWALS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1B4 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1B4 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xC1B4 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_173)
{
    // C1B5;C1B5;1109 116A 11B4;C1B5;1109 116A 11B4; 
    // (솵; 솵; 솵; 솵; 솵; ) HANGUL SYLLABLE SWALT
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1B5 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1B5 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xC1B5 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_174)
{
    // C1B6;C1B6;1109 116A 11B5;C1B6;1109 116A 11B5; 
    // (솶; 솶; 솶; 솶; 솶; ) HANGUL SYLLABLE SWALP
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1B6 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1B6 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xC1B6 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_175)
{
    // C1B7;C1B7;1109 116A 11B6;C1B7;1109 116A 11B6; 
    // (솷; 솷; 솷; 솷; 솷; ) HANGUL SYLLABLE SWALH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1B7 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1B7 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xC1B7 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_176)
{
    // C1B8;C1B8;1109 116A 11B7;C1B8;1109 116A 11B7; 
    // (솸; 솸; 솸; 솸; 솸; ) HANGUL SYLLABLE SWAM
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1B8 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1B8 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xC1B8 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_177)
{
    // C1B9;C1B9;1109 116A 11B8;C1B9;1109 116A 11B8; 
    // (솹; 솹; 솹; 솹; 솹; ) HANGUL SYLLABLE SWAB
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1B9 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1B9 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xC1B9 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_178)
{
    // C1BA;C1BA;1109 116A 11B9;C1BA;1109 116A 11B9; 
    // (솺; 솺; 솺; 솺; 솺; ) HANGUL SYLLABLE SWABS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1BA }};
        std::array<char32_t, 1> const c2 = {{ 0xC1BA }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xC1BA }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_179)
{
    // C1BB;C1BB;1109 116A 11BA;C1BB;1109 116A 11BA; 
    // (솻; 솻; 솻; 솻; 솻; ) HANGUL SYLLABLE SWAS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1BB }};
        std::array<char32_t, 1> const c2 = {{ 0xC1BB }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xC1BB }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_180)
{
    // C1BC;C1BC;1109 116A 11BB;C1BC;1109 116A 11BB; 
    // (솼; 솼; 솼; 솼; 솼; ) HANGUL SYLLABLE SWASS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1BC }};
        std::array<char32_t, 1> const c2 = {{ 0xC1BC }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xC1BC }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_181)
{
    // C1BD;C1BD;1109 116A 11BC;C1BD;1109 116A 11BC; 
    // (솽; 솽; 솽; 솽; 솽; ) HANGUL SYLLABLE SWANG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1BD }};
        std::array<char32_t, 1> const c2 = {{ 0xC1BD }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xC1BD }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_182)
{
    // C1BE;C1BE;1109 116A 11BD;C1BE;1109 116A 11BD; 
    // (솾; 솾; 솾; 솾; 솾; ) HANGUL SYLLABLE SWAJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1BE }};
        std::array<char32_t, 1> const c2 = {{ 0xC1BE }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xC1BE }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_183)
{
    // C1BF;C1BF;1109 116A 11BE;C1BF;1109 116A 11BE; 
    // (솿; 솿; 솿; 솿; 솿; ) HANGUL SYLLABLE SWAC
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1BF }};
        std::array<char32_t, 1> const c2 = {{ 0xC1BF }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xC1BF }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_184)
{
    // C1C0;C1C0;1109 116A 11BF;C1C0;1109 116A 11BF; 
    // (쇀; 쇀; 쇀; 쇀; 쇀; ) HANGUL SYLLABLE SWAK
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1C0 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1C0 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xC1C0 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_185)
{
    // C1C1;C1C1;1109 116A 11C0;C1C1;1109 116A 11C0; 
    // (쇁; 쇁; 쇁; 쇁; 쇁; ) HANGUL SYLLABLE SWAT
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1C1 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1C1 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xC1C1 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_186)
{
    // C1C2;C1C2;1109 116A 11C1;C1C2;1109 116A 11C1; 
    // (쇂; 쇂; 쇂; 쇂; 쇂; ) HANGUL SYLLABLE SWAP
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1C2 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1C2 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xC1C2 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_187)
{
    // C1C3;C1C3;1109 116A 11C2;C1C3;1109 116A 11C2; 
    // (쇃; 쇃; 쇃; 쇃; 쇃; ) HANGUL SYLLABLE SWAH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1C3 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1C3 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116A, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xC1C3 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116A, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_188)
{
    // C1C4;C1C4;1109 116B;C1C4;1109 116B; 
    // (쇄; 쇄; 쇄; 쇄; 쇄; ) HANGUL SYLLABLE SWAE
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1C4 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1C4 }};
        std::array<char32_t, 2> const c3 = {{ 0x1109, 0x116B }};
        std::array<char32_t, 1> const c4 = {{ 0xC1C4 }};
        std::array<char32_t, 2> const c5 = {{ 0x1109, 0x116B }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_189)
{
    // C1C5;C1C5;1109 116B 11A8;C1C5;1109 116B 11A8; 
    // (쇅; 쇅; 쇅; 쇅; 쇅; ) HANGUL SYLLABLE SWAEG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1C5 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1C5 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xC1C5 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_190)
{
    // C1C6;C1C6;1109 116B 11A9;C1C6;1109 116B 11A9; 
    // (쇆; 쇆; 쇆; 쇆; 쇆; ) HANGUL SYLLABLE SWAEGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1C6 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1C6 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xC1C6 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_191)
{
    // C1C7;C1C7;1109 116B 11AA;C1C7;1109 116B 11AA; 
    // (쇇; 쇇; 쇇; 쇇; 쇇; ) HANGUL SYLLABLE SWAEGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1C7 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1C7 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xC1C7 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_192)
{
    // C1C8;C1C8;1109 116B 11AB;C1C8;1109 116B 11AB; 
    // (쇈; 쇈; 쇈; 쇈; 쇈; ) HANGUL SYLLABLE SWAEN
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1C8 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1C8 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xC1C8 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_193)
{
    // C1C9;C1C9;1109 116B 11AC;C1C9;1109 116B 11AC; 
    // (쇉; 쇉; 쇉; 쇉; 쇉; ) HANGUL SYLLABLE SWAENJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1C9 }};
        std::array<char32_t, 1> const c2 = {{ 0xC1C9 }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xC1C9 }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_194)
{
    // C1CA;C1CA;1109 116B 11AD;C1CA;1109 116B 11AD; 
    // (쇊; 쇊; 쇊; 쇊; 쇊; ) HANGUL SYLLABLE SWAENH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1CA }};
        std::array<char32_t, 1> const c2 = {{ 0xC1CA }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xC1CA }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_195)
{
    // C1CB;C1CB;1109 116B 11AE;C1CB;1109 116B 11AE; 
    // (쇋; 쇋; 쇋; 쇋; 쇋; ) HANGUL SYLLABLE SWAED
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1CB }};
        std::array<char32_t, 1> const c2 = {{ 0xC1CB }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xC1CB }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_196)
{
    // C1CC;C1CC;1109 116B 11AF;C1CC;1109 116B 11AF; 
    // (쇌; 쇌; 쇌; 쇌; 쇌; ) HANGUL SYLLABLE SWAEL
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1CC }};
        std::array<char32_t, 1> const c2 = {{ 0xC1CC }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xC1CC }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_197)
{
    // C1CD;C1CD;1109 116B 11B0;C1CD;1109 116B 11B0; 
    // (쇍; 쇍; 쇍; 쇍; 쇍; ) HANGUL SYLLABLE SWAELG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1CD }};
        std::array<char32_t, 1> const c2 = {{ 0xC1CD }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xC1CD }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_198)
{
    // C1CE;C1CE;1109 116B 11B1;C1CE;1109 116B 11B1; 
    // (쇎; 쇎; 쇎; 쇎; 쇎; ) HANGUL SYLLABLE SWAELM
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1CE }};
        std::array<char32_t, 1> const c2 = {{ 0xC1CE }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xC1CE }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_039_199)
{
    // C1CF;C1CF;1109 116B 11B2;C1CF;1109 116B 11B2; 
    // (쇏; 쇏; 쇏; 쇏; 쇏; ) HANGUL SYLLABLE SWAELB
    {
        std::array<char32_t, 1> const c1 = {{ 0xC1CF }};
        std::array<char32_t, 1> const c2 = {{ 0xC1CF }};
        std::array<char32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xC1CF }};
        std::array<char32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


