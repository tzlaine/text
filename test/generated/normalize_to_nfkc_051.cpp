// Copyright (C) 2020 T. Zachary Laine
//
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

// Warning! This file is autogenerated.
#include <boost/text/normalize_string.hpp>
#include <boost/text/transcode_view.hpp>
#include <boost/text/string_utility.hpp>

#include <gtest/gtest.h>

#include <algorithm>



TEST(normalization, nfkc_051_000)
{
    // CA68;CA68;110D 1166;CA68;110D 1166; 
    // (쩨; 쩨; 쩨; 쩨; 쩨; ) HANGUL SYLLABLE JJE
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA68 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA68 }};
        std::array<char32_t, 2> const c3 = {{ 0x110D, 0x1166 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA68 }};
        std::array<char32_t, 2> const c5 = {{ 0x110D, 0x1166 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_001)
{
    // CA69;CA69;110D 1166 11A8;CA69;110D 1166 11A8; 
    // (쩩; 쩩; 쩩; 쩩; 쩩; ) HANGUL SYLLABLE JJEG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA69 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA69 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA69 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_002)
{
    // CA6A;CA6A;110D 1166 11A9;CA6A;110D 1166 11A9; 
    // (쩪; 쩪; 쩪; 쩪; 쩪; ) HANGUL SYLLABLE JJEGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA6A }};
        std::array<char32_t, 1> const c2 = {{ 0xCA6A }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA6A }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_003)
{
    // CA6B;CA6B;110D 1166 11AA;CA6B;110D 1166 11AA; 
    // (쩫; 쩫; 쩫; 쩫; 쩫; ) HANGUL SYLLABLE JJEGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA6B }};
        std::array<char32_t, 1> const c2 = {{ 0xCA6B }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xCA6B }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_004)
{
    // CA6C;CA6C;110D 1166 11AB;CA6C;110D 1166 11AB; 
    // (쩬; 쩬; 쩬; 쩬; 쩬; ) HANGUL SYLLABLE JJEN
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA6C }};
        std::array<char32_t, 1> const c2 = {{ 0xCA6C }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xCA6C }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_005)
{
    // CA6D;CA6D;110D 1166 11AC;CA6D;110D 1166 11AC; 
    // (쩭; 쩭; 쩭; 쩭; 쩭; ) HANGUL SYLLABLE JJENJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA6D }};
        std::array<char32_t, 1> const c2 = {{ 0xCA6D }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xCA6D }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_006)
{
    // CA6E;CA6E;110D 1166 11AD;CA6E;110D 1166 11AD; 
    // (쩮; 쩮; 쩮; 쩮; 쩮; ) HANGUL SYLLABLE JJENH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA6E }};
        std::array<char32_t, 1> const c2 = {{ 0xCA6E }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xCA6E }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_007)
{
    // CA6F;CA6F;110D 1166 11AE;CA6F;110D 1166 11AE; 
    // (쩯; 쩯; 쩯; 쩯; 쩯; ) HANGUL SYLLABLE JJED
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA6F }};
        std::array<char32_t, 1> const c2 = {{ 0xCA6F }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xCA6F }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_008)
{
    // CA70;CA70;110D 1166 11AF;CA70;110D 1166 11AF; 
    // (쩰; 쩰; 쩰; 쩰; 쩰; ) HANGUL SYLLABLE JJEL
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA70 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA70 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xCA70 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_009)
{
    // CA71;CA71;110D 1166 11B0;CA71;110D 1166 11B0; 
    // (쩱; 쩱; 쩱; 쩱; 쩱; ) HANGUL SYLLABLE JJELG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA71 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA71 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA71 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_010)
{
    // CA72;CA72;110D 1166 11B1;CA72;110D 1166 11B1; 
    // (쩲; 쩲; 쩲; 쩲; 쩲; ) HANGUL SYLLABLE JJELM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA72 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA72 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA72 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_011)
{
    // CA73;CA73;110D 1166 11B2;CA73;110D 1166 11B2; 
    // (쩳; 쩳; 쩳; 쩳; 쩳; ) HANGUL SYLLABLE JJELB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA73 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA73 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA73 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_012)
{
    // CA74;CA74;110D 1166 11B3;CA74;110D 1166 11B3; 
    // (쩴; 쩴; 쩴; 쩴; 쩴; ) HANGUL SYLLABLE JJELS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA74 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA74 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA74 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_013)
{
    // CA75;CA75;110D 1166 11B4;CA75;110D 1166 11B4; 
    // (쩵; 쩵; 쩵; 쩵; 쩵; ) HANGUL SYLLABLE JJELT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA75 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA75 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA75 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_014)
{
    // CA76;CA76;110D 1166 11B5;CA76;110D 1166 11B5; 
    // (쩶; 쩶; 쩶; 쩶; 쩶; ) HANGUL SYLLABLE JJELP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA76 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA76 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA76 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_015)
{
    // CA77;CA77;110D 1166 11B6;CA77;110D 1166 11B6; 
    // (쩷; 쩷; 쩷; 쩷; 쩷; ) HANGUL SYLLABLE JJELH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA77 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA77 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA77 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_016)
{
    // CA78;CA78;110D 1166 11B7;CA78;110D 1166 11B7; 
    // (쩸; 쩸; 쩸; 쩸; 쩸; ) HANGUL SYLLABLE JJEM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA78 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA78 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA78 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_017)
{
    // CA79;CA79;110D 1166 11B8;CA79;110D 1166 11B8; 
    // (쩹; 쩹; 쩹; 쩹; 쩹; ) HANGUL SYLLABLE JJEB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA79 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA79 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA79 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_018)
{
    // CA7A;CA7A;110D 1166 11B9;CA7A;110D 1166 11B9; 
    // (쩺; 쩺; 쩺; 쩺; 쩺; ) HANGUL SYLLABLE JJEBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA7A }};
        std::array<char32_t, 1> const c2 = {{ 0xCA7A }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA7A }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_019)
{
    // CA7B;CA7B;110D 1166 11BA;CA7B;110D 1166 11BA; 
    // (쩻; 쩻; 쩻; 쩻; 쩻; ) HANGUL SYLLABLE JJES
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA7B }};
        std::array<char32_t, 1> const c2 = {{ 0xCA7B }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xCA7B }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_020)
{
    // CA7C;CA7C;110D 1166 11BB;CA7C;110D 1166 11BB; 
    // (쩼; 쩼; 쩼; 쩼; 쩼; ) HANGUL SYLLABLE JJESS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA7C }};
        std::array<char32_t, 1> const c2 = {{ 0xCA7C }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xCA7C }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_021)
{
    // CA7D;CA7D;110D 1166 11BC;CA7D;110D 1166 11BC; 
    // (쩽; 쩽; 쩽; 쩽; 쩽; ) HANGUL SYLLABLE JJENG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA7D }};
        std::array<char32_t, 1> const c2 = {{ 0xCA7D }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xCA7D }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_022)
{
    // CA7E;CA7E;110D 1166 11BD;CA7E;110D 1166 11BD; 
    // (쩾; 쩾; 쩾; 쩾; 쩾; ) HANGUL SYLLABLE JJEJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA7E }};
        std::array<char32_t, 1> const c2 = {{ 0xCA7E }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xCA7E }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_023)
{
    // CA7F;CA7F;110D 1166 11BE;CA7F;110D 1166 11BE; 
    // (쩿; 쩿; 쩿; 쩿; 쩿; ) HANGUL SYLLABLE JJEC
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA7F }};
        std::array<char32_t, 1> const c2 = {{ 0xCA7F }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xCA7F }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_024)
{
    // CA80;CA80;110D 1166 11BF;CA80;110D 1166 11BF; 
    // (쪀; 쪀; 쪀; 쪀; 쪀; ) HANGUL SYLLABLE JJEK
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA80 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA80 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xCA80 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_025)
{
    // CA81;CA81;110D 1166 11C0;CA81;110D 1166 11C0; 
    // (쪁; 쪁; 쪁; 쪁; 쪁; ) HANGUL SYLLABLE JJET
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA81 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA81 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA81 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_026)
{
    // CA82;CA82;110D 1166 11C1;CA82;110D 1166 11C1; 
    // (쪂; 쪂; 쪂; 쪂; 쪂; ) HANGUL SYLLABLE JJEP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA82 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA82 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA82 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_027)
{
    // CA83;CA83;110D 1166 11C2;CA83;110D 1166 11C2; 
    // (쪃; 쪃; 쪃; 쪃; 쪃; ) HANGUL SYLLABLE JJEH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA83 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA83 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1166, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA83 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1166, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_028)
{
    // CA84;CA84;110D 1167;CA84;110D 1167; 
    // (쪄; 쪄; 쪄; 쪄; 쪄; ) HANGUL SYLLABLE JJYEO
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA84 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA84 }};
        std::array<char32_t, 2> const c3 = {{ 0x110D, 0x1167 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA84 }};
        std::array<char32_t, 2> const c5 = {{ 0x110D, 0x1167 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_029)
{
    // CA85;CA85;110D 1167 11A8;CA85;110D 1167 11A8; 
    // (쪅; 쪅; 쪅; 쪅; 쪅; ) HANGUL SYLLABLE JJYEOG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA85 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA85 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA85 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_030)
{
    // CA86;CA86;110D 1167 11A9;CA86;110D 1167 11A9; 
    // (쪆; 쪆; 쪆; 쪆; 쪆; ) HANGUL SYLLABLE JJYEOGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA86 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA86 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA86 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_031)
{
    // CA87;CA87;110D 1167 11AA;CA87;110D 1167 11AA; 
    // (쪇; 쪇; 쪇; 쪇; 쪇; ) HANGUL SYLLABLE JJYEOGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA87 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA87 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xCA87 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_032)
{
    // CA88;CA88;110D 1167 11AB;CA88;110D 1167 11AB; 
    // (쪈; 쪈; 쪈; 쪈; 쪈; ) HANGUL SYLLABLE JJYEON
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA88 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA88 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xCA88 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_033)
{
    // CA89;CA89;110D 1167 11AC;CA89;110D 1167 11AC; 
    // (쪉; 쪉; 쪉; 쪉; 쪉; ) HANGUL SYLLABLE JJYEONJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA89 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA89 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xCA89 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_034)
{
    // CA8A;CA8A;110D 1167 11AD;CA8A;110D 1167 11AD; 
    // (쪊; 쪊; 쪊; 쪊; 쪊; ) HANGUL SYLLABLE JJYEONH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA8A }};
        std::array<char32_t, 1> const c2 = {{ 0xCA8A }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xCA8A }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_035)
{
    // CA8B;CA8B;110D 1167 11AE;CA8B;110D 1167 11AE; 
    // (쪋; 쪋; 쪋; 쪋; 쪋; ) HANGUL SYLLABLE JJYEOD
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA8B }};
        std::array<char32_t, 1> const c2 = {{ 0xCA8B }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xCA8B }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_036)
{
    // CA8C;CA8C;110D 1167 11AF;CA8C;110D 1167 11AF; 
    // (쪌; 쪌; 쪌; 쪌; 쪌; ) HANGUL SYLLABLE JJYEOL
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA8C }};
        std::array<char32_t, 1> const c2 = {{ 0xCA8C }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xCA8C }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_037)
{
    // CA8D;CA8D;110D 1167 11B0;CA8D;110D 1167 11B0; 
    // (쪍; 쪍; 쪍; 쪍; 쪍; ) HANGUL SYLLABLE JJYEOLG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA8D }};
        std::array<char32_t, 1> const c2 = {{ 0xCA8D }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA8D }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_038)
{
    // CA8E;CA8E;110D 1167 11B1;CA8E;110D 1167 11B1; 
    // (쪎; 쪎; 쪎; 쪎; 쪎; ) HANGUL SYLLABLE JJYEOLM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA8E }};
        std::array<char32_t, 1> const c2 = {{ 0xCA8E }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA8E }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_039)
{
    // CA8F;CA8F;110D 1167 11B2;CA8F;110D 1167 11B2; 
    // (쪏; 쪏; 쪏; 쪏; 쪏; ) HANGUL SYLLABLE JJYEOLB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA8F }};
        std::array<char32_t, 1> const c2 = {{ 0xCA8F }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA8F }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_040)
{
    // CA90;CA90;110D 1167 11B3;CA90;110D 1167 11B3; 
    // (쪐; 쪐; 쪐; 쪐; 쪐; ) HANGUL SYLLABLE JJYEOLS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA90 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA90 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA90 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_041)
{
    // CA91;CA91;110D 1167 11B4;CA91;110D 1167 11B4; 
    // (쪑; 쪑; 쪑; 쪑; 쪑; ) HANGUL SYLLABLE JJYEOLT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA91 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA91 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA91 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_042)
{
    // CA92;CA92;110D 1167 11B5;CA92;110D 1167 11B5; 
    // (쪒; 쪒; 쪒; 쪒; 쪒; ) HANGUL SYLLABLE JJYEOLP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA92 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA92 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA92 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_043)
{
    // CA93;CA93;110D 1167 11B6;CA93;110D 1167 11B6; 
    // (쪓; 쪓; 쪓; 쪓; 쪓; ) HANGUL SYLLABLE JJYEOLH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA93 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA93 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA93 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_044)
{
    // CA94;CA94;110D 1167 11B7;CA94;110D 1167 11B7; 
    // (쪔; 쪔; 쪔; 쪔; 쪔; ) HANGUL SYLLABLE JJYEOM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA94 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA94 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA94 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_045)
{
    // CA95;CA95;110D 1167 11B8;CA95;110D 1167 11B8; 
    // (쪕; 쪕; 쪕; 쪕; 쪕; ) HANGUL SYLLABLE JJYEOB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA95 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA95 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA95 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_046)
{
    // CA96;CA96;110D 1167 11B9;CA96;110D 1167 11B9; 
    // (쪖; 쪖; 쪖; 쪖; 쪖; ) HANGUL SYLLABLE JJYEOBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA96 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA96 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA96 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_047)
{
    // CA97;CA97;110D 1167 11BA;CA97;110D 1167 11BA; 
    // (쪗; 쪗; 쪗; 쪗; 쪗; ) HANGUL SYLLABLE JJYEOS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA97 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA97 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xCA97 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_048)
{
    // CA98;CA98;110D 1167 11BB;CA98;110D 1167 11BB; 
    // (쪘; 쪘; 쪘; 쪘; 쪘; ) HANGUL SYLLABLE JJYEOSS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA98 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA98 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xCA98 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_049)
{
    // CA99;CA99;110D 1167 11BC;CA99;110D 1167 11BC; 
    // (쪙; 쪙; 쪙; 쪙; 쪙; ) HANGUL SYLLABLE JJYEONG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA99 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA99 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xCA99 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_050)
{
    // CA9A;CA9A;110D 1167 11BD;CA9A;110D 1167 11BD; 
    // (쪚; 쪚; 쪚; 쪚; 쪚; ) HANGUL SYLLABLE JJYEOJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA9A }};
        std::array<char32_t, 1> const c2 = {{ 0xCA9A }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xCA9A }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_051)
{
    // CA9B;CA9B;110D 1167 11BE;CA9B;110D 1167 11BE; 
    // (쪛; 쪛; 쪛; 쪛; 쪛; ) HANGUL SYLLABLE JJYEOC
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA9B }};
        std::array<char32_t, 1> const c2 = {{ 0xCA9B }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xCA9B }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_052)
{
    // CA9C;CA9C;110D 1167 11BF;CA9C;110D 1167 11BF; 
    // (쪜; 쪜; 쪜; 쪜; 쪜; ) HANGUL SYLLABLE JJYEOK
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA9C }};
        std::array<char32_t, 1> const c2 = {{ 0xCA9C }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xCA9C }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_053)
{
    // CA9D;CA9D;110D 1167 11C0;CA9D;110D 1167 11C0; 
    // (쪝; 쪝; 쪝; 쪝; 쪝; ) HANGUL SYLLABLE JJYEOT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA9D }};
        std::array<char32_t, 1> const c2 = {{ 0xCA9D }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA9D }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_054)
{
    // CA9E;CA9E;110D 1167 11C1;CA9E;110D 1167 11C1; 
    // (쪞; 쪞; 쪞; 쪞; 쪞; ) HANGUL SYLLABLE JJYEOP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA9E }};
        std::array<char32_t, 1> const c2 = {{ 0xCA9E }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA9E }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_055)
{
    // CA9F;CA9F;110D 1167 11C2;CA9F;110D 1167 11C2; 
    // (쪟; 쪟; 쪟; 쪟; 쪟; ) HANGUL SYLLABLE JJYEOH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA9F }};
        std::array<char32_t, 1> const c2 = {{ 0xCA9F }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1167, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA9F }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1167, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_056)
{
    // CAA0;CAA0;110D 1168;CAA0;110D 1168; 
    // (쪠; 쪠; 쪠; 쪠; 쪠; ) HANGUL SYLLABLE JJYE
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAA0 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAA0 }};
        std::array<char32_t, 2> const c3 = {{ 0x110D, 0x1168 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAA0 }};
        std::array<char32_t, 2> const c5 = {{ 0x110D, 0x1168 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_057)
{
    // CAA1;CAA1;110D 1168 11A8;CAA1;110D 1168 11A8; 
    // (쪡; 쪡; 쪡; 쪡; 쪡; ) HANGUL SYLLABLE JJYEG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAA1 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAA1 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAA1 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_058)
{
    // CAA2;CAA2;110D 1168 11A9;CAA2;110D 1168 11A9; 
    // (쪢; 쪢; 쪢; 쪢; 쪢; ) HANGUL SYLLABLE JJYEGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAA2 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAA2 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAA2 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_059)
{
    // CAA3;CAA3;110D 1168 11AA;CAA3;110D 1168 11AA; 
    // (쪣; 쪣; 쪣; 쪣; 쪣; ) HANGUL SYLLABLE JJYEGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAA3 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAA3 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xCAA3 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_060)
{
    // CAA4;CAA4;110D 1168 11AB;CAA4;110D 1168 11AB; 
    // (쪤; 쪤; 쪤; 쪤; 쪤; ) HANGUL SYLLABLE JJYEN
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAA4 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAA4 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xCAA4 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_061)
{
    // CAA5;CAA5;110D 1168 11AC;CAA5;110D 1168 11AC; 
    // (쪥; 쪥; 쪥; 쪥; 쪥; ) HANGUL SYLLABLE JJYENJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAA5 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAA5 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xCAA5 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_062)
{
    // CAA6;CAA6;110D 1168 11AD;CAA6;110D 1168 11AD; 
    // (쪦; 쪦; 쪦; 쪦; 쪦; ) HANGUL SYLLABLE JJYENH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAA6 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAA6 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xCAA6 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_063)
{
    // CAA7;CAA7;110D 1168 11AE;CAA7;110D 1168 11AE; 
    // (쪧; 쪧; 쪧; 쪧; 쪧; ) HANGUL SYLLABLE JJYED
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAA7 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAA7 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xCAA7 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_064)
{
    // CAA8;CAA8;110D 1168 11AF;CAA8;110D 1168 11AF; 
    // (쪨; 쪨; 쪨; 쪨; 쪨; ) HANGUL SYLLABLE JJYEL
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAA8 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAA8 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xCAA8 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_065)
{
    // CAA9;CAA9;110D 1168 11B0;CAA9;110D 1168 11B0; 
    // (쪩; 쪩; 쪩; 쪩; 쪩; ) HANGUL SYLLABLE JJYELG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAA9 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAA9 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAA9 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_066)
{
    // CAAA;CAAA;110D 1168 11B1;CAAA;110D 1168 11B1; 
    // (쪪; 쪪; 쪪; 쪪; 쪪; ) HANGUL SYLLABLE JJYELM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAAA }};
        std::array<char32_t, 1> const c2 = {{ 0xCAAA }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAAA }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_067)
{
    // CAAB;CAAB;110D 1168 11B2;CAAB;110D 1168 11B2; 
    // (쪫; 쪫; 쪫; 쪫; 쪫; ) HANGUL SYLLABLE JJYELB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAAB }};
        std::array<char32_t, 1> const c2 = {{ 0xCAAB }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAAB }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_068)
{
    // CAAC;CAAC;110D 1168 11B3;CAAC;110D 1168 11B3; 
    // (쪬; 쪬; 쪬; 쪬; 쪬; ) HANGUL SYLLABLE JJYELS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAAC }};
        std::array<char32_t, 1> const c2 = {{ 0xCAAC }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAAC }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_069)
{
    // CAAD;CAAD;110D 1168 11B4;CAAD;110D 1168 11B4; 
    // (쪭; 쪭; 쪭; 쪭; 쪭; ) HANGUL SYLLABLE JJYELT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAAD }};
        std::array<char32_t, 1> const c2 = {{ 0xCAAD }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAAD }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_070)
{
    // CAAE;CAAE;110D 1168 11B5;CAAE;110D 1168 11B5; 
    // (쪮; 쪮; 쪮; 쪮; 쪮; ) HANGUL SYLLABLE JJYELP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAAE }};
        std::array<char32_t, 1> const c2 = {{ 0xCAAE }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAAE }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_071)
{
    // CAAF;CAAF;110D 1168 11B6;CAAF;110D 1168 11B6; 
    // (쪯; 쪯; 쪯; 쪯; 쪯; ) HANGUL SYLLABLE JJYELH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAAF }};
        std::array<char32_t, 1> const c2 = {{ 0xCAAF }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAAF }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_072)
{
    // CAB0;CAB0;110D 1168 11B7;CAB0;110D 1168 11B7; 
    // (쪰; 쪰; 쪰; 쪰; 쪰; ) HANGUL SYLLABLE JJYEM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAB0 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAB0 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAB0 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_073)
{
    // CAB1;CAB1;110D 1168 11B8;CAB1;110D 1168 11B8; 
    // (쪱; 쪱; 쪱; 쪱; 쪱; ) HANGUL SYLLABLE JJYEB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAB1 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAB1 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAB1 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_074)
{
    // CAB2;CAB2;110D 1168 11B9;CAB2;110D 1168 11B9; 
    // (쪲; 쪲; 쪲; 쪲; 쪲; ) HANGUL SYLLABLE JJYEBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAB2 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAB2 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAB2 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_075)
{
    // CAB3;CAB3;110D 1168 11BA;CAB3;110D 1168 11BA; 
    // (쪳; 쪳; 쪳; 쪳; 쪳; ) HANGUL SYLLABLE JJYES
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAB3 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAB3 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xCAB3 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_076)
{
    // CAB4;CAB4;110D 1168 11BB;CAB4;110D 1168 11BB; 
    // (쪴; 쪴; 쪴; 쪴; 쪴; ) HANGUL SYLLABLE JJYESS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAB4 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAB4 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xCAB4 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_077)
{
    // CAB5;CAB5;110D 1168 11BC;CAB5;110D 1168 11BC; 
    // (쪵; 쪵; 쪵; 쪵; 쪵; ) HANGUL SYLLABLE JJYENG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAB5 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAB5 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xCAB5 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_078)
{
    // CAB6;CAB6;110D 1168 11BD;CAB6;110D 1168 11BD; 
    // (쪶; 쪶; 쪶; 쪶; 쪶; ) HANGUL SYLLABLE JJYEJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAB6 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAB6 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xCAB6 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_079)
{
    // CAB7;CAB7;110D 1168 11BE;CAB7;110D 1168 11BE; 
    // (쪷; 쪷; 쪷; 쪷; 쪷; ) HANGUL SYLLABLE JJYEC
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAB7 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAB7 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xCAB7 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_080)
{
    // CAB8;CAB8;110D 1168 11BF;CAB8;110D 1168 11BF; 
    // (쪸; 쪸; 쪸; 쪸; 쪸; ) HANGUL SYLLABLE JJYEK
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAB8 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAB8 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xCAB8 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_081)
{
    // CAB9;CAB9;110D 1168 11C0;CAB9;110D 1168 11C0; 
    // (쪹; 쪹; 쪹; 쪹; 쪹; ) HANGUL SYLLABLE JJYET
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAB9 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAB9 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAB9 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_082)
{
    // CABA;CABA;110D 1168 11C1;CABA;110D 1168 11C1; 
    // (쪺; 쪺; 쪺; 쪺; 쪺; ) HANGUL SYLLABLE JJYEP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCABA }};
        std::array<char32_t, 1> const c2 = {{ 0xCABA }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCABA }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_083)
{
    // CABB;CABB;110D 1168 11C2;CABB;110D 1168 11C2; 
    // (쪻; 쪻; 쪻; 쪻; 쪻; ) HANGUL SYLLABLE JJYEH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCABB }};
        std::array<char32_t, 1> const c2 = {{ 0xCABB }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1168, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCABB }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1168, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_084)
{
    // CABC;CABC;110D 1169;CABC;110D 1169; 
    // (쪼; 쪼; 쪼; 쪼; 쪼; ) HANGUL SYLLABLE JJO
    {
        std::array<char32_t, 1> const c1 = {{ 0xCABC }};
        std::array<char32_t, 1> const c2 = {{ 0xCABC }};
        std::array<char32_t, 2> const c3 = {{ 0x110D, 0x1169 }};
        std::array<char32_t, 1> const c4 = {{ 0xCABC }};
        std::array<char32_t, 2> const c5 = {{ 0x110D, 0x1169 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_085)
{
    // CABD;CABD;110D 1169 11A8;CABD;110D 1169 11A8; 
    // (쪽; 쪽; 쪽; 쪽; 쪽; ) HANGUL SYLLABLE JJOG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCABD }};
        std::array<char32_t, 1> const c2 = {{ 0xCABD }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCABD }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_086)
{
    // CABE;CABE;110D 1169 11A9;CABE;110D 1169 11A9; 
    // (쪾; 쪾; 쪾; 쪾; 쪾; ) HANGUL SYLLABLE JJOGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCABE }};
        std::array<char32_t, 1> const c2 = {{ 0xCABE }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCABE }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_087)
{
    // CABF;CABF;110D 1169 11AA;CABF;110D 1169 11AA; 
    // (쪿; 쪿; 쪿; 쪿; 쪿; ) HANGUL SYLLABLE JJOGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCABF }};
        std::array<char32_t, 1> const c2 = {{ 0xCABF }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xCABF }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_088)
{
    // CAC0;CAC0;110D 1169 11AB;CAC0;110D 1169 11AB; 
    // (쫀; 쫀; 쫀; 쫀; 쫀; ) HANGUL SYLLABLE JJON
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAC0 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAC0 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xCAC0 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_089)
{
    // CAC1;CAC1;110D 1169 11AC;CAC1;110D 1169 11AC; 
    // (쫁; 쫁; 쫁; 쫁; 쫁; ) HANGUL SYLLABLE JJONJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAC1 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAC1 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xCAC1 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_090)
{
    // CAC2;CAC2;110D 1169 11AD;CAC2;110D 1169 11AD; 
    // (쫂; 쫂; 쫂; 쫂; 쫂; ) HANGUL SYLLABLE JJONH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAC2 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAC2 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xCAC2 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_091)
{
    // CAC3;CAC3;110D 1169 11AE;CAC3;110D 1169 11AE; 
    // (쫃; 쫃; 쫃; 쫃; 쫃; ) HANGUL SYLLABLE JJOD
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAC3 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAC3 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xCAC3 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_092)
{
    // CAC4;CAC4;110D 1169 11AF;CAC4;110D 1169 11AF; 
    // (쫄; 쫄; 쫄; 쫄; 쫄; ) HANGUL SYLLABLE JJOL
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAC4 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAC4 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xCAC4 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_093)
{
    // CAC5;CAC5;110D 1169 11B0;CAC5;110D 1169 11B0; 
    // (쫅; 쫅; 쫅; 쫅; 쫅; ) HANGUL SYLLABLE JJOLG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAC5 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAC5 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAC5 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_094)
{
    // CAC6;CAC6;110D 1169 11B1;CAC6;110D 1169 11B1; 
    // (쫆; 쫆; 쫆; 쫆; 쫆; ) HANGUL SYLLABLE JJOLM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAC6 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAC6 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAC6 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_095)
{
    // CAC7;CAC7;110D 1169 11B2;CAC7;110D 1169 11B2; 
    // (쫇; 쫇; 쫇; 쫇; 쫇; ) HANGUL SYLLABLE JJOLB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAC7 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAC7 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAC7 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_096)
{
    // CAC8;CAC8;110D 1169 11B3;CAC8;110D 1169 11B3; 
    // (쫈; 쫈; 쫈; 쫈; 쫈; ) HANGUL SYLLABLE JJOLS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAC8 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAC8 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAC8 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_097)
{
    // CAC9;CAC9;110D 1169 11B4;CAC9;110D 1169 11B4; 
    // (쫉; 쫉; 쫉; 쫉; 쫉; ) HANGUL SYLLABLE JJOLT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAC9 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAC9 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAC9 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_098)
{
    // CACA;CACA;110D 1169 11B5;CACA;110D 1169 11B5; 
    // (쫊; 쫊; 쫊; 쫊; 쫊; ) HANGUL SYLLABLE JJOLP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCACA }};
        std::array<char32_t, 1> const c2 = {{ 0xCACA }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xCACA }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_099)
{
    // CACB;CACB;110D 1169 11B6;CACB;110D 1169 11B6; 
    // (쫋; 쫋; 쫋; 쫋; 쫋; ) HANGUL SYLLABLE JJOLH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCACB }};
        std::array<char32_t, 1> const c2 = {{ 0xCACB }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xCACB }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_100)
{
    // CACC;CACC;110D 1169 11B7;CACC;110D 1169 11B7; 
    // (쫌; 쫌; 쫌; 쫌; 쫌; ) HANGUL SYLLABLE JJOM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCACC }};
        std::array<char32_t, 1> const c2 = {{ 0xCACC }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xCACC }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_101)
{
    // CACD;CACD;110D 1169 11B8;CACD;110D 1169 11B8; 
    // (쫍; 쫍; 쫍; 쫍; 쫍; ) HANGUL SYLLABLE JJOB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCACD }};
        std::array<char32_t, 1> const c2 = {{ 0xCACD }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCACD }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_102)
{
    // CACE;CACE;110D 1169 11B9;CACE;110D 1169 11B9; 
    // (쫎; 쫎; 쫎; 쫎; 쫎; ) HANGUL SYLLABLE JJOBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCACE }};
        std::array<char32_t, 1> const c2 = {{ 0xCACE }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCACE }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_103)
{
    // CACF;CACF;110D 1169 11BA;CACF;110D 1169 11BA; 
    // (쫏; 쫏; 쫏; 쫏; 쫏; ) HANGUL SYLLABLE JJOS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCACF }};
        std::array<char32_t, 1> const c2 = {{ 0xCACF }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xCACF }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_104)
{
    // CAD0;CAD0;110D 1169 11BB;CAD0;110D 1169 11BB; 
    // (쫐; 쫐; 쫐; 쫐; 쫐; ) HANGUL SYLLABLE JJOSS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAD0 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAD0 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xCAD0 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_105)
{
    // CAD1;CAD1;110D 1169 11BC;CAD1;110D 1169 11BC; 
    // (쫑; 쫑; 쫑; 쫑; 쫑; ) HANGUL SYLLABLE JJONG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAD1 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAD1 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xCAD1 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_106)
{
    // CAD2;CAD2;110D 1169 11BD;CAD2;110D 1169 11BD; 
    // (쫒; 쫒; 쫒; 쫒; 쫒; ) HANGUL SYLLABLE JJOJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAD2 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAD2 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xCAD2 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_107)
{
    // CAD3;CAD3;110D 1169 11BE;CAD3;110D 1169 11BE; 
    // (쫓; 쫓; 쫓; 쫓; 쫓; ) HANGUL SYLLABLE JJOC
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAD3 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAD3 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xCAD3 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_108)
{
    // CAD4;CAD4;110D 1169 11BF;CAD4;110D 1169 11BF; 
    // (쫔; 쫔; 쫔; 쫔; 쫔; ) HANGUL SYLLABLE JJOK
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAD4 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAD4 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xCAD4 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_109)
{
    // CAD5;CAD5;110D 1169 11C0;CAD5;110D 1169 11C0; 
    // (쫕; 쫕; 쫕; 쫕; 쫕; ) HANGUL SYLLABLE JJOT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAD5 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAD5 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAD5 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_110)
{
    // CAD6;CAD6;110D 1169 11C1;CAD6;110D 1169 11C1; 
    // (쫖; 쫖; 쫖; 쫖; 쫖; ) HANGUL SYLLABLE JJOP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAD6 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAD6 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAD6 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_111)
{
    // CAD7;CAD7;110D 1169 11C2;CAD7;110D 1169 11C2; 
    // (쫗; 쫗; 쫗; 쫗; 쫗; ) HANGUL SYLLABLE JJOH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAD7 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAD7 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1169, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAD7 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1169, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_112)
{
    // CAD8;CAD8;110D 116A;CAD8;110D 116A; 
    // (쫘; 쫘; 쫘; 쫘; 쫘; ) HANGUL SYLLABLE JJWA
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAD8 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAD8 }};
        std::array<char32_t, 2> const c3 = {{ 0x110D, 0x116A }};
        std::array<char32_t, 1> const c4 = {{ 0xCAD8 }};
        std::array<char32_t, 2> const c5 = {{ 0x110D, 0x116A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_113)
{
    // CAD9;CAD9;110D 116A 11A8;CAD9;110D 116A 11A8; 
    // (쫙; 쫙; 쫙; 쫙; 쫙; ) HANGUL SYLLABLE JJWAG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAD9 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAD9 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAD9 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_114)
{
    // CADA;CADA;110D 116A 11A9;CADA;110D 116A 11A9; 
    // (쫚; 쫚; 쫚; 쫚; 쫚; ) HANGUL SYLLABLE JJWAGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCADA }};
        std::array<char32_t, 1> const c2 = {{ 0xCADA }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCADA }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_115)
{
    // CADB;CADB;110D 116A 11AA;CADB;110D 116A 11AA; 
    // (쫛; 쫛; 쫛; 쫛; 쫛; ) HANGUL SYLLABLE JJWAGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCADB }};
        std::array<char32_t, 1> const c2 = {{ 0xCADB }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xCADB }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_116)
{
    // CADC;CADC;110D 116A 11AB;CADC;110D 116A 11AB; 
    // (쫜; 쫜; 쫜; 쫜; 쫜; ) HANGUL SYLLABLE JJWAN
    {
        std::array<char32_t, 1> const c1 = {{ 0xCADC }};
        std::array<char32_t, 1> const c2 = {{ 0xCADC }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xCADC }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_117)
{
    // CADD;CADD;110D 116A 11AC;CADD;110D 116A 11AC; 
    // (쫝; 쫝; 쫝; 쫝; 쫝; ) HANGUL SYLLABLE JJWANJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCADD }};
        std::array<char32_t, 1> const c2 = {{ 0xCADD }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xCADD }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_118)
{
    // CADE;CADE;110D 116A 11AD;CADE;110D 116A 11AD; 
    // (쫞; 쫞; 쫞; 쫞; 쫞; ) HANGUL SYLLABLE JJWANH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCADE }};
        std::array<char32_t, 1> const c2 = {{ 0xCADE }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xCADE }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_119)
{
    // CADF;CADF;110D 116A 11AE;CADF;110D 116A 11AE; 
    // (쫟; 쫟; 쫟; 쫟; 쫟; ) HANGUL SYLLABLE JJWAD
    {
        std::array<char32_t, 1> const c1 = {{ 0xCADF }};
        std::array<char32_t, 1> const c2 = {{ 0xCADF }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xCADF }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_120)
{
    // CAE0;CAE0;110D 116A 11AF;CAE0;110D 116A 11AF; 
    // (쫠; 쫠; 쫠; 쫠; 쫠; ) HANGUL SYLLABLE JJWAL
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAE0 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAE0 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xCAE0 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_121)
{
    // CAE1;CAE1;110D 116A 11B0;CAE1;110D 116A 11B0; 
    // (쫡; 쫡; 쫡; 쫡; 쫡; ) HANGUL SYLLABLE JJWALG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAE1 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAE1 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAE1 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_122)
{
    // CAE2;CAE2;110D 116A 11B1;CAE2;110D 116A 11B1; 
    // (쫢; 쫢; 쫢; 쫢; 쫢; ) HANGUL SYLLABLE JJWALM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAE2 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAE2 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAE2 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_123)
{
    // CAE3;CAE3;110D 116A 11B2;CAE3;110D 116A 11B2; 
    // (쫣; 쫣; 쫣; 쫣; 쫣; ) HANGUL SYLLABLE JJWALB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAE3 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAE3 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAE3 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_124)
{
    // CAE4;CAE4;110D 116A 11B3;CAE4;110D 116A 11B3; 
    // (쫤; 쫤; 쫤; 쫤; 쫤; ) HANGUL SYLLABLE JJWALS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAE4 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAE4 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAE4 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_125)
{
    // CAE5;CAE5;110D 116A 11B4;CAE5;110D 116A 11B4; 
    // (쫥; 쫥; 쫥; 쫥; 쫥; ) HANGUL SYLLABLE JJWALT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAE5 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAE5 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAE5 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_126)
{
    // CAE6;CAE6;110D 116A 11B5;CAE6;110D 116A 11B5; 
    // (쫦; 쫦; 쫦; 쫦; 쫦; ) HANGUL SYLLABLE JJWALP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAE6 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAE6 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAE6 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_127)
{
    // CAE7;CAE7;110D 116A 11B6;CAE7;110D 116A 11B6; 
    // (쫧; 쫧; 쫧; 쫧; 쫧; ) HANGUL SYLLABLE JJWALH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAE7 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAE7 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAE7 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_128)
{
    // CAE8;CAE8;110D 116A 11B7;CAE8;110D 116A 11B7; 
    // (쫨; 쫨; 쫨; 쫨; 쫨; ) HANGUL SYLLABLE JJWAM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAE8 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAE8 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAE8 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_129)
{
    // CAE9;CAE9;110D 116A 11B8;CAE9;110D 116A 11B8; 
    // (쫩; 쫩; 쫩; 쫩; 쫩; ) HANGUL SYLLABLE JJWAB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAE9 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAE9 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAE9 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_130)
{
    // CAEA;CAEA;110D 116A 11B9;CAEA;110D 116A 11B9; 
    // (쫪; 쫪; 쫪; 쫪; 쫪; ) HANGUL SYLLABLE JJWABS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAEA }};
        std::array<char32_t, 1> const c2 = {{ 0xCAEA }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAEA }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_131)
{
    // CAEB;CAEB;110D 116A 11BA;CAEB;110D 116A 11BA; 
    // (쫫; 쫫; 쫫; 쫫; 쫫; ) HANGUL SYLLABLE JJWAS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAEB }};
        std::array<char32_t, 1> const c2 = {{ 0xCAEB }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xCAEB }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_132)
{
    // CAEC;CAEC;110D 116A 11BB;CAEC;110D 116A 11BB; 
    // (쫬; 쫬; 쫬; 쫬; 쫬; ) HANGUL SYLLABLE JJWASS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAEC }};
        std::array<char32_t, 1> const c2 = {{ 0xCAEC }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xCAEC }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_133)
{
    // CAED;CAED;110D 116A 11BC;CAED;110D 116A 11BC; 
    // (쫭; 쫭; 쫭; 쫭; 쫭; ) HANGUL SYLLABLE JJWANG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAED }};
        std::array<char32_t, 1> const c2 = {{ 0xCAED }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xCAED }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_134)
{
    // CAEE;CAEE;110D 116A 11BD;CAEE;110D 116A 11BD; 
    // (쫮; 쫮; 쫮; 쫮; 쫮; ) HANGUL SYLLABLE JJWAJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAEE }};
        std::array<char32_t, 1> const c2 = {{ 0xCAEE }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xCAEE }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_135)
{
    // CAEF;CAEF;110D 116A 11BE;CAEF;110D 116A 11BE; 
    // (쫯; 쫯; 쫯; 쫯; 쫯; ) HANGUL SYLLABLE JJWAC
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAEF }};
        std::array<char32_t, 1> const c2 = {{ 0xCAEF }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xCAEF }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_136)
{
    // CAF0;CAF0;110D 116A 11BF;CAF0;110D 116A 11BF; 
    // (쫰; 쫰; 쫰; 쫰; 쫰; ) HANGUL SYLLABLE JJWAK
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAF0 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAF0 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xCAF0 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_137)
{
    // CAF1;CAF1;110D 116A 11C0;CAF1;110D 116A 11C0; 
    // (쫱; 쫱; 쫱; 쫱; 쫱; ) HANGUL SYLLABLE JJWAT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAF1 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAF1 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAF1 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_138)
{
    // CAF2;CAF2;110D 116A 11C1;CAF2;110D 116A 11C1; 
    // (쫲; 쫲; 쫲; 쫲; 쫲; ) HANGUL SYLLABLE JJWAP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAF2 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAF2 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAF2 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_139)
{
    // CAF3;CAF3;110D 116A 11C2;CAF3;110D 116A 11C2; 
    // (쫳; 쫳; 쫳; 쫳; 쫳; ) HANGUL SYLLABLE JJWAH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAF3 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAF3 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116A, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAF3 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116A, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_140)
{
    // CAF4;CAF4;110D 116B;CAF4;110D 116B; 
    // (쫴; 쫴; 쫴; 쫴; 쫴; ) HANGUL SYLLABLE JJWAE
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAF4 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAF4 }};
        std::array<char32_t, 2> const c3 = {{ 0x110D, 0x116B }};
        std::array<char32_t, 1> const c4 = {{ 0xCAF4 }};
        std::array<char32_t, 2> const c5 = {{ 0x110D, 0x116B }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_141)
{
    // CAF5;CAF5;110D 116B 11A8;CAF5;110D 116B 11A8; 
    // (쫵; 쫵; 쫵; 쫵; 쫵; ) HANGUL SYLLABLE JJWAEG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAF5 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAF5 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAF5 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_142)
{
    // CAF6;CAF6;110D 116B 11A9;CAF6;110D 116B 11A9; 
    // (쫶; 쫶; 쫶; 쫶; 쫶; ) HANGUL SYLLABLE JJWAEGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAF6 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAF6 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAF6 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_143)
{
    // CAF7;CAF7;110D 116B 11AA;CAF7;110D 116B 11AA; 
    // (쫷; 쫷; 쫷; 쫷; 쫷; ) HANGUL SYLLABLE JJWAEGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAF7 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAF7 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xCAF7 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_144)
{
    // CAF8;CAF8;110D 116B 11AB;CAF8;110D 116B 11AB; 
    // (쫸; 쫸; 쫸; 쫸; 쫸; ) HANGUL SYLLABLE JJWAEN
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAF8 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAF8 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xCAF8 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_145)
{
    // CAF9;CAF9;110D 116B 11AC;CAF9;110D 116B 11AC; 
    // (쫹; 쫹; 쫹; 쫹; 쫹; ) HANGUL SYLLABLE JJWAENJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAF9 }};
        std::array<char32_t, 1> const c2 = {{ 0xCAF9 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xCAF9 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_146)
{
    // CAFA;CAFA;110D 116B 11AD;CAFA;110D 116B 11AD; 
    // (쫺; 쫺; 쫺; 쫺; 쫺; ) HANGUL SYLLABLE JJWAENH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAFA }};
        std::array<char32_t, 1> const c2 = {{ 0xCAFA }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xCAFA }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_147)
{
    // CAFB;CAFB;110D 116B 11AE;CAFB;110D 116B 11AE; 
    // (쫻; 쫻; 쫻; 쫻; 쫻; ) HANGUL SYLLABLE JJWAED
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAFB }};
        std::array<char32_t, 1> const c2 = {{ 0xCAFB }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xCAFB }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_148)
{
    // CAFC;CAFC;110D 116B 11AF;CAFC;110D 116B 11AF; 
    // (쫼; 쫼; 쫼; 쫼; 쫼; ) HANGUL SYLLABLE JJWAEL
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAFC }};
        std::array<char32_t, 1> const c2 = {{ 0xCAFC }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xCAFC }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_149)
{
    // CAFD;CAFD;110D 116B 11B0;CAFD;110D 116B 11B0; 
    // (쫽; 쫽; 쫽; 쫽; 쫽; ) HANGUL SYLLABLE JJWAELG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAFD }};
        std::array<char32_t, 1> const c2 = {{ 0xCAFD }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAFD }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_150)
{
    // CAFE;CAFE;110D 116B 11B1;CAFE;110D 116B 11B1; 
    // (쫾; 쫾; 쫾; 쫾; 쫾; ) HANGUL SYLLABLE JJWAELM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAFE }};
        std::array<char32_t, 1> const c2 = {{ 0xCAFE }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAFE }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_151)
{
    // CAFF;CAFF;110D 116B 11B2;CAFF;110D 116B 11B2; 
    // (쫿; 쫿; 쫿; 쫿; 쫿; ) HANGUL SYLLABLE JJWAELB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCAFF }};
        std::array<char32_t, 1> const c2 = {{ 0xCAFF }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCAFF }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_152)
{
    // CB00;CB00;110D 116B 11B3;CB00;110D 116B 11B3; 
    // (쬀; 쬀; 쬀; 쬀; 쬀; ) HANGUL SYLLABLE JJWAELS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB00 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB00 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB00 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_153)
{
    // CB01;CB01;110D 116B 11B4;CB01;110D 116B 11B4; 
    // (쬁; 쬁; 쬁; 쬁; 쬁; ) HANGUL SYLLABLE JJWAELT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB01 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB01 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB01 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_154)
{
    // CB02;CB02;110D 116B 11B5;CB02;110D 116B 11B5; 
    // (쬂; 쬂; 쬂; 쬂; 쬂; ) HANGUL SYLLABLE JJWAELP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB02 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB02 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB02 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_155)
{
    // CB03;CB03;110D 116B 11B6;CB03;110D 116B 11B6; 
    // (쬃; 쬃; 쬃; 쬃; 쬃; ) HANGUL SYLLABLE JJWAELH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB03 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB03 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB03 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_156)
{
    // CB04;CB04;110D 116B 11B7;CB04;110D 116B 11B7; 
    // (쬄; 쬄; 쬄; 쬄; 쬄; ) HANGUL SYLLABLE JJWAEM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB04 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB04 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB04 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_157)
{
    // CB05;CB05;110D 116B 11B8;CB05;110D 116B 11B8; 
    // (쬅; 쬅; 쬅; 쬅; 쬅; ) HANGUL SYLLABLE JJWAEB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB05 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB05 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB05 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_158)
{
    // CB06;CB06;110D 116B 11B9;CB06;110D 116B 11B9; 
    // (쬆; 쬆; 쬆; 쬆; 쬆; ) HANGUL SYLLABLE JJWAEBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB06 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB06 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB06 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_159)
{
    // CB07;CB07;110D 116B 11BA;CB07;110D 116B 11BA; 
    // (쬇; 쬇; 쬇; 쬇; 쬇; ) HANGUL SYLLABLE JJWAES
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB07 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB07 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xCB07 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_160)
{
    // CB08;CB08;110D 116B 11BB;CB08;110D 116B 11BB; 
    // (쬈; 쬈; 쬈; 쬈; 쬈; ) HANGUL SYLLABLE JJWAESS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB08 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB08 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xCB08 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_161)
{
    // CB09;CB09;110D 116B 11BC;CB09;110D 116B 11BC; 
    // (쬉; 쬉; 쬉; 쬉; 쬉; ) HANGUL SYLLABLE JJWAENG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB09 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB09 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xCB09 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_162)
{
    // CB0A;CB0A;110D 116B 11BD;CB0A;110D 116B 11BD; 
    // (쬊; 쬊; 쬊; 쬊; 쬊; ) HANGUL SYLLABLE JJWAEJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB0A }};
        std::array<char32_t, 1> const c2 = {{ 0xCB0A }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xCB0A }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_163)
{
    // CB0B;CB0B;110D 116B 11BE;CB0B;110D 116B 11BE; 
    // (쬋; 쬋; 쬋; 쬋; 쬋; ) HANGUL SYLLABLE JJWAEC
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB0B }};
        std::array<char32_t, 1> const c2 = {{ 0xCB0B }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xCB0B }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_164)
{
    // CB0C;CB0C;110D 116B 11BF;CB0C;110D 116B 11BF; 
    // (쬌; 쬌; 쬌; 쬌; 쬌; ) HANGUL SYLLABLE JJWAEK
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB0C }};
        std::array<char32_t, 1> const c2 = {{ 0xCB0C }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xCB0C }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_165)
{
    // CB0D;CB0D;110D 116B 11C0;CB0D;110D 116B 11C0; 
    // (쬍; 쬍; 쬍; 쬍; 쬍; ) HANGUL SYLLABLE JJWAET
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB0D }};
        std::array<char32_t, 1> const c2 = {{ 0xCB0D }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB0D }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_166)
{
    // CB0E;CB0E;110D 116B 11C1;CB0E;110D 116B 11C1; 
    // (쬎; 쬎; 쬎; 쬎; 쬎; ) HANGUL SYLLABLE JJWAEP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB0E }};
        std::array<char32_t, 1> const c2 = {{ 0xCB0E }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB0E }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_167)
{
    // CB0F;CB0F;110D 116B 11C2;CB0F;110D 116B 11C2; 
    // (쬏; 쬏; 쬏; 쬏; 쬏; ) HANGUL SYLLABLE JJWAEH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB0F }};
        std::array<char32_t, 1> const c2 = {{ 0xCB0F }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116B, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB0F }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116B, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_168)
{
    // CB10;CB10;110D 116C;CB10;110D 116C; 
    // (쬐; 쬐; 쬐; 쬐; 쬐; ) HANGUL SYLLABLE JJOE
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB10 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB10 }};
        std::array<char32_t, 2> const c3 = {{ 0x110D, 0x116C }};
        std::array<char32_t, 1> const c4 = {{ 0xCB10 }};
        std::array<char32_t, 2> const c5 = {{ 0x110D, 0x116C }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_169)
{
    // CB11;CB11;110D 116C 11A8;CB11;110D 116C 11A8; 
    // (쬑; 쬑; 쬑; 쬑; 쬑; ) HANGUL SYLLABLE JJOEG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB11 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB11 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB11 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_170)
{
    // CB12;CB12;110D 116C 11A9;CB12;110D 116C 11A9; 
    // (쬒; 쬒; 쬒; 쬒; 쬒; ) HANGUL SYLLABLE JJOEGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB12 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB12 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB12 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_171)
{
    // CB13;CB13;110D 116C 11AA;CB13;110D 116C 11AA; 
    // (쬓; 쬓; 쬓; 쬓; 쬓; ) HANGUL SYLLABLE JJOEGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB13 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB13 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xCB13 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_172)
{
    // CB14;CB14;110D 116C 11AB;CB14;110D 116C 11AB; 
    // (쬔; 쬔; 쬔; 쬔; 쬔; ) HANGUL SYLLABLE JJOEN
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB14 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB14 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xCB14 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_173)
{
    // CB15;CB15;110D 116C 11AC;CB15;110D 116C 11AC; 
    // (쬕; 쬕; 쬕; 쬕; 쬕; ) HANGUL SYLLABLE JJOENJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB15 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB15 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xCB15 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_174)
{
    // CB16;CB16;110D 116C 11AD;CB16;110D 116C 11AD; 
    // (쬖; 쬖; 쬖; 쬖; 쬖; ) HANGUL SYLLABLE JJOENH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB16 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB16 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xCB16 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_175)
{
    // CB17;CB17;110D 116C 11AE;CB17;110D 116C 11AE; 
    // (쬗; 쬗; 쬗; 쬗; 쬗; ) HANGUL SYLLABLE JJOED
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB17 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB17 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xCB17 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_176)
{
    // CB18;CB18;110D 116C 11AF;CB18;110D 116C 11AF; 
    // (쬘; 쬘; 쬘; 쬘; 쬘; ) HANGUL SYLLABLE JJOEL
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB18 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB18 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xCB18 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_177)
{
    // CB19;CB19;110D 116C 11B0;CB19;110D 116C 11B0; 
    // (쬙; 쬙; 쬙; 쬙; 쬙; ) HANGUL SYLLABLE JJOELG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB19 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB19 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB19 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_178)
{
    // CB1A;CB1A;110D 116C 11B1;CB1A;110D 116C 11B1; 
    // (쬚; 쬚; 쬚; 쬚; 쬚; ) HANGUL SYLLABLE JJOELM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB1A }};
        std::array<char32_t, 1> const c2 = {{ 0xCB1A }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB1A }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_179)
{
    // CB1B;CB1B;110D 116C 11B2;CB1B;110D 116C 11B2; 
    // (쬛; 쬛; 쬛; 쬛; 쬛; ) HANGUL SYLLABLE JJOELB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB1B }};
        std::array<char32_t, 1> const c2 = {{ 0xCB1B }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB1B }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_180)
{
    // CB1C;CB1C;110D 116C 11B3;CB1C;110D 116C 11B3; 
    // (쬜; 쬜; 쬜; 쬜; 쬜; ) HANGUL SYLLABLE JJOELS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB1C }};
        std::array<char32_t, 1> const c2 = {{ 0xCB1C }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB1C }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_181)
{
    // CB1D;CB1D;110D 116C 11B4;CB1D;110D 116C 11B4; 
    // (쬝; 쬝; 쬝; 쬝; 쬝; ) HANGUL SYLLABLE JJOELT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB1D }};
        std::array<char32_t, 1> const c2 = {{ 0xCB1D }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB1D }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_182)
{
    // CB1E;CB1E;110D 116C 11B5;CB1E;110D 116C 11B5; 
    // (쬞; 쬞; 쬞; 쬞; 쬞; ) HANGUL SYLLABLE JJOELP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB1E }};
        std::array<char32_t, 1> const c2 = {{ 0xCB1E }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB1E }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_183)
{
    // CB1F;CB1F;110D 116C 11B6;CB1F;110D 116C 11B6; 
    // (쬟; 쬟; 쬟; 쬟; 쬟; ) HANGUL SYLLABLE JJOELH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB1F }};
        std::array<char32_t, 1> const c2 = {{ 0xCB1F }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB1F }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_184)
{
    // CB20;CB20;110D 116C 11B7;CB20;110D 116C 11B7; 
    // (쬠; 쬠; 쬠; 쬠; 쬠; ) HANGUL SYLLABLE JJOEM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB20 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB20 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB20 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_185)
{
    // CB21;CB21;110D 116C 11B8;CB21;110D 116C 11B8; 
    // (쬡; 쬡; 쬡; 쬡; 쬡; ) HANGUL SYLLABLE JJOEB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB21 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB21 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB21 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_186)
{
    // CB22;CB22;110D 116C 11B9;CB22;110D 116C 11B9; 
    // (쬢; 쬢; 쬢; 쬢; 쬢; ) HANGUL SYLLABLE JJOEBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB22 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB22 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB22 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_187)
{
    // CB23;CB23;110D 116C 11BA;CB23;110D 116C 11BA; 
    // (쬣; 쬣; 쬣; 쬣; 쬣; ) HANGUL SYLLABLE JJOES
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB23 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB23 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xCB23 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_188)
{
    // CB24;CB24;110D 116C 11BB;CB24;110D 116C 11BB; 
    // (쬤; 쬤; 쬤; 쬤; 쬤; ) HANGUL SYLLABLE JJOESS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB24 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB24 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xCB24 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_189)
{
    // CB25;CB25;110D 116C 11BC;CB25;110D 116C 11BC; 
    // (쬥; 쬥; 쬥; 쬥; 쬥; ) HANGUL SYLLABLE JJOENG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB25 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB25 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xCB25 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_190)
{
    // CB26;CB26;110D 116C 11BD;CB26;110D 116C 11BD; 
    // (쬦; 쬦; 쬦; 쬦; 쬦; ) HANGUL SYLLABLE JJOEJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB26 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB26 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xCB26 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_191)
{
    // CB27;CB27;110D 116C 11BE;CB27;110D 116C 11BE; 
    // (쬧; 쬧; 쬧; 쬧; 쬧; ) HANGUL SYLLABLE JJOEC
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB27 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB27 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xCB27 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_192)
{
    // CB28;CB28;110D 116C 11BF;CB28;110D 116C 11BF; 
    // (쬨; 쬨; 쬨; 쬨; 쬨; ) HANGUL SYLLABLE JJOEK
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB28 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB28 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xCB28 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_193)
{
    // CB29;CB29;110D 116C 11C0;CB29;110D 116C 11C0; 
    // (쬩; 쬩; 쬩; 쬩; 쬩; ) HANGUL SYLLABLE JJOET
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB29 }};
        std::array<char32_t, 1> const c2 = {{ 0xCB29 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB29 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_194)
{
    // CB2A;CB2A;110D 116C 11C1;CB2A;110D 116C 11C1; 
    // (쬪; 쬪; 쬪; 쬪; 쬪; ) HANGUL SYLLABLE JJOEP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB2A }};
        std::array<char32_t, 1> const c2 = {{ 0xCB2A }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB2A }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_195)
{
    // CB2B;CB2B;110D 116C 11C2;CB2B;110D 116C 11C2; 
    // (쬫; 쬫; 쬫; 쬫; 쬫; ) HANGUL SYLLABLE JJOEH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB2B }};
        std::array<char32_t, 1> const c2 = {{ 0xCB2B }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116C, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB2B }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116C, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_196)
{
    // CB2C;CB2C;110D 116D;CB2C;110D 116D; 
    // (쬬; 쬬; 쬬; 쬬; 쬬; ) HANGUL SYLLABLE JJYO
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB2C }};
        std::array<char32_t, 1> const c2 = {{ 0xCB2C }};
        std::array<char32_t, 2> const c3 = {{ 0x110D, 0x116D }};
        std::array<char32_t, 1> const c4 = {{ 0xCB2C }};
        std::array<char32_t, 2> const c5 = {{ 0x110D, 0x116D }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_197)
{
    // CB2D;CB2D;110D 116D 11A8;CB2D;110D 116D 11A8; 
    // (쬭; 쬭; 쬭; 쬭; 쬭; ) HANGUL SYLLABLE JJYOG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB2D }};
        std::array<char32_t, 1> const c2 = {{ 0xCB2D }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116D, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB2D }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116D, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_198)
{
    // CB2E;CB2E;110D 116D 11A9;CB2E;110D 116D 11A9; 
    // (쬮; 쬮; 쬮; 쬮; 쬮; ) HANGUL SYLLABLE JJYOGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB2E }};
        std::array<char32_t, 1> const c2 = {{ 0xCB2E }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116D, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCB2E }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116D, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_051_199)
{
    // CB2F;CB2F;110D 116D 11AA;CB2F;110D 116D 11AA; 
    // (쬯; 쬯; 쬯; 쬯; 쬯; ) HANGUL SYLLABLE JJYOGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCB2F }};
        std::array<char32_t, 1> const c2 = {{ 0xCB2F }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x116D, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xCB2F }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x116D, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


