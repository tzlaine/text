// Copyright (C) 2020 T. Zachary Laine
//
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

// Warning! This file is autogenerated.
#include <boost/text/normalize_string.hpp>
#include <boost/text/transcode_view.hpp>
#include <boost/text/string_utility.hpp>

#include <gtest/gtest.h>

#include <algorithm>



TEST(normalization, nfd_078_000)
{
    // 1D5D8;1D5D8;1D5D8;0045;0045; 
    // (ùóò; ùóò; ùóò; E; E; ) MATHEMATICAL SANS-SERIF BOLD CAPITAL E
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5D8 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5D8 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5D8 }};
        std::array<char32_t, 1> const c4 = {{ 0x0045 }};
        std::array<char32_t, 1> const c5 = {{ 0x0045 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_001)
{
    // 1D5D9;1D5D9;1D5D9;0046;0046; 
    // (ùóô; ùóô; ùóô; F; F; ) MATHEMATICAL SANS-SERIF BOLD CAPITAL F
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5D9 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5D9 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5D9 }};
        std::array<char32_t, 1> const c4 = {{ 0x0046 }};
        std::array<char32_t, 1> const c5 = {{ 0x0046 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_002)
{
    // 1D5DA;1D5DA;1D5DA;0047;0047; 
    // (ùóö; ùóö; ùóö; G; G; ) MATHEMATICAL SANS-SERIF BOLD CAPITAL G
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5DA }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5DA }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5DA }};
        std::array<char32_t, 1> const c4 = {{ 0x0047 }};
        std::array<char32_t, 1> const c5 = {{ 0x0047 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_003)
{
    // 1D5DB;1D5DB;1D5DB;0048;0048; 
    // (ùóõ; ùóõ; ùóõ; H; H; ) MATHEMATICAL SANS-SERIF BOLD CAPITAL H
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5DB }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5DB }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5DB }};
        std::array<char32_t, 1> const c4 = {{ 0x0048 }};
        std::array<char32_t, 1> const c5 = {{ 0x0048 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_004)
{
    // 1D5DC;1D5DC;1D5DC;0049;0049; 
    // (ùóú; ùóú; ùóú; I; I; ) MATHEMATICAL SANS-SERIF BOLD CAPITAL I
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5DC }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5DC }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5DC }};
        std::array<char32_t, 1> const c4 = {{ 0x0049 }};
        std::array<char32_t, 1> const c5 = {{ 0x0049 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_005)
{
    // 1D5DD;1D5DD;1D5DD;004A;004A; 
    // (ùóù; ùóù; ùóù; J; J; ) MATHEMATICAL SANS-SERIF BOLD CAPITAL J
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5DD }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5DD }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5DD }};
        std::array<char32_t, 1> const c4 = {{ 0x004A }};
        std::array<char32_t, 1> const c5 = {{ 0x004A }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_006)
{
    // 1D5DE;1D5DE;1D5DE;004B;004B; 
    // (ùóû; ùóû; ùóû; K; K; ) MATHEMATICAL SANS-SERIF BOLD CAPITAL K
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5DE }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5DE }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5DE }};
        std::array<char32_t, 1> const c4 = {{ 0x004B }};
        std::array<char32_t, 1> const c5 = {{ 0x004B }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_007)
{
    // 1D5DF;1D5DF;1D5DF;004C;004C; 
    // (ùóü; ùóü; ùóü; L; L; ) MATHEMATICAL SANS-SERIF BOLD CAPITAL L
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5DF }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5DF }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5DF }};
        std::array<char32_t, 1> const c4 = {{ 0x004C }};
        std::array<char32_t, 1> const c5 = {{ 0x004C }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_008)
{
    // 1D5E0;1D5E0;1D5E0;004D;004D; 
    // (ùó†; ùó†; ùó†; M; M; ) MATHEMATICAL SANS-SERIF BOLD CAPITAL M
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5E0 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5E0 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5E0 }};
        std::array<char32_t, 1> const c4 = {{ 0x004D }};
        std::array<char32_t, 1> const c5 = {{ 0x004D }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_009)
{
    // 1D5E1;1D5E1;1D5E1;004E;004E; 
    // (ùó°; ùó°; ùó°; N; N; ) MATHEMATICAL SANS-SERIF BOLD CAPITAL N
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5E1 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5E1 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5E1 }};
        std::array<char32_t, 1> const c4 = {{ 0x004E }};
        std::array<char32_t, 1> const c5 = {{ 0x004E }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_010)
{
    // 1D5E2;1D5E2;1D5E2;004F;004F; 
    // (ùó¢; ùó¢; ùó¢; O; O; ) MATHEMATICAL SANS-SERIF BOLD CAPITAL O
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5E2 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5E2 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5E2 }};
        std::array<char32_t, 1> const c4 = {{ 0x004F }};
        std::array<char32_t, 1> const c5 = {{ 0x004F }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_011)
{
    // 1D5E3;1D5E3;1D5E3;0050;0050; 
    // (ùó£; ùó£; ùó£; P; P; ) MATHEMATICAL SANS-SERIF BOLD CAPITAL P
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5E3 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5E3 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5E3 }};
        std::array<char32_t, 1> const c4 = {{ 0x0050 }};
        std::array<char32_t, 1> const c5 = {{ 0x0050 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_012)
{
    // 1D5E4;1D5E4;1D5E4;0051;0051; 
    // (ùó§; ùó§; ùó§; Q; Q; ) MATHEMATICAL SANS-SERIF BOLD CAPITAL Q
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5E4 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5E4 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5E4 }};
        std::array<char32_t, 1> const c4 = {{ 0x0051 }};
        std::array<char32_t, 1> const c5 = {{ 0x0051 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_013)
{
    // 1D5E5;1D5E5;1D5E5;0052;0052; 
    // (ùó•; ùó•; ùó•; R; R; ) MATHEMATICAL SANS-SERIF BOLD CAPITAL R
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5E5 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5E5 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5E5 }};
        std::array<char32_t, 1> const c4 = {{ 0x0052 }};
        std::array<char32_t, 1> const c5 = {{ 0x0052 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_014)
{
    // 1D5E6;1D5E6;1D5E6;0053;0053; 
    // (ùó¶; ùó¶; ùó¶; S; S; ) MATHEMATICAL SANS-SERIF BOLD CAPITAL S
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5E6 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5E6 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5E6 }};
        std::array<char32_t, 1> const c4 = {{ 0x0053 }};
        std::array<char32_t, 1> const c5 = {{ 0x0053 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_015)
{
    // 1D5E7;1D5E7;1D5E7;0054;0054; 
    // (ùóß; ùóß; ùóß; T; T; ) MATHEMATICAL SANS-SERIF BOLD CAPITAL T
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5E7 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5E7 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5E7 }};
        std::array<char32_t, 1> const c4 = {{ 0x0054 }};
        std::array<char32_t, 1> const c5 = {{ 0x0054 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_016)
{
    // 1D5E8;1D5E8;1D5E8;0055;0055; 
    // (ùó®; ùó®; ùó®; U; U; ) MATHEMATICAL SANS-SERIF BOLD CAPITAL U
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5E8 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5E8 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5E8 }};
        std::array<char32_t, 1> const c4 = {{ 0x0055 }};
        std::array<char32_t, 1> const c5 = {{ 0x0055 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_017)
{
    // 1D5E9;1D5E9;1D5E9;0056;0056; 
    // (ùó©; ùó©; ùó©; V; V; ) MATHEMATICAL SANS-SERIF BOLD CAPITAL V
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5E9 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5E9 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5E9 }};
        std::array<char32_t, 1> const c4 = {{ 0x0056 }};
        std::array<char32_t, 1> const c5 = {{ 0x0056 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_018)
{
    // 1D5EA;1D5EA;1D5EA;0057;0057; 
    // (ùó™; ùó™; ùó™; W; W; ) MATHEMATICAL SANS-SERIF BOLD CAPITAL W
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5EA }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5EA }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5EA }};
        std::array<char32_t, 1> const c4 = {{ 0x0057 }};
        std::array<char32_t, 1> const c5 = {{ 0x0057 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_019)
{
    // 1D5EB;1D5EB;1D5EB;0058;0058; 
    // (ùó´; ùó´; ùó´; X; X; ) MATHEMATICAL SANS-SERIF BOLD CAPITAL X
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5EB }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5EB }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5EB }};
        std::array<char32_t, 1> const c4 = {{ 0x0058 }};
        std::array<char32_t, 1> const c5 = {{ 0x0058 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_020)
{
    // 1D5EC;1D5EC;1D5EC;0059;0059; 
    // (ùó¨; ùó¨; ùó¨; Y; Y; ) MATHEMATICAL SANS-SERIF BOLD CAPITAL Y
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5EC }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5EC }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5EC }};
        std::array<char32_t, 1> const c4 = {{ 0x0059 }};
        std::array<char32_t, 1> const c5 = {{ 0x0059 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_021)
{
    // 1D5ED;1D5ED;1D5ED;005A;005A; 
    // (ùó≠; ùó≠; ùó≠; Z; Z; ) MATHEMATICAL SANS-SERIF BOLD CAPITAL Z
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5ED }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5ED }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5ED }};
        std::array<char32_t, 1> const c4 = {{ 0x005A }};
        std::array<char32_t, 1> const c5 = {{ 0x005A }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_022)
{
    // 1D5EE;1D5EE;1D5EE;0061;0061; 
    // (ùóÆ; ùóÆ; ùóÆ; a; a; ) MATHEMATICAL SANS-SERIF BOLD SMALL A
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5EE }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5EE }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5EE }};
        std::array<char32_t, 1> const c4 = {{ 0x0061 }};
        std::array<char32_t, 1> const c5 = {{ 0x0061 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_023)
{
    // 1D5EF;1D5EF;1D5EF;0062;0062; 
    // (ùóØ; ùóØ; ùóØ; b; b; ) MATHEMATICAL SANS-SERIF BOLD SMALL B
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5EF }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5EF }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5EF }};
        std::array<char32_t, 1> const c4 = {{ 0x0062 }};
        std::array<char32_t, 1> const c5 = {{ 0x0062 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_024)
{
    // 1D5F0;1D5F0;1D5F0;0063;0063; 
    // (ùó∞; ùó∞; ùó∞; c; c; ) MATHEMATICAL SANS-SERIF BOLD SMALL C
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5F0 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5F0 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5F0 }};
        std::array<char32_t, 1> const c4 = {{ 0x0063 }};
        std::array<char32_t, 1> const c5 = {{ 0x0063 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_025)
{
    // 1D5F1;1D5F1;1D5F1;0064;0064; 
    // (ùó±; ùó±; ùó±; d; d; ) MATHEMATICAL SANS-SERIF BOLD SMALL D
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5F1 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5F1 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5F1 }};
        std::array<char32_t, 1> const c4 = {{ 0x0064 }};
        std::array<char32_t, 1> const c5 = {{ 0x0064 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_026)
{
    // 1D5F2;1D5F2;1D5F2;0065;0065; 
    // (ùó≤; ùó≤; ùó≤; e; e; ) MATHEMATICAL SANS-SERIF BOLD SMALL E
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5F2 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5F2 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5F2 }};
        std::array<char32_t, 1> const c4 = {{ 0x0065 }};
        std::array<char32_t, 1> const c5 = {{ 0x0065 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_027)
{
    // 1D5F3;1D5F3;1D5F3;0066;0066; 
    // (ùó≥; ùó≥; ùó≥; f; f; ) MATHEMATICAL SANS-SERIF BOLD SMALL F
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5F3 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5F3 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5F3 }};
        std::array<char32_t, 1> const c4 = {{ 0x0066 }};
        std::array<char32_t, 1> const c5 = {{ 0x0066 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_028)
{
    // 1D5F4;1D5F4;1D5F4;0067;0067; 
    // (ùó¥; ùó¥; ùó¥; g; g; ) MATHEMATICAL SANS-SERIF BOLD SMALL G
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5F4 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5F4 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5F4 }};
        std::array<char32_t, 1> const c4 = {{ 0x0067 }};
        std::array<char32_t, 1> const c5 = {{ 0x0067 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_029)
{
    // 1D5F5;1D5F5;1D5F5;0068;0068; 
    // (ùóµ; ùóµ; ùóµ; h; h; ) MATHEMATICAL SANS-SERIF BOLD SMALL H
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5F5 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5F5 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5F5 }};
        std::array<char32_t, 1> const c4 = {{ 0x0068 }};
        std::array<char32_t, 1> const c5 = {{ 0x0068 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_030)
{
    // 1D5F6;1D5F6;1D5F6;0069;0069; 
    // (ùó∂; ùó∂; ùó∂; i; i; ) MATHEMATICAL SANS-SERIF BOLD SMALL I
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5F6 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5F6 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5F6 }};
        std::array<char32_t, 1> const c4 = {{ 0x0069 }};
        std::array<char32_t, 1> const c5 = {{ 0x0069 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_031)
{
    // 1D5F7;1D5F7;1D5F7;006A;006A; 
    // (ùó∑; ùó∑; ùó∑; j; j; ) MATHEMATICAL SANS-SERIF BOLD SMALL J
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5F7 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5F7 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5F7 }};
        std::array<char32_t, 1> const c4 = {{ 0x006A }};
        std::array<char32_t, 1> const c5 = {{ 0x006A }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_032)
{
    // 1D5F8;1D5F8;1D5F8;006B;006B; 
    // (ùó∏; ùó∏; ùó∏; k; k; ) MATHEMATICAL SANS-SERIF BOLD SMALL K
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5F8 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5F8 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5F8 }};
        std::array<char32_t, 1> const c4 = {{ 0x006B }};
        std::array<char32_t, 1> const c5 = {{ 0x006B }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_033)
{
    // 1D5F9;1D5F9;1D5F9;006C;006C; 
    // (ùóπ; ùóπ; ùóπ; l; l; ) MATHEMATICAL SANS-SERIF BOLD SMALL L
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5F9 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5F9 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5F9 }};
        std::array<char32_t, 1> const c4 = {{ 0x006C }};
        std::array<char32_t, 1> const c5 = {{ 0x006C }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_034)
{
    // 1D5FA;1D5FA;1D5FA;006D;006D; 
    // (ùó∫; ùó∫; ùó∫; m; m; ) MATHEMATICAL SANS-SERIF BOLD SMALL M
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5FA }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5FA }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5FA }};
        std::array<char32_t, 1> const c4 = {{ 0x006D }};
        std::array<char32_t, 1> const c5 = {{ 0x006D }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_035)
{
    // 1D5FB;1D5FB;1D5FB;006E;006E; 
    // (ùóª; ùóª; ùóª; n; n; ) MATHEMATICAL SANS-SERIF BOLD SMALL N
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5FB }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5FB }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5FB }};
        std::array<char32_t, 1> const c4 = {{ 0x006E }};
        std::array<char32_t, 1> const c5 = {{ 0x006E }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_036)
{
    // 1D5FC;1D5FC;1D5FC;006F;006F; 
    // (ùóº; ùóº; ùóº; o; o; ) MATHEMATICAL SANS-SERIF BOLD SMALL O
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5FC }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5FC }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5FC }};
        std::array<char32_t, 1> const c4 = {{ 0x006F }};
        std::array<char32_t, 1> const c5 = {{ 0x006F }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_037)
{
    // 1D5FD;1D5FD;1D5FD;0070;0070; 
    // (ùóΩ; ùóΩ; ùóΩ; p; p; ) MATHEMATICAL SANS-SERIF BOLD SMALL P
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5FD }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5FD }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5FD }};
        std::array<char32_t, 1> const c4 = {{ 0x0070 }};
        std::array<char32_t, 1> const c5 = {{ 0x0070 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_038)
{
    // 1D5FE;1D5FE;1D5FE;0071;0071; 
    // (ùóæ; ùóæ; ùóæ; q; q; ) MATHEMATICAL SANS-SERIF BOLD SMALL Q
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5FE }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5FE }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5FE }};
        std::array<char32_t, 1> const c4 = {{ 0x0071 }};
        std::array<char32_t, 1> const c5 = {{ 0x0071 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_039)
{
    // 1D5FF;1D5FF;1D5FF;0072;0072; 
    // (ùóø; ùóø; ùóø; r; r; ) MATHEMATICAL SANS-SERIF BOLD SMALL R
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D5FF }};
        std::array<char32_t, 1> const c2 = {{ 0x1D5FF }};
        std::array<char32_t, 1> const c3 = {{ 0x1D5FF }};
        std::array<char32_t, 1> const c4 = {{ 0x0072 }};
        std::array<char32_t, 1> const c5 = {{ 0x0072 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_040)
{
    // 1D600;1D600;1D600;0073;0073; 
    // (ùòÄ; ùòÄ; ùòÄ; s; s; ) MATHEMATICAL SANS-SERIF BOLD SMALL S
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D600 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D600 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D600 }};
        std::array<char32_t, 1> const c4 = {{ 0x0073 }};
        std::array<char32_t, 1> const c5 = {{ 0x0073 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_041)
{
    // 1D601;1D601;1D601;0074;0074; 
    // (ùòÅ; ùòÅ; ùòÅ; t; t; ) MATHEMATICAL SANS-SERIF BOLD SMALL T
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D601 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D601 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D601 }};
        std::array<char32_t, 1> const c4 = {{ 0x0074 }};
        std::array<char32_t, 1> const c5 = {{ 0x0074 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_042)
{
    // 1D602;1D602;1D602;0075;0075; 
    // (ùòÇ; ùòÇ; ùòÇ; u; u; ) MATHEMATICAL SANS-SERIF BOLD SMALL U
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D602 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D602 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D602 }};
        std::array<char32_t, 1> const c4 = {{ 0x0075 }};
        std::array<char32_t, 1> const c5 = {{ 0x0075 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_043)
{
    // 1D603;1D603;1D603;0076;0076; 
    // (ùòÉ; ùòÉ; ùòÉ; v; v; ) MATHEMATICAL SANS-SERIF BOLD SMALL V
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D603 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D603 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D603 }};
        std::array<char32_t, 1> const c4 = {{ 0x0076 }};
        std::array<char32_t, 1> const c5 = {{ 0x0076 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_044)
{
    // 1D604;1D604;1D604;0077;0077; 
    // (ùòÑ; ùòÑ; ùòÑ; w; w; ) MATHEMATICAL SANS-SERIF BOLD SMALL W
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D604 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D604 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D604 }};
        std::array<char32_t, 1> const c4 = {{ 0x0077 }};
        std::array<char32_t, 1> const c5 = {{ 0x0077 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_045)
{
    // 1D605;1D605;1D605;0078;0078; 
    // (ùòÖ; ùòÖ; ùòÖ; x; x; ) MATHEMATICAL SANS-SERIF BOLD SMALL X
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D605 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D605 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D605 }};
        std::array<char32_t, 1> const c4 = {{ 0x0078 }};
        std::array<char32_t, 1> const c5 = {{ 0x0078 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_046)
{
    // 1D606;1D606;1D606;0079;0079; 
    // (ùòÜ; ùòÜ; ùòÜ; y; y; ) MATHEMATICAL SANS-SERIF BOLD SMALL Y
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D606 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D606 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D606 }};
        std::array<char32_t, 1> const c4 = {{ 0x0079 }};
        std::array<char32_t, 1> const c5 = {{ 0x0079 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_047)
{
    // 1D607;1D607;1D607;007A;007A; 
    // (ùòá; ùòá; ùòá; z; z; ) MATHEMATICAL SANS-SERIF BOLD SMALL Z
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D607 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D607 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D607 }};
        std::array<char32_t, 1> const c4 = {{ 0x007A }};
        std::array<char32_t, 1> const c5 = {{ 0x007A }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_048)
{
    // 1D608;1D608;1D608;0041;0041; 
    // (ùòà; ùòà; ùòà; A; A; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL A
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D608 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D608 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D608 }};
        std::array<char32_t, 1> const c4 = {{ 0x0041 }};
        std::array<char32_t, 1> const c5 = {{ 0x0041 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_049)
{
    // 1D609;1D609;1D609;0042;0042; 
    // (ùòâ; ùòâ; ùòâ; B; B; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL B
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D609 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D609 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D609 }};
        std::array<char32_t, 1> const c4 = {{ 0x0042 }};
        std::array<char32_t, 1> const c5 = {{ 0x0042 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_050)
{
    // 1D60A;1D60A;1D60A;0043;0043; 
    // (ùòä; ùòä; ùòä; C; C; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL C
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D60A }};
        std::array<char32_t, 1> const c2 = {{ 0x1D60A }};
        std::array<char32_t, 1> const c3 = {{ 0x1D60A }};
        std::array<char32_t, 1> const c4 = {{ 0x0043 }};
        std::array<char32_t, 1> const c5 = {{ 0x0043 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_051)
{
    // 1D60B;1D60B;1D60B;0044;0044; 
    // (ùòã; ùòã; ùòã; D; D; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL D
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D60B }};
        std::array<char32_t, 1> const c2 = {{ 0x1D60B }};
        std::array<char32_t, 1> const c3 = {{ 0x1D60B }};
        std::array<char32_t, 1> const c4 = {{ 0x0044 }};
        std::array<char32_t, 1> const c5 = {{ 0x0044 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_052)
{
    // 1D60C;1D60C;1D60C;0045;0045; 
    // (ùòå; ùòå; ùòå; E; E; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL E
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D60C }};
        std::array<char32_t, 1> const c2 = {{ 0x1D60C }};
        std::array<char32_t, 1> const c3 = {{ 0x1D60C }};
        std::array<char32_t, 1> const c4 = {{ 0x0045 }};
        std::array<char32_t, 1> const c5 = {{ 0x0045 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_053)
{
    // 1D60D;1D60D;1D60D;0046;0046; 
    // (ùòç; ùòç; ùòç; F; F; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL F
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D60D }};
        std::array<char32_t, 1> const c2 = {{ 0x1D60D }};
        std::array<char32_t, 1> const c3 = {{ 0x1D60D }};
        std::array<char32_t, 1> const c4 = {{ 0x0046 }};
        std::array<char32_t, 1> const c5 = {{ 0x0046 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_054)
{
    // 1D60E;1D60E;1D60E;0047;0047; 
    // (ùòé; ùòé; ùòé; G; G; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL G
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D60E }};
        std::array<char32_t, 1> const c2 = {{ 0x1D60E }};
        std::array<char32_t, 1> const c3 = {{ 0x1D60E }};
        std::array<char32_t, 1> const c4 = {{ 0x0047 }};
        std::array<char32_t, 1> const c5 = {{ 0x0047 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_055)
{
    // 1D60F;1D60F;1D60F;0048;0048; 
    // (ùòè; ùòè; ùòè; H; H; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL H
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D60F }};
        std::array<char32_t, 1> const c2 = {{ 0x1D60F }};
        std::array<char32_t, 1> const c3 = {{ 0x1D60F }};
        std::array<char32_t, 1> const c4 = {{ 0x0048 }};
        std::array<char32_t, 1> const c5 = {{ 0x0048 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_056)
{
    // 1D610;1D610;1D610;0049;0049; 
    // (ùòê; ùòê; ùòê; I; I; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL I
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D610 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D610 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D610 }};
        std::array<char32_t, 1> const c4 = {{ 0x0049 }};
        std::array<char32_t, 1> const c5 = {{ 0x0049 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_057)
{
    // 1D611;1D611;1D611;004A;004A; 
    // (ùòë; ùòë; ùòë; J; J; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL J
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D611 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D611 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D611 }};
        std::array<char32_t, 1> const c4 = {{ 0x004A }};
        std::array<char32_t, 1> const c5 = {{ 0x004A }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_058)
{
    // 1D612;1D612;1D612;004B;004B; 
    // (ùòí; ùòí; ùòí; K; K; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL K
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D612 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D612 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D612 }};
        std::array<char32_t, 1> const c4 = {{ 0x004B }};
        std::array<char32_t, 1> const c5 = {{ 0x004B }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_059)
{
    // 1D613;1D613;1D613;004C;004C; 
    // (ùòì; ùòì; ùòì; L; L; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL L
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D613 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D613 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D613 }};
        std::array<char32_t, 1> const c4 = {{ 0x004C }};
        std::array<char32_t, 1> const c5 = {{ 0x004C }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_060)
{
    // 1D614;1D614;1D614;004D;004D; 
    // (ùòî; ùòî; ùòî; M; M; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL M
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D614 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D614 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D614 }};
        std::array<char32_t, 1> const c4 = {{ 0x004D }};
        std::array<char32_t, 1> const c5 = {{ 0x004D }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_061)
{
    // 1D615;1D615;1D615;004E;004E; 
    // (ùòï; ùòï; ùòï; N; N; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL N
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D615 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D615 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D615 }};
        std::array<char32_t, 1> const c4 = {{ 0x004E }};
        std::array<char32_t, 1> const c5 = {{ 0x004E }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_062)
{
    // 1D616;1D616;1D616;004F;004F; 
    // (ùòñ; ùòñ; ùòñ; O; O; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL O
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D616 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D616 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D616 }};
        std::array<char32_t, 1> const c4 = {{ 0x004F }};
        std::array<char32_t, 1> const c5 = {{ 0x004F }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_063)
{
    // 1D617;1D617;1D617;0050;0050; 
    // (ùòó; ùòó; ùòó; P; P; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL P
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D617 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D617 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D617 }};
        std::array<char32_t, 1> const c4 = {{ 0x0050 }};
        std::array<char32_t, 1> const c5 = {{ 0x0050 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_064)
{
    // 1D618;1D618;1D618;0051;0051; 
    // (ùòò; ùòò; ùòò; Q; Q; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL Q
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D618 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D618 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D618 }};
        std::array<char32_t, 1> const c4 = {{ 0x0051 }};
        std::array<char32_t, 1> const c5 = {{ 0x0051 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_065)
{
    // 1D619;1D619;1D619;0052;0052; 
    // (ùòô; ùòô; ùòô; R; R; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL R
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D619 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D619 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D619 }};
        std::array<char32_t, 1> const c4 = {{ 0x0052 }};
        std::array<char32_t, 1> const c5 = {{ 0x0052 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_066)
{
    // 1D61A;1D61A;1D61A;0053;0053; 
    // (ùòö; ùòö; ùòö; S; S; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL S
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D61A }};
        std::array<char32_t, 1> const c2 = {{ 0x1D61A }};
        std::array<char32_t, 1> const c3 = {{ 0x1D61A }};
        std::array<char32_t, 1> const c4 = {{ 0x0053 }};
        std::array<char32_t, 1> const c5 = {{ 0x0053 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_067)
{
    // 1D61B;1D61B;1D61B;0054;0054; 
    // (ùòõ; ùòõ; ùòõ; T; T; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL T
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D61B }};
        std::array<char32_t, 1> const c2 = {{ 0x1D61B }};
        std::array<char32_t, 1> const c3 = {{ 0x1D61B }};
        std::array<char32_t, 1> const c4 = {{ 0x0054 }};
        std::array<char32_t, 1> const c5 = {{ 0x0054 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_068)
{
    // 1D61C;1D61C;1D61C;0055;0055; 
    // (ùòú; ùòú; ùòú; U; U; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL U
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D61C }};
        std::array<char32_t, 1> const c2 = {{ 0x1D61C }};
        std::array<char32_t, 1> const c3 = {{ 0x1D61C }};
        std::array<char32_t, 1> const c4 = {{ 0x0055 }};
        std::array<char32_t, 1> const c5 = {{ 0x0055 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_069)
{
    // 1D61D;1D61D;1D61D;0056;0056; 
    // (ùòù; ùòù; ùòù; V; V; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL V
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D61D }};
        std::array<char32_t, 1> const c2 = {{ 0x1D61D }};
        std::array<char32_t, 1> const c3 = {{ 0x1D61D }};
        std::array<char32_t, 1> const c4 = {{ 0x0056 }};
        std::array<char32_t, 1> const c5 = {{ 0x0056 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_070)
{
    // 1D61E;1D61E;1D61E;0057;0057; 
    // (ùòû; ùòû; ùòû; W; W; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL W
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D61E }};
        std::array<char32_t, 1> const c2 = {{ 0x1D61E }};
        std::array<char32_t, 1> const c3 = {{ 0x1D61E }};
        std::array<char32_t, 1> const c4 = {{ 0x0057 }};
        std::array<char32_t, 1> const c5 = {{ 0x0057 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_071)
{
    // 1D61F;1D61F;1D61F;0058;0058; 
    // (ùòü; ùòü; ùòü; X; X; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL X
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D61F }};
        std::array<char32_t, 1> const c2 = {{ 0x1D61F }};
        std::array<char32_t, 1> const c3 = {{ 0x1D61F }};
        std::array<char32_t, 1> const c4 = {{ 0x0058 }};
        std::array<char32_t, 1> const c5 = {{ 0x0058 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_072)
{
    // 1D620;1D620;1D620;0059;0059; 
    // (ùò†; ùò†; ùò†; Y; Y; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL Y
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D620 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D620 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D620 }};
        std::array<char32_t, 1> const c4 = {{ 0x0059 }};
        std::array<char32_t, 1> const c5 = {{ 0x0059 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_073)
{
    // 1D621;1D621;1D621;005A;005A; 
    // (ùò°; ùò°; ùò°; Z; Z; ) MATHEMATICAL SANS-SERIF ITALIC CAPITAL Z
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D621 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D621 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D621 }};
        std::array<char32_t, 1> const c4 = {{ 0x005A }};
        std::array<char32_t, 1> const c5 = {{ 0x005A }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_074)
{
    // 1D622;1D622;1D622;0061;0061; 
    // (ùò¢; ùò¢; ùò¢; a; a; ) MATHEMATICAL SANS-SERIF ITALIC SMALL A
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D622 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D622 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D622 }};
        std::array<char32_t, 1> const c4 = {{ 0x0061 }};
        std::array<char32_t, 1> const c5 = {{ 0x0061 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_075)
{
    // 1D623;1D623;1D623;0062;0062; 
    // (ùò£; ùò£; ùò£; b; b; ) MATHEMATICAL SANS-SERIF ITALIC SMALL B
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D623 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D623 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D623 }};
        std::array<char32_t, 1> const c4 = {{ 0x0062 }};
        std::array<char32_t, 1> const c5 = {{ 0x0062 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_076)
{
    // 1D624;1D624;1D624;0063;0063; 
    // (ùò§; ùò§; ùò§; c; c; ) MATHEMATICAL SANS-SERIF ITALIC SMALL C
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D624 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D624 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D624 }};
        std::array<char32_t, 1> const c4 = {{ 0x0063 }};
        std::array<char32_t, 1> const c5 = {{ 0x0063 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_077)
{
    // 1D625;1D625;1D625;0064;0064; 
    // (ùò•; ùò•; ùò•; d; d; ) MATHEMATICAL SANS-SERIF ITALIC SMALL D
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D625 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D625 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D625 }};
        std::array<char32_t, 1> const c4 = {{ 0x0064 }};
        std::array<char32_t, 1> const c5 = {{ 0x0064 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_078)
{
    // 1D626;1D626;1D626;0065;0065; 
    // (ùò¶; ùò¶; ùò¶; e; e; ) MATHEMATICAL SANS-SERIF ITALIC SMALL E
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D626 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D626 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D626 }};
        std::array<char32_t, 1> const c4 = {{ 0x0065 }};
        std::array<char32_t, 1> const c5 = {{ 0x0065 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_079)
{
    // 1D627;1D627;1D627;0066;0066; 
    // (ùòß; ùòß; ùòß; f; f; ) MATHEMATICAL SANS-SERIF ITALIC SMALL F
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D627 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D627 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D627 }};
        std::array<char32_t, 1> const c4 = {{ 0x0066 }};
        std::array<char32_t, 1> const c5 = {{ 0x0066 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_080)
{
    // 1D628;1D628;1D628;0067;0067; 
    // (ùò®; ùò®; ùò®; g; g; ) MATHEMATICAL SANS-SERIF ITALIC SMALL G
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D628 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D628 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D628 }};
        std::array<char32_t, 1> const c4 = {{ 0x0067 }};
        std::array<char32_t, 1> const c5 = {{ 0x0067 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_081)
{
    // 1D629;1D629;1D629;0068;0068; 
    // (ùò©; ùò©; ùò©; h; h; ) MATHEMATICAL SANS-SERIF ITALIC SMALL H
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D629 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D629 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D629 }};
        std::array<char32_t, 1> const c4 = {{ 0x0068 }};
        std::array<char32_t, 1> const c5 = {{ 0x0068 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_082)
{
    // 1D62A;1D62A;1D62A;0069;0069; 
    // (ùò™; ùò™; ùò™; i; i; ) MATHEMATICAL SANS-SERIF ITALIC SMALL I
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D62A }};
        std::array<char32_t, 1> const c2 = {{ 0x1D62A }};
        std::array<char32_t, 1> const c3 = {{ 0x1D62A }};
        std::array<char32_t, 1> const c4 = {{ 0x0069 }};
        std::array<char32_t, 1> const c5 = {{ 0x0069 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_083)
{
    // 1D62B;1D62B;1D62B;006A;006A; 
    // (ùò´; ùò´; ùò´; j; j; ) MATHEMATICAL SANS-SERIF ITALIC SMALL J
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D62B }};
        std::array<char32_t, 1> const c2 = {{ 0x1D62B }};
        std::array<char32_t, 1> const c3 = {{ 0x1D62B }};
        std::array<char32_t, 1> const c4 = {{ 0x006A }};
        std::array<char32_t, 1> const c5 = {{ 0x006A }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_084)
{
    // 1D62C;1D62C;1D62C;006B;006B; 
    // (ùò¨; ùò¨; ùò¨; k; k; ) MATHEMATICAL SANS-SERIF ITALIC SMALL K
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D62C }};
        std::array<char32_t, 1> const c2 = {{ 0x1D62C }};
        std::array<char32_t, 1> const c3 = {{ 0x1D62C }};
        std::array<char32_t, 1> const c4 = {{ 0x006B }};
        std::array<char32_t, 1> const c5 = {{ 0x006B }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_085)
{
    // 1D62D;1D62D;1D62D;006C;006C; 
    // (ùò≠; ùò≠; ùò≠; l; l; ) MATHEMATICAL SANS-SERIF ITALIC SMALL L
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D62D }};
        std::array<char32_t, 1> const c2 = {{ 0x1D62D }};
        std::array<char32_t, 1> const c3 = {{ 0x1D62D }};
        std::array<char32_t, 1> const c4 = {{ 0x006C }};
        std::array<char32_t, 1> const c5 = {{ 0x006C }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_086)
{
    // 1D62E;1D62E;1D62E;006D;006D; 
    // (ùòÆ; ùòÆ; ùòÆ; m; m; ) MATHEMATICAL SANS-SERIF ITALIC SMALL M
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D62E }};
        std::array<char32_t, 1> const c2 = {{ 0x1D62E }};
        std::array<char32_t, 1> const c3 = {{ 0x1D62E }};
        std::array<char32_t, 1> const c4 = {{ 0x006D }};
        std::array<char32_t, 1> const c5 = {{ 0x006D }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_087)
{
    // 1D62F;1D62F;1D62F;006E;006E; 
    // (ùòØ; ùòØ; ùòØ; n; n; ) MATHEMATICAL SANS-SERIF ITALIC SMALL N
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D62F }};
        std::array<char32_t, 1> const c2 = {{ 0x1D62F }};
        std::array<char32_t, 1> const c3 = {{ 0x1D62F }};
        std::array<char32_t, 1> const c4 = {{ 0x006E }};
        std::array<char32_t, 1> const c5 = {{ 0x006E }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_088)
{
    // 1D630;1D630;1D630;006F;006F; 
    // (ùò∞; ùò∞; ùò∞; o; o; ) MATHEMATICAL SANS-SERIF ITALIC SMALL O
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D630 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D630 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D630 }};
        std::array<char32_t, 1> const c4 = {{ 0x006F }};
        std::array<char32_t, 1> const c5 = {{ 0x006F }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_089)
{
    // 1D631;1D631;1D631;0070;0070; 
    // (ùò±; ùò±; ùò±; p; p; ) MATHEMATICAL SANS-SERIF ITALIC SMALL P
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D631 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D631 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D631 }};
        std::array<char32_t, 1> const c4 = {{ 0x0070 }};
        std::array<char32_t, 1> const c5 = {{ 0x0070 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_090)
{
    // 1D632;1D632;1D632;0071;0071; 
    // (ùò≤; ùò≤; ùò≤; q; q; ) MATHEMATICAL SANS-SERIF ITALIC SMALL Q
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D632 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D632 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D632 }};
        std::array<char32_t, 1> const c4 = {{ 0x0071 }};
        std::array<char32_t, 1> const c5 = {{ 0x0071 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_091)
{
    // 1D633;1D633;1D633;0072;0072; 
    // (ùò≥; ùò≥; ùò≥; r; r; ) MATHEMATICAL SANS-SERIF ITALIC SMALL R
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D633 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D633 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D633 }};
        std::array<char32_t, 1> const c4 = {{ 0x0072 }};
        std::array<char32_t, 1> const c5 = {{ 0x0072 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_092)
{
    // 1D634;1D634;1D634;0073;0073; 
    // (ùò¥; ùò¥; ùò¥; s; s; ) MATHEMATICAL SANS-SERIF ITALIC SMALL S
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D634 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D634 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D634 }};
        std::array<char32_t, 1> const c4 = {{ 0x0073 }};
        std::array<char32_t, 1> const c5 = {{ 0x0073 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_093)
{
    // 1D635;1D635;1D635;0074;0074; 
    // (ùòµ; ùòµ; ùòµ; t; t; ) MATHEMATICAL SANS-SERIF ITALIC SMALL T
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D635 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D635 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D635 }};
        std::array<char32_t, 1> const c4 = {{ 0x0074 }};
        std::array<char32_t, 1> const c5 = {{ 0x0074 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_094)
{
    // 1D636;1D636;1D636;0075;0075; 
    // (ùò∂; ùò∂; ùò∂; u; u; ) MATHEMATICAL SANS-SERIF ITALIC SMALL U
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D636 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D636 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D636 }};
        std::array<char32_t, 1> const c4 = {{ 0x0075 }};
        std::array<char32_t, 1> const c5 = {{ 0x0075 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_095)
{
    // 1D637;1D637;1D637;0076;0076; 
    // (ùò∑; ùò∑; ùò∑; v; v; ) MATHEMATICAL SANS-SERIF ITALIC SMALL V
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D637 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D637 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D637 }};
        std::array<char32_t, 1> const c4 = {{ 0x0076 }};
        std::array<char32_t, 1> const c5 = {{ 0x0076 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_096)
{
    // 1D638;1D638;1D638;0077;0077; 
    // (ùò∏; ùò∏; ùò∏; w; w; ) MATHEMATICAL SANS-SERIF ITALIC SMALL W
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D638 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D638 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D638 }};
        std::array<char32_t, 1> const c4 = {{ 0x0077 }};
        std::array<char32_t, 1> const c5 = {{ 0x0077 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_097)
{
    // 1D639;1D639;1D639;0078;0078; 
    // (ùòπ; ùòπ; ùòπ; x; x; ) MATHEMATICAL SANS-SERIF ITALIC SMALL X
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D639 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D639 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D639 }};
        std::array<char32_t, 1> const c4 = {{ 0x0078 }};
        std::array<char32_t, 1> const c5 = {{ 0x0078 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_098)
{
    // 1D63A;1D63A;1D63A;0079;0079; 
    // (ùò∫; ùò∫; ùò∫; y; y; ) MATHEMATICAL SANS-SERIF ITALIC SMALL Y
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D63A }};
        std::array<char32_t, 1> const c2 = {{ 0x1D63A }};
        std::array<char32_t, 1> const c3 = {{ 0x1D63A }};
        std::array<char32_t, 1> const c4 = {{ 0x0079 }};
        std::array<char32_t, 1> const c5 = {{ 0x0079 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_099)
{
    // 1D63B;1D63B;1D63B;007A;007A; 
    // (ùòª; ùòª; ùòª; z; z; ) MATHEMATICAL SANS-SERIF ITALIC SMALL Z
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D63B }};
        std::array<char32_t, 1> const c2 = {{ 0x1D63B }};
        std::array<char32_t, 1> const c3 = {{ 0x1D63B }};
        std::array<char32_t, 1> const c4 = {{ 0x007A }};
        std::array<char32_t, 1> const c5 = {{ 0x007A }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_100)
{
    // 1D63C;1D63C;1D63C;0041;0041; 
    // (ùòº; ùòº; ùòº; A; A; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL A
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D63C }};
        std::array<char32_t, 1> const c2 = {{ 0x1D63C }};
        std::array<char32_t, 1> const c3 = {{ 0x1D63C }};
        std::array<char32_t, 1> const c4 = {{ 0x0041 }};
        std::array<char32_t, 1> const c5 = {{ 0x0041 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_101)
{
    // 1D63D;1D63D;1D63D;0042;0042; 
    // (ùòΩ; ùòΩ; ùòΩ; B; B; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL B
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D63D }};
        std::array<char32_t, 1> const c2 = {{ 0x1D63D }};
        std::array<char32_t, 1> const c3 = {{ 0x1D63D }};
        std::array<char32_t, 1> const c4 = {{ 0x0042 }};
        std::array<char32_t, 1> const c5 = {{ 0x0042 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_102)
{
    // 1D63E;1D63E;1D63E;0043;0043; 
    // (ùòæ; ùòæ; ùòæ; C; C; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL C
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D63E }};
        std::array<char32_t, 1> const c2 = {{ 0x1D63E }};
        std::array<char32_t, 1> const c3 = {{ 0x1D63E }};
        std::array<char32_t, 1> const c4 = {{ 0x0043 }};
        std::array<char32_t, 1> const c5 = {{ 0x0043 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_103)
{
    // 1D63F;1D63F;1D63F;0044;0044; 
    // (ùòø; ùòø; ùòø; D; D; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL D
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D63F }};
        std::array<char32_t, 1> const c2 = {{ 0x1D63F }};
        std::array<char32_t, 1> const c3 = {{ 0x1D63F }};
        std::array<char32_t, 1> const c4 = {{ 0x0044 }};
        std::array<char32_t, 1> const c5 = {{ 0x0044 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_104)
{
    // 1D640;1D640;1D640;0045;0045; 
    // (ùôÄ; ùôÄ; ùôÄ; E; E; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL E
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D640 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D640 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D640 }};
        std::array<char32_t, 1> const c4 = {{ 0x0045 }};
        std::array<char32_t, 1> const c5 = {{ 0x0045 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_105)
{
    // 1D641;1D641;1D641;0046;0046; 
    // (ùôÅ; ùôÅ; ùôÅ; F; F; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL F
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D641 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D641 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D641 }};
        std::array<char32_t, 1> const c4 = {{ 0x0046 }};
        std::array<char32_t, 1> const c5 = {{ 0x0046 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_106)
{
    // 1D642;1D642;1D642;0047;0047; 
    // (ùôÇ; ùôÇ; ùôÇ; G; G; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL G
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D642 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D642 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D642 }};
        std::array<char32_t, 1> const c4 = {{ 0x0047 }};
        std::array<char32_t, 1> const c5 = {{ 0x0047 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_107)
{
    // 1D643;1D643;1D643;0048;0048; 
    // (ùôÉ; ùôÉ; ùôÉ; H; H; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL H
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D643 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D643 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D643 }};
        std::array<char32_t, 1> const c4 = {{ 0x0048 }};
        std::array<char32_t, 1> const c5 = {{ 0x0048 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_108)
{
    // 1D644;1D644;1D644;0049;0049; 
    // (ùôÑ; ùôÑ; ùôÑ; I; I; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL I
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D644 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D644 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D644 }};
        std::array<char32_t, 1> const c4 = {{ 0x0049 }};
        std::array<char32_t, 1> const c5 = {{ 0x0049 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_109)
{
    // 1D645;1D645;1D645;004A;004A; 
    // (ùôÖ; ùôÖ; ùôÖ; J; J; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL J
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D645 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D645 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D645 }};
        std::array<char32_t, 1> const c4 = {{ 0x004A }};
        std::array<char32_t, 1> const c5 = {{ 0x004A }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_110)
{
    // 1D646;1D646;1D646;004B;004B; 
    // (ùôÜ; ùôÜ; ùôÜ; K; K; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL K
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D646 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D646 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D646 }};
        std::array<char32_t, 1> const c4 = {{ 0x004B }};
        std::array<char32_t, 1> const c5 = {{ 0x004B }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_111)
{
    // 1D647;1D647;1D647;004C;004C; 
    // (ùôá; ùôá; ùôá; L; L; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL L
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D647 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D647 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D647 }};
        std::array<char32_t, 1> const c4 = {{ 0x004C }};
        std::array<char32_t, 1> const c5 = {{ 0x004C }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_112)
{
    // 1D648;1D648;1D648;004D;004D; 
    // (ùôà; ùôà; ùôà; M; M; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL M
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D648 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D648 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D648 }};
        std::array<char32_t, 1> const c4 = {{ 0x004D }};
        std::array<char32_t, 1> const c5 = {{ 0x004D }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_113)
{
    // 1D649;1D649;1D649;004E;004E; 
    // (ùôâ; ùôâ; ùôâ; N; N; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL N
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D649 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D649 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D649 }};
        std::array<char32_t, 1> const c4 = {{ 0x004E }};
        std::array<char32_t, 1> const c5 = {{ 0x004E }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_114)
{
    // 1D64A;1D64A;1D64A;004F;004F; 
    // (ùôä; ùôä; ùôä; O; O; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL O
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D64A }};
        std::array<char32_t, 1> const c2 = {{ 0x1D64A }};
        std::array<char32_t, 1> const c3 = {{ 0x1D64A }};
        std::array<char32_t, 1> const c4 = {{ 0x004F }};
        std::array<char32_t, 1> const c5 = {{ 0x004F }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_115)
{
    // 1D64B;1D64B;1D64B;0050;0050; 
    // (ùôã; ùôã; ùôã; P; P; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL P
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D64B }};
        std::array<char32_t, 1> const c2 = {{ 0x1D64B }};
        std::array<char32_t, 1> const c3 = {{ 0x1D64B }};
        std::array<char32_t, 1> const c4 = {{ 0x0050 }};
        std::array<char32_t, 1> const c5 = {{ 0x0050 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_116)
{
    // 1D64C;1D64C;1D64C;0051;0051; 
    // (ùôå; ùôå; ùôå; Q; Q; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL Q
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D64C }};
        std::array<char32_t, 1> const c2 = {{ 0x1D64C }};
        std::array<char32_t, 1> const c3 = {{ 0x1D64C }};
        std::array<char32_t, 1> const c4 = {{ 0x0051 }};
        std::array<char32_t, 1> const c5 = {{ 0x0051 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_117)
{
    // 1D64D;1D64D;1D64D;0052;0052; 
    // (ùôç; ùôç; ùôç; R; R; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL R
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D64D }};
        std::array<char32_t, 1> const c2 = {{ 0x1D64D }};
        std::array<char32_t, 1> const c3 = {{ 0x1D64D }};
        std::array<char32_t, 1> const c4 = {{ 0x0052 }};
        std::array<char32_t, 1> const c5 = {{ 0x0052 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_118)
{
    // 1D64E;1D64E;1D64E;0053;0053; 
    // (ùôé; ùôé; ùôé; S; S; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL S
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D64E }};
        std::array<char32_t, 1> const c2 = {{ 0x1D64E }};
        std::array<char32_t, 1> const c3 = {{ 0x1D64E }};
        std::array<char32_t, 1> const c4 = {{ 0x0053 }};
        std::array<char32_t, 1> const c5 = {{ 0x0053 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_119)
{
    // 1D64F;1D64F;1D64F;0054;0054; 
    // (ùôè; ùôè; ùôè; T; T; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL T
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D64F }};
        std::array<char32_t, 1> const c2 = {{ 0x1D64F }};
        std::array<char32_t, 1> const c3 = {{ 0x1D64F }};
        std::array<char32_t, 1> const c4 = {{ 0x0054 }};
        std::array<char32_t, 1> const c5 = {{ 0x0054 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_120)
{
    // 1D650;1D650;1D650;0055;0055; 
    // (ùôê; ùôê; ùôê; U; U; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL U
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D650 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D650 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D650 }};
        std::array<char32_t, 1> const c4 = {{ 0x0055 }};
        std::array<char32_t, 1> const c5 = {{ 0x0055 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_121)
{
    // 1D651;1D651;1D651;0056;0056; 
    // (ùôë; ùôë; ùôë; V; V; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL V
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D651 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D651 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D651 }};
        std::array<char32_t, 1> const c4 = {{ 0x0056 }};
        std::array<char32_t, 1> const c5 = {{ 0x0056 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_122)
{
    // 1D652;1D652;1D652;0057;0057; 
    // (ùôí; ùôí; ùôí; W; W; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL W
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D652 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D652 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D652 }};
        std::array<char32_t, 1> const c4 = {{ 0x0057 }};
        std::array<char32_t, 1> const c5 = {{ 0x0057 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_123)
{
    // 1D653;1D653;1D653;0058;0058; 
    // (ùôì; ùôì; ùôì; X; X; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL X
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D653 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D653 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D653 }};
        std::array<char32_t, 1> const c4 = {{ 0x0058 }};
        std::array<char32_t, 1> const c5 = {{ 0x0058 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_124)
{
    // 1D654;1D654;1D654;0059;0059; 
    // (ùôî; ùôî; ùôî; Y; Y; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL Y
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D654 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D654 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D654 }};
        std::array<char32_t, 1> const c4 = {{ 0x0059 }};
        std::array<char32_t, 1> const c5 = {{ 0x0059 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_125)
{
    // 1D655;1D655;1D655;005A;005A; 
    // (ùôï; ùôï; ùôï; Z; Z; ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL Z
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D655 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D655 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D655 }};
        std::array<char32_t, 1> const c4 = {{ 0x005A }};
        std::array<char32_t, 1> const c5 = {{ 0x005A }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_126)
{
    // 1D656;1D656;1D656;0061;0061; 
    // (ùôñ; ùôñ; ùôñ; a; a; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL A
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D656 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D656 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D656 }};
        std::array<char32_t, 1> const c4 = {{ 0x0061 }};
        std::array<char32_t, 1> const c5 = {{ 0x0061 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_127)
{
    // 1D657;1D657;1D657;0062;0062; 
    // (ùôó; ùôó; ùôó; b; b; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL B
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D657 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D657 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D657 }};
        std::array<char32_t, 1> const c4 = {{ 0x0062 }};
        std::array<char32_t, 1> const c5 = {{ 0x0062 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_128)
{
    // 1D658;1D658;1D658;0063;0063; 
    // (ùôò; ùôò; ùôò; c; c; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL C
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D658 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D658 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D658 }};
        std::array<char32_t, 1> const c4 = {{ 0x0063 }};
        std::array<char32_t, 1> const c5 = {{ 0x0063 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_129)
{
    // 1D659;1D659;1D659;0064;0064; 
    // (ùôô; ùôô; ùôô; d; d; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL D
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D659 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D659 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D659 }};
        std::array<char32_t, 1> const c4 = {{ 0x0064 }};
        std::array<char32_t, 1> const c5 = {{ 0x0064 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_130)
{
    // 1D65A;1D65A;1D65A;0065;0065; 
    // (ùôö; ùôö; ùôö; e; e; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL E
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D65A }};
        std::array<char32_t, 1> const c2 = {{ 0x1D65A }};
        std::array<char32_t, 1> const c3 = {{ 0x1D65A }};
        std::array<char32_t, 1> const c4 = {{ 0x0065 }};
        std::array<char32_t, 1> const c5 = {{ 0x0065 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_131)
{
    // 1D65B;1D65B;1D65B;0066;0066; 
    // (ùôõ; ùôõ; ùôõ; f; f; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL F
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D65B }};
        std::array<char32_t, 1> const c2 = {{ 0x1D65B }};
        std::array<char32_t, 1> const c3 = {{ 0x1D65B }};
        std::array<char32_t, 1> const c4 = {{ 0x0066 }};
        std::array<char32_t, 1> const c5 = {{ 0x0066 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_132)
{
    // 1D65C;1D65C;1D65C;0067;0067; 
    // (ùôú; ùôú; ùôú; g; g; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL G
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D65C }};
        std::array<char32_t, 1> const c2 = {{ 0x1D65C }};
        std::array<char32_t, 1> const c3 = {{ 0x1D65C }};
        std::array<char32_t, 1> const c4 = {{ 0x0067 }};
        std::array<char32_t, 1> const c5 = {{ 0x0067 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_133)
{
    // 1D65D;1D65D;1D65D;0068;0068; 
    // (ùôù; ùôù; ùôù; h; h; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL H
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D65D }};
        std::array<char32_t, 1> const c2 = {{ 0x1D65D }};
        std::array<char32_t, 1> const c3 = {{ 0x1D65D }};
        std::array<char32_t, 1> const c4 = {{ 0x0068 }};
        std::array<char32_t, 1> const c5 = {{ 0x0068 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_134)
{
    // 1D65E;1D65E;1D65E;0069;0069; 
    // (ùôû; ùôû; ùôû; i; i; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL I
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D65E }};
        std::array<char32_t, 1> const c2 = {{ 0x1D65E }};
        std::array<char32_t, 1> const c3 = {{ 0x1D65E }};
        std::array<char32_t, 1> const c4 = {{ 0x0069 }};
        std::array<char32_t, 1> const c5 = {{ 0x0069 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_135)
{
    // 1D65F;1D65F;1D65F;006A;006A; 
    // (ùôü; ùôü; ùôü; j; j; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL J
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D65F }};
        std::array<char32_t, 1> const c2 = {{ 0x1D65F }};
        std::array<char32_t, 1> const c3 = {{ 0x1D65F }};
        std::array<char32_t, 1> const c4 = {{ 0x006A }};
        std::array<char32_t, 1> const c5 = {{ 0x006A }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_136)
{
    // 1D660;1D660;1D660;006B;006B; 
    // (ùô†; ùô†; ùô†; k; k; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL K
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D660 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D660 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D660 }};
        std::array<char32_t, 1> const c4 = {{ 0x006B }};
        std::array<char32_t, 1> const c5 = {{ 0x006B }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_137)
{
    // 1D661;1D661;1D661;006C;006C; 
    // (ùô°; ùô°; ùô°; l; l; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL L
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D661 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D661 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D661 }};
        std::array<char32_t, 1> const c4 = {{ 0x006C }};
        std::array<char32_t, 1> const c5 = {{ 0x006C }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_138)
{
    // 1D662;1D662;1D662;006D;006D; 
    // (ùô¢; ùô¢; ùô¢; m; m; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL M
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D662 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D662 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D662 }};
        std::array<char32_t, 1> const c4 = {{ 0x006D }};
        std::array<char32_t, 1> const c5 = {{ 0x006D }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_139)
{
    // 1D663;1D663;1D663;006E;006E; 
    // (ùô£; ùô£; ùô£; n; n; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL N
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D663 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D663 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D663 }};
        std::array<char32_t, 1> const c4 = {{ 0x006E }};
        std::array<char32_t, 1> const c5 = {{ 0x006E }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_140)
{
    // 1D664;1D664;1D664;006F;006F; 
    // (ùô§; ùô§; ùô§; o; o; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL O
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D664 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D664 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D664 }};
        std::array<char32_t, 1> const c4 = {{ 0x006F }};
        std::array<char32_t, 1> const c5 = {{ 0x006F }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_141)
{
    // 1D665;1D665;1D665;0070;0070; 
    // (ùô•; ùô•; ùô•; p; p; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL P
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D665 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D665 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D665 }};
        std::array<char32_t, 1> const c4 = {{ 0x0070 }};
        std::array<char32_t, 1> const c5 = {{ 0x0070 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_142)
{
    // 1D666;1D666;1D666;0071;0071; 
    // (ùô¶; ùô¶; ùô¶; q; q; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL Q
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D666 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D666 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D666 }};
        std::array<char32_t, 1> const c4 = {{ 0x0071 }};
        std::array<char32_t, 1> const c5 = {{ 0x0071 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_143)
{
    // 1D667;1D667;1D667;0072;0072; 
    // (ùôß; ùôß; ùôß; r; r; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL R
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D667 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D667 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D667 }};
        std::array<char32_t, 1> const c4 = {{ 0x0072 }};
        std::array<char32_t, 1> const c5 = {{ 0x0072 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_144)
{
    // 1D668;1D668;1D668;0073;0073; 
    // (ùô®; ùô®; ùô®; s; s; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL S
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D668 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D668 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D668 }};
        std::array<char32_t, 1> const c4 = {{ 0x0073 }};
        std::array<char32_t, 1> const c5 = {{ 0x0073 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_145)
{
    // 1D669;1D669;1D669;0074;0074; 
    // (ùô©; ùô©; ùô©; t; t; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL T
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D669 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D669 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D669 }};
        std::array<char32_t, 1> const c4 = {{ 0x0074 }};
        std::array<char32_t, 1> const c5 = {{ 0x0074 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_146)
{
    // 1D66A;1D66A;1D66A;0075;0075; 
    // (ùô™; ùô™; ùô™; u; u; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL U
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D66A }};
        std::array<char32_t, 1> const c2 = {{ 0x1D66A }};
        std::array<char32_t, 1> const c3 = {{ 0x1D66A }};
        std::array<char32_t, 1> const c4 = {{ 0x0075 }};
        std::array<char32_t, 1> const c5 = {{ 0x0075 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_147)
{
    // 1D66B;1D66B;1D66B;0076;0076; 
    // (ùô´; ùô´; ùô´; v; v; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL V
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D66B }};
        std::array<char32_t, 1> const c2 = {{ 0x1D66B }};
        std::array<char32_t, 1> const c3 = {{ 0x1D66B }};
        std::array<char32_t, 1> const c4 = {{ 0x0076 }};
        std::array<char32_t, 1> const c5 = {{ 0x0076 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_148)
{
    // 1D66C;1D66C;1D66C;0077;0077; 
    // (ùô¨; ùô¨; ùô¨; w; w; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL W
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D66C }};
        std::array<char32_t, 1> const c2 = {{ 0x1D66C }};
        std::array<char32_t, 1> const c3 = {{ 0x1D66C }};
        std::array<char32_t, 1> const c4 = {{ 0x0077 }};
        std::array<char32_t, 1> const c5 = {{ 0x0077 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_149)
{
    // 1D66D;1D66D;1D66D;0078;0078; 
    // (ùô≠; ùô≠; ùô≠; x; x; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL X
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D66D }};
        std::array<char32_t, 1> const c2 = {{ 0x1D66D }};
        std::array<char32_t, 1> const c3 = {{ 0x1D66D }};
        std::array<char32_t, 1> const c4 = {{ 0x0078 }};
        std::array<char32_t, 1> const c5 = {{ 0x0078 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_150)
{
    // 1D66E;1D66E;1D66E;0079;0079; 
    // (ùôÆ; ùôÆ; ùôÆ; y; y; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL Y
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D66E }};
        std::array<char32_t, 1> const c2 = {{ 0x1D66E }};
        std::array<char32_t, 1> const c3 = {{ 0x1D66E }};
        std::array<char32_t, 1> const c4 = {{ 0x0079 }};
        std::array<char32_t, 1> const c5 = {{ 0x0079 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_151)
{
    // 1D66F;1D66F;1D66F;007A;007A; 
    // (ùôØ; ùôØ; ùôØ; z; z; ) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL Z
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D66F }};
        std::array<char32_t, 1> const c2 = {{ 0x1D66F }};
        std::array<char32_t, 1> const c3 = {{ 0x1D66F }};
        std::array<char32_t, 1> const c4 = {{ 0x007A }};
        std::array<char32_t, 1> const c5 = {{ 0x007A }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_152)
{
    // 1D670;1D670;1D670;0041;0041; 
    // (ùô∞; ùô∞; ùô∞; A; A; ) MATHEMATICAL MONOSPACE CAPITAL A
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D670 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D670 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D670 }};
        std::array<char32_t, 1> const c4 = {{ 0x0041 }};
        std::array<char32_t, 1> const c5 = {{ 0x0041 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_153)
{
    // 1D671;1D671;1D671;0042;0042; 
    // (ùô±; ùô±; ùô±; B; B; ) MATHEMATICAL MONOSPACE CAPITAL B
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D671 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D671 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D671 }};
        std::array<char32_t, 1> const c4 = {{ 0x0042 }};
        std::array<char32_t, 1> const c5 = {{ 0x0042 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_154)
{
    // 1D672;1D672;1D672;0043;0043; 
    // (ùô≤; ùô≤; ùô≤; C; C; ) MATHEMATICAL MONOSPACE CAPITAL C
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D672 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D672 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D672 }};
        std::array<char32_t, 1> const c4 = {{ 0x0043 }};
        std::array<char32_t, 1> const c5 = {{ 0x0043 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_155)
{
    // 1D673;1D673;1D673;0044;0044; 
    // (ùô≥; ùô≥; ùô≥; D; D; ) MATHEMATICAL MONOSPACE CAPITAL D
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D673 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D673 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D673 }};
        std::array<char32_t, 1> const c4 = {{ 0x0044 }};
        std::array<char32_t, 1> const c5 = {{ 0x0044 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_156)
{
    // 1D674;1D674;1D674;0045;0045; 
    // (ùô¥; ùô¥; ùô¥; E; E; ) MATHEMATICAL MONOSPACE CAPITAL E
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D674 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D674 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D674 }};
        std::array<char32_t, 1> const c4 = {{ 0x0045 }};
        std::array<char32_t, 1> const c5 = {{ 0x0045 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_157)
{
    // 1D675;1D675;1D675;0046;0046; 
    // (ùôµ; ùôµ; ùôµ; F; F; ) MATHEMATICAL MONOSPACE CAPITAL F
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D675 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D675 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D675 }};
        std::array<char32_t, 1> const c4 = {{ 0x0046 }};
        std::array<char32_t, 1> const c5 = {{ 0x0046 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_158)
{
    // 1D676;1D676;1D676;0047;0047; 
    // (ùô∂; ùô∂; ùô∂; G; G; ) MATHEMATICAL MONOSPACE CAPITAL G
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D676 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D676 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D676 }};
        std::array<char32_t, 1> const c4 = {{ 0x0047 }};
        std::array<char32_t, 1> const c5 = {{ 0x0047 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_159)
{
    // 1D677;1D677;1D677;0048;0048; 
    // (ùô∑; ùô∑; ùô∑; H; H; ) MATHEMATICAL MONOSPACE CAPITAL H
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D677 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D677 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D677 }};
        std::array<char32_t, 1> const c4 = {{ 0x0048 }};
        std::array<char32_t, 1> const c5 = {{ 0x0048 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_160)
{
    // 1D678;1D678;1D678;0049;0049; 
    // (ùô∏; ùô∏; ùô∏; I; I; ) MATHEMATICAL MONOSPACE CAPITAL I
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D678 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D678 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D678 }};
        std::array<char32_t, 1> const c4 = {{ 0x0049 }};
        std::array<char32_t, 1> const c5 = {{ 0x0049 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_161)
{
    // 1D679;1D679;1D679;004A;004A; 
    // (ùôπ; ùôπ; ùôπ; J; J; ) MATHEMATICAL MONOSPACE CAPITAL J
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D679 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D679 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D679 }};
        std::array<char32_t, 1> const c4 = {{ 0x004A }};
        std::array<char32_t, 1> const c5 = {{ 0x004A }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_162)
{
    // 1D67A;1D67A;1D67A;004B;004B; 
    // (ùô∫; ùô∫; ùô∫; K; K; ) MATHEMATICAL MONOSPACE CAPITAL K
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D67A }};
        std::array<char32_t, 1> const c2 = {{ 0x1D67A }};
        std::array<char32_t, 1> const c3 = {{ 0x1D67A }};
        std::array<char32_t, 1> const c4 = {{ 0x004B }};
        std::array<char32_t, 1> const c5 = {{ 0x004B }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_163)
{
    // 1D67B;1D67B;1D67B;004C;004C; 
    // (ùôª; ùôª; ùôª; L; L; ) MATHEMATICAL MONOSPACE CAPITAL L
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D67B }};
        std::array<char32_t, 1> const c2 = {{ 0x1D67B }};
        std::array<char32_t, 1> const c3 = {{ 0x1D67B }};
        std::array<char32_t, 1> const c4 = {{ 0x004C }};
        std::array<char32_t, 1> const c5 = {{ 0x004C }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_164)
{
    // 1D67C;1D67C;1D67C;004D;004D; 
    // (ùôº; ùôº; ùôº; M; M; ) MATHEMATICAL MONOSPACE CAPITAL M
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D67C }};
        std::array<char32_t, 1> const c2 = {{ 0x1D67C }};
        std::array<char32_t, 1> const c3 = {{ 0x1D67C }};
        std::array<char32_t, 1> const c4 = {{ 0x004D }};
        std::array<char32_t, 1> const c5 = {{ 0x004D }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_165)
{
    // 1D67D;1D67D;1D67D;004E;004E; 
    // (ùôΩ; ùôΩ; ùôΩ; N; N; ) MATHEMATICAL MONOSPACE CAPITAL N
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D67D }};
        std::array<char32_t, 1> const c2 = {{ 0x1D67D }};
        std::array<char32_t, 1> const c3 = {{ 0x1D67D }};
        std::array<char32_t, 1> const c4 = {{ 0x004E }};
        std::array<char32_t, 1> const c5 = {{ 0x004E }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_166)
{
    // 1D67E;1D67E;1D67E;004F;004F; 
    // (ùôæ; ùôæ; ùôæ; O; O; ) MATHEMATICAL MONOSPACE CAPITAL O
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D67E }};
        std::array<char32_t, 1> const c2 = {{ 0x1D67E }};
        std::array<char32_t, 1> const c3 = {{ 0x1D67E }};
        std::array<char32_t, 1> const c4 = {{ 0x004F }};
        std::array<char32_t, 1> const c5 = {{ 0x004F }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_167)
{
    // 1D67F;1D67F;1D67F;0050;0050; 
    // (ùôø; ùôø; ùôø; P; P; ) MATHEMATICAL MONOSPACE CAPITAL P
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D67F }};
        std::array<char32_t, 1> const c2 = {{ 0x1D67F }};
        std::array<char32_t, 1> const c3 = {{ 0x1D67F }};
        std::array<char32_t, 1> const c4 = {{ 0x0050 }};
        std::array<char32_t, 1> const c5 = {{ 0x0050 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_168)
{
    // 1D680;1D680;1D680;0051;0051; 
    // (ùöÄ; ùöÄ; ùöÄ; Q; Q; ) MATHEMATICAL MONOSPACE CAPITAL Q
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D680 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D680 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D680 }};
        std::array<char32_t, 1> const c4 = {{ 0x0051 }};
        std::array<char32_t, 1> const c5 = {{ 0x0051 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_169)
{
    // 1D681;1D681;1D681;0052;0052; 
    // (ùöÅ; ùöÅ; ùöÅ; R; R; ) MATHEMATICAL MONOSPACE CAPITAL R
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D681 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D681 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D681 }};
        std::array<char32_t, 1> const c4 = {{ 0x0052 }};
        std::array<char32_t, 1> const c5 = {{ 0x0052 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_170)
{
    // 1D682;1D682;1D682;0053;0053; 
    // (ùöÇ; ùöÇ; ùöÇ; S; S; ) MATHEMATICAL MONOSPACE CAPITAL S
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D682 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D682 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D682 }};
        std::array<char32_t, 1> const c4 = {{ 0x0053 }};
        std::array<char32_t, 1> const c5 = {{ 0x0053 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_171)
{
    // 1D683;1D683;1D683;0054;0054; 
    // (ùöÉ; ùöÉ; ùöÉ; T; T; ) MATHEMATICAL MONOSPACE CAPITAL T
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D683 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D683 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D683 }};
        std::array<char32_t, 1> const c4 = {{ 0x0054 }};
        std::array<char32_t, 1> const c5 = {{ 0x0054 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_172)
{
    // 1D684;1D684;1D684;0055;0055; 
    // (ùöÑ; ùöÑ; ùöÑ; U; U; ) MATHEMATICAL MONOSPACE CAPITAL U
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D684 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D684 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D684 }};
        std::array<char32_t, 1> const c4 = {{ 0x0055 }};
        std::array<char32_t, 1> const c5 = {{ 0x0055 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_173)
{
    // 1D685;1D685;1D685;0056;0056; 
    // (ùöÖ; ùöÖ; ùöÖ; V; V; ) MATHEMATICAL MONOSPACE CAPITAL V
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D685 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D685 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D685 }};
        std::array<char32_t, 1> const c4 = {{ 0x0056 }};
        std::array<char32_t, 1> const c5 = {{ 0x0056 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_174)
{
    // 1D686;1D686;1D686;0057;0057; 
    // (ùöÜ; ùöÜ; ùöÜ; W; W; ) MATHEMATICAL MONOSPACE CAPITAL W
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D686 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D686 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D686 }};
        std::array<char32_t, 1> const c4 = {{ 0x0057 }};
        std::array<char32_t, 1> const c5 = {{ 0x0057 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_175)
{
    // 1D687;1D687;1D687;0058;0058; 
    // (ùöá; ùöá; ùöá; X; X; ) MATHEMATICAL MONOSPACE CAPITAL X
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D687 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D687 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D687 }};
        std::array<char32_t, 1> const c4 = {{ 0x0058 }};
        std::array<char32_t, 1> const c5 = {{ 0x0058 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_176)
{
    // 1D688;1D688;1D688;0059;0059; 
    // (ùöà; ùöà; ùöà; Y; Y; ) MATHEMATICAL MONOSPACE CAPITAL Y
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D688 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D688 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D688 }};
        std::array<char32_t, 1> const c4 = {{ 0x0059 }};
        std::array<char32_t, 1> const c5 = {{ 0x0059 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_177)
{
    // 1D689;1D689;1D689;005A;005A; 
    // (ùöâ; ùöâ; ùöâ; Z; Z; ) MATHEMATICAL MONOSPACE CAPITAL Z
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D689 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D689 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D689 }};
        std::array<char32_t, 1> const c4 = {{ 0x005A }};
        std::array<char32_t, 1> const c5 = {{ 0x005A }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_178)
{
    // 1D68A;1D68A;1D68A;0061;0061; 
    // (ùöä; ùöä; ùöä; a; a; ) MATHEMATICAL MONOSPACE SMALL A
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D68A }};
        std::array<char32_t, 1> const c2 = {{ 0x1D68A }};
        std::array<char32_t, 1> const c3 = {{ 0x1D68A }};
        std::array<char32_t, 1> const c4 = {{ 0x0061 }};
        std::array<char32_t, 1> const c5 = {{ 0x0061 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_179)
{
    // 1D68B;1D68B;1D68B;0062;0062; 
    // (ùöã; ùöã; ùöã; b; b; ) MATHEMATICAL MONOSPACE SMALL B
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D68B }};
        std::array<char32_t, 1> const c2 = {{ 0x1D68B }};
        std::array<char32_t, 1> const c3 = {{ 0x1D68B }};
        std::array<char32_t, 1> const c4 = {{ 0x0062 }};
        std::array<char32_t, 1> const c5 = {{ 0x0062 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_180)
{
    // 1D68C;1D68C;1D68C;0063;0063; 
    // (ùöå; ùöå; ùöå; c; c; ) MATHEMATICAL MONOSPACE SMALL C
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D68C }};
        std::array<char32_t, 1> const c2 = {{ 0x1D68C }};
        std::array<char32_t, 1> const c3 = {{ 0x1D68C }};
        std::array<char32_t, 1> const c4 = {{ 0x0063 }};
        std::array<char32_t, 1> const c5 = {{ 0x0063 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_181)
{
    // 1D68D;1D68D;1D68D;0064;0064; 
    // (ùöç; ùöç; ùöç; d; d; ) MATHEMATICAL MONOSPACE SMALL D
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D68D }};
        std::array<char32_t, 1> const c2 = {{ 0x1D68D }};
        std::array<char32_t, 1> const c3 = {{ 0x1D68D }};
        std::array<char32_t, 1> const c4 = {{ 0x0064 }};
        std::array<char32_t, 1> const c5 = {{ 0x0064 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_182)
{
    // 1D68E;1D68E;1D68E;0065;0065; 
    // (ùöé; ùöé; ùöé; e; e; ) MATHEMATICAL MONOSPACE SMALL E
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D68E }};
        std::array<char32_t, 1> const c2 = {{ 0x1D68E }};
        std::array<char32_t, 1> const c3 = {{ 0x1D68E }};
        std::array<char32_t, 1> const c4 = {{ 0x0065 }};
        std::array<char32_t, 1> const c5 = {{ 0x0065 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_183)
{
    // 1D68F;1D68F;1D68F;0066;0066; 
    // (ùöè; ùöè; ùöè; f; f; ) MATHEMATICAL MONOSPACE SMALL F
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D68F }};
        std::array<char32_t, 1> const c2 = {{ 0x1D68F }};
        std::array<char32_t, 1> const c3 = {{ 0x1D68F }};
        std::array<char32_t, 1> const c4 = {{ 0x0066 }};
        std::array<char32_t, 1> const c5 = {{ 0x0066 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_184)
{
    // 1D690;1D690;1D690;0067;0067; 
    // (ùöê; ùöê; ùöê; g; g; ) MATHEMATICAL MONOSPACE SMALL G
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D690 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D690 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D690 }};
        std::array<char32_t, 1> const c4 = {{ 0x0067 }};
        std::array<char32_t, 1> const c5 = {{ 0x0067 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_185)
{
    // 1D691;1D691;1D691;0068;0068; 
    // (ùöë; ùöë; ùöë; h; h; ) MATHEMATICAL MONOSPACE SMALL H
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D691 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D691 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D691 }};
        std::array<char32_t, 1> const c4 = {{ 0x0068 }};
        std::array<char32_t, 1> const c5 = {{ 0x0068 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_186)
{
    // 1D692;1D692;1D692;0069;0069; 
    // (ùöí; ùöí; ùöí; i; i; ) MATHEMATICAL MONOSPACE SMALL I
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D692 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D692 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D692 }};
        std::array<char32_t, 1> const c4 = {{ 0x0069 }};
        std::array<char32_t, 1> const c5 = {{ 0x0069 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_187)
{
    // 1D693;1D693;1D693;006A;006A; 
    // (ùöì; ùöì; ùöì; j; j; ) MATHEMATICAL MONOSPACE SMALL J
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D693 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D693 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D693 }};
        std::array<char32_t, 1> const c4 = {{ 0x006A }};
        std::array<char32_t, 1> const c5 = {{ 0x006A }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_188)
{
    // 1D694;1D694;1D694;006B;006B; 
    // (ùöî; ùöî; ùöî; k; k; ) MATHEMATICAL MONOSPACE SMALL K
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D694 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D694 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D694 }};
        std::array<char32_t, 1> const c4 = {{ 0x006B }};
        std::array<char32_t, 1> const c5 = {{ 0x006B }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_189)
{
    // 1D695;1D695;1D695;006C;006C; 
    // (ùöï; ùöï; ùöï; l; l; ) MATHEMATICAL MONOSPACE SMALL L
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D695 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D695 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D695 }};
        std::array<char32_t, 1> const c4 = {{ 0x006C }};
        std::array<char32_t, 1> const c5 = {{ 0x006C }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_190)
{
    // 1D696;1D696;1D696;006D;006D; 
    // (ùöñ; ùöñ; ùöñ; m; m; ) MATHEMATICAL MONOSPACE SMALL M
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D696 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D696 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D696 }};
        std::array<char32_t, 1> const c4 = {{ 0x006D }};
        std::array<char32_t, 1> const c5 = {{ 0x006D }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_191)
{
    // 1D697;1D697;1D697;006E;006E; 
    // (ùöó; ùöó; ùöó; n; n; ) MATHEMATICAL MONOSPACE SMALL N
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D697 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D697 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D697 }};
        std::array<char32_t, 1> const c4 = {{ 0x006E }};
        std::array<char32_t, 1> const c5 = {{ 0x006E }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_192)
{
    // 1D698;1D698;1D698;006F;006F; 
    // (ùöò; ùöò; ùöò; o; o; ) MATHEMATICAL MONOSPACE SMALL O
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D698 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D698 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D698 }};
        std::array<char32_t, 1> const c4 = {{ 0x006F }};
        std::array<char32_t, 1> const c5 = {{ 0x006F }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_193)
{
    // 1D699;1D699;1D699;0070;0070; 
    // (ùöô; ùöô; ùöô; p; p; ) MATHEMATICAL MONOSPACE SMALL P
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D699 }};
        std::array<char32_t, 1> const c2 = {{ 0x1D699 }};
        std::array<char32_t, 1> const c3 = {{ 0x1D699 }};
        std::array<char32_t, 1> const c4 = {{ 0x0070 }};
        std::array<char32_t, 1> const c5 = {{ 0x0070 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_194)
{
    // 1D69A;1D69A;1D69A;0071;0071; 
    // (ùöö; ùöö; ùöö; q; q; ) MATHEMATICAL MONOSPACE SMALL Q
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D69A }};
        std::array<char32_t, 1> const c2 = {{ 0x1D69A }};
        std::array<char32_t, 1> const c3 = {{ 0x1D69A }};
        std::array<char32_t, 1> const c4 = {{ 0x0071 }};
        std::array<char32_t, 1> const c5 = {{ 0x0071 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_195)
{
    // 1D69B;1D69B;1D69B;0072;0072; 
    // (ùöõ; ùöõ; ùöõ; r; r; ) MATHEMATICAL MONOSPACE SMALL R
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D69B }};
        std::array<char32_t, 1> const c2 = {{ 0x1D69B }};
        std::array<char32_t, 1> const c3 = {{ 0x1D69B }};
        std::array<char32_t, 1> const c4 = {{ 0x0072 }};
        std::array<char32_t, 1> const c5 = {{ 0x0072 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_196)
{
    // 1D69C;1D69C;1D69C;0073;0073; 
    // (ùöú; ùöú; ùöú; s; s; ) MATHEMATICAL MONOSPACE SMALL S
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D69C }};
        std::array<char32_t, 1> const c2 = {{ 0x1D69C }};
        std::array<char32_t, 1> const c3 = {{ 0x1D69C }};
        std::array<char32_t, 1> const c4 = {{ 0x0073 }};
        std::array<char32_t, 1> const c5 = {{ 0x0073 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_197)
{
    // 1D69D;1D69D;1D69D;0074;0074; 
    // (ùöù; ùöù; ùöù; t; t; ) MATHEMATICAL MONOSPACE SMALL T
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D69D }};
        std::array<char32_t, 1> const c2 = {{ 0x1D69D }};
        std::array<char32_t, 1> const c3 = {{ 0x1D69D }};
        std::array<char32_t, 1> const c4 = {{ 0x0074 }};
        std::array<char32_t, 1> const c5 = {{ 0x0074 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_198)
{
    // 1D69E;1D69E;1D69E;0075;0075; 
    // (ùöû; ùöû; ùöû; u; u; ) MATHEMATICAL MONOSPACE SMALL U
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D69E }};
        std::array<char32_t, 1> const c2 = {{ 0x1D69E }};
        std::array<char32_t, 1> const c3 = {{ 0x1D69E }};
        std::array<char32_t, 1> const c4 = {{ 0x0075 }};
        std::array<char32_t, 1> const c5 = {{ 0x0075 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_078_199)
{
    // 1D69F;1D69F;1D69F;0076;0076; 
    // (ùöü; ùöü; ùöü; v; v; ) MATHEMATICAL MONOSPACE SMALL V
    {
        std::array<char32_t, 1> const c1 = {{ 0x1D69F }};
        std::array<char32_t, 1> const c2 = {{ 0x1D69F }};
        std::array<char32_t, 1> const c3 = {{ 0x1D69F }};
        std::array<char32_t, 1> const c4 = {{ 0x0076 }};
        std::array<char32_t, 1> const c5 = {{ 0x0076 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


