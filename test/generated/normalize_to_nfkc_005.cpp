// Copyright (C) 2020 T. Zachary Laine
//
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

// Warning! This file is autogenerated.
#include <boost/text/normalize_string.hpp>
#include <boost/text/transcode_view.hpp>
#include <boost/text/string_utility.hpp>

#include <gtest/gtest.h>

#include <algorithm>



TEST(normalization, nfkc_005_000)
{
    // 1F67;1F67;03C9 0314 0342;1F67;03C9 0314 0342; 
    // (ὧ; ὧ; ω◌̔◌͂; ὧ; ω◌̔◌͂; ) GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F67 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F67 }};
        std::array<char32_t, 3> const c3 = {{ 0x03C9, 0x0314, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F67 }};
        std::array<char32_t, 3> const c5 = {{ 0x03C9, 0x0314, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_001)
{
    // 1F68;1F68;03A9 0313;1F68;03A9 0313; 
    // (Ὠ; Ὠ; Ω◌̓; Ὠ; Ω◌̓; ) GREEK CAPITAL LETTER OMEGA WITH PSILI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F68 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F68 }};
        std::array<char32_t, 2> const c3 = {{ 0x03A9, 0x0313 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F68 }};
        std::array<char32_t, 2> const c5 = {{ 0x03A9, 0x0313 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_002)
{
    // 1F69;1F69;03A9 0314;1F69;03A9 0314; 
    // (Ὡ; Ὡ; Ω◌̔; Ὡ; Ω◌̔; ) GREEK CAPITAL LETTER OMEGA WITH DASIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F69 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F69 }};
        std::array<char32_t, 2> const c3 = {{ 0x03A9, 0x0314 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F69 }};
        std::array<char32_t, 2> const c5 = {{ 0x03A9, 0x0314 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_003)
{
    // 1F6A;1F6A;03A9 0313 0300;1F6A;03A9 0313 0300; 
    // (Ὢ; Ὢ; Ω◌̓◌̀; Ὢ; Ω◌̓◌̀; ) GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F6A }};
        std::array<char32_t, 1> const c2 = {{ 0x1F6A }};
        std::array<char32_t, 3> const c3 = {{ 0x03A9, 0x0313, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F6A }};
        std::array<char32_t, 3> const c5 = {{ 0x03A9, 0x0313, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_004)
{
    // 1F6B;1F6B;03A9 0314 0300;1F6B;03A9 0314 0300; 
    // (Ὣ; Ὣ; Ω◌̔◌̀; Ὣ; Ω◌̔◌̀; ) GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F6B }};
        std::array<char32_t, 1> const c2 = {{ 0x1F6B }};
        std::array<char32_t, 3> const c3 = {{ 0x03A9, 0x0314, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F6B }};
        std::array<char32_t, 3> const c5 = {{ 0x03A9, 0x0314, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_005)
{
    // 1F6C;1F6C;03A9 0313 0301;1F6C;03A9 0313 0301; 
    // (Ὤ; Ὤ; Ω◌̓◌́; Ὤ; Ω◌̓◌́; ) GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F6C }};
        std::array<char32_t, 1> const c2 = {{ 0x1F6C }};
        std::array<char32_t, 3> const c3 = {{ 0x03A9, 0x0313, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F6C }};
        std::array<char32_t, 3> const c5 = {{ 0x03A9, 0x0313, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_006)
{
    // 1F6D;1F6D;03A9 0314 0301;1F6D;03A9 0314 0301; 
    // (Ὥ; Ὥ; Ω◌̔◌́; Ὥ; Ω◌̔◌́; ) GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F6D }};
        std::array<char32_t, 1> const c2 = {{ 0x1F6D }};
        std::array<char32_t, 3> const c3 = {{ 0x03A9, 0x0314, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F6D }};
        std::array<char32_t, 3> const c5 = {{ 0x03A9, 0x0314, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_007)
{
    // 1F6E;1F6E;03A9 0313 0342;1F6E;03A9 0313 0342; 
    // (Ὦ; Ὦ; Ω◌̓◌͂; Ὦ; Ω◌̓◌͂; ) GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F6E }};
        std::array<char32_t, 1> const c2 = {{ 0x1F6E }};
        std::array<char32_t, 3> const c3 = {{ 0x03A9, 0x0313, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F6E }};
        std::array<char32_t, 3> const c5 = {{ 0x03A9, 0x0313, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_008)
{
    // 1F6F;1F6F;03A9 0314 0342;1F6F;03A9 0314 0342; 
    // (Ὧ; Ὧ; Ω◌̔◌͂; Ὧ; Ω◌̔◌͂; ) GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F6F }};
        std::array<char32_t, 1> const c2 = {{ 0x1F6F }};
        std::array<char32_t, 3> const c3 = {{ 0x03A9, 0x0314, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F6F }};
        std::array<char32_t, 3> const c5 = {{ 0x03A9, 0x0314, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_009)
{
    // 1F70;1F70;03B1 0300;1F70;03B1 0300; 
    // (ὰ; ὰ; α◌̀; ὰ; α◌̀; ) GREEK SMALL LETTER ALPHA WITH VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F70 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F70 }};
        std::array<char32_t, 2> const c3 = {{ 0x03B1, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F70 }};
        std::array<char32_t, 2> const c5 = {{ 0x03B1, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_010)
{
    // 1F71;03AC;03B1 0301;03AC;03B1 0301; 
    // (ά; ά; α◌́; ά; α◌́; ) GREEK SMALL LETTER ALPHA WITH OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F71 }};
        std::array<char32_t, 1> const c2 = {{ 0x03AC }};
        std::array<char32_t, 2> const c3 = {{ 0x03B1, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x03AC }};
        std::array<char32_t, 2> const c5 = {{ 0x03B1, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_011)
{
    // 1F72;1F72;03B5 0300;1F72;03B5 0300; 
    // (ὲ; ὲ; ε◌̀; ὲ; ε◌̀; ) GREEK SMALL LETTER EPSILON WITH VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F72 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F72 }};
        std::array<char32_t, 2> const c3 = {{ 0x03B5, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F72 }};
        std::array<char32_t, 2> const c5 = {{ 0x03B5, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_012)
{
    // 1F73;03AD;03B5 0301;03AD;03B5 0301; 
    // (έ; έ; ε◌́; έ; ε◌́; ) GREEK SMALL LETTER EPSILON WITH OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F73 }};
        std::array<char32_t, 1> const c2 = {{ 0x03AD }};
        std::array<char32_t, 2> const c3 = {{ 0x03B5, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x03AD }};
        std::array<char32_t, 2> const c5 = {{ 0x03B5, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_013)
{
    // 1F74;1F74;03B7 0300;1F74;03B7 0300; 
    // (ὴ; ὴ; η◌̀; ὴ; η◌̀; ) GREEK SMALL LETTER ETA WITH VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F74 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F74 }};
        std::array<char32_t, 2> const c3 = {{ 0x03B7, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F74 }};
        std::array<char32_t, 2> const c5 = {{ 0x03B7, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_014)
{
    // 1F75;03AE;03B7 0301;03AE;03B7 0301; 
    // (ή; ή; η◌́; ή; η◌́; ) GREEK SMALL LETTER ETA WITH OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F75 }};
        std::array<char32_t, 1> const c2 = {{ 0x03AE }};
        std::array<char32_t, 2> const c3 = {{ 0x03B7, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x03AE }};
        std::array<char32_t, 2> const c5 = {{ 0x03B7, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_015)
{
    // 1F76;1F76;03B9 0300;1F76;03B9 0300; 
    // (ὶ; ὶ; ι◌̀; ὶ; ι◌̀; ) GREEK SMALL LETTER IOTA WITH VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F76 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F76 }};
        std::array<char32_t, 2> const c3 = {{ 0x03B9, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F76 }};
        std::array<char32_t, 2> const c5 = {{ 0x03B9, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_016)
{
    // 1F77;03AF;03B9 0301;03AF;03B9 0301; 
    // (ί; ί; ι◌́; ί; ι◌́; ) GREEK SMALL LETTER IOTA WITH OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F77 }};
        std::array<char32_t, 1> const c2 = {{ 0x03AF }};
        std::array<char32_t, 2> const c3 = {{ 0x03B9, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x03AF }};
        std::array<char32_t, 2> const c5 = {{ 0x03B9, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_017)
{
    // 1F78;1F78;03BF 0300;1F78;03BF 0300; 
    // (ὸ; ὸ; ο◌̀; ὸ; ο◌̀; ) GREEK SMALL LETTER OMICRON WITH VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F78 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F78 }};
        std::array<char32_t, 2> const c3 = {{ 0x03BF, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F78 }};
        std::array<char32_t, 2> const c5 = {{ 0x03BF, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_018)
{
    // 1F79;03CC;03BF 0301;03CC;03BF 0301; 
    // (ό; ό; ο◌́; ό; ο◌́; ) GREEK SMALL LETTER OMICRON WITH OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F79 }};
        std::array<char32_t, 1> const c2 = {{ 0x03CC }};
        std::array<char32_t, 2> const c3 = {{ 0x03BF, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x03CC }};
        std::array<char32_t, 2> const c5 = {{ 0x03BF, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_019)
{
    // 1F7A;1F7A;03C5 0300;1F7A;03C5 0300; 
    // (ὺ; ὺ; υ◌̀; ὺ; υ◌̀; ) GREEK SMALL LETTER UPSILON WITH VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F7A }};
        std::array<char32_t, 1> const c2 = {{ 0x1F7A }};
        std::array<char32_t, 2> const c3 = {{ 0x03C5, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F7A }};
        std::array<char32_t, 2> const c5 = {{ 0x03C5, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_020)
{
    // 1F7B;03CD;03C5 0301;03CD;03C5 0301; 
    // (ύ; ύ; υ◌́; ύ; υ◌́; ) GREEK SMALL LETTER UPSILON WITH OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F7B }};
        std::array<char32_t, 1> const c2 = {{ 0x03CD }};
        std::array<char32_t, 2> const c3 = {{ 0x03C5, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x03CD }};
        std::array<char32_t, 2> const c5 = {{ 0x03C5, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_021)
{
    // 1F7C;1F7C;03C9 0300;1F7C;03C9 0300; 
    // (ὼ; ὼ; ω◌̀; ὼ; ω◌̀; ) GREEK SMALL LETTER OMEGA WITH VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F7C }};
        std::array<char32_t, 1> const c2 = {{ 0x1F7C }};
        std::array<char32_t, 2> const c3 = {{ 0x03C9, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F7C }};
        std::array<char32_t, 2> const c5 = {{ 0x03C9, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_022)
{
    // 1F7D;03CE;03C9 0301;03CE;03C9 0301; 
    // (ώ; ώ; ω◌́; ώ; ω◌́; ) GREEK SMALL LETTER OMEGA WITH OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F7D }};
        std::array<char32_t, 1> const c2 = {{ 0x03CE }};
        std::array<char32_t, 2> const c3 = {{ 0x03C9, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x03CE }};
        std::array<char32_t, 2> const c5 = {{ 0x03C9, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_023)
{
    // 1F80;1F80;03B1 0313 0345;1F80;03B1 0313 0345; 
    // (ᾀ; ᾀ; α◌̓◌ͅ; ᾀ; α◌̓◌ͅ; ) GREEK SMALL LETTER ALPHA WITH PSILI AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F80 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F80 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B1, 0x0313, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F80 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B1, 0x0313, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_024)
{
    // 1F81;1F81;03B1 0314 0345;1F81;03B1 0314 0345; 
    // (ᾁ; ᾁ; α◌̔◌ͅ; ᾁ; α◌̔◌ͅ; ) GREEK SMALL LETTER ALPHA WITH DASIA AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F81 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F81 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B1, 0x0314, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F81 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B1, 0x0314, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_025)
{
    // 1F82;1F82;03B1 0313 0300 0345;1F82;03B1 0313 0300 0345; 
    // (ᾂ; ᾂ; α◌̓◌̀◌ͅ; ᾂ; α◌̓◌̀◌ͅ; ) GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F82 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F82 }};
        std::array<char32_t, 4> const c3 = {{ 0x03B1, 0x0313, 0x0300, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F82 }};
        std::array<char32_t, 4> const c5 = {{ 0x03B1, 0x0313, 0x0300, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_026)
{
    // 1F83;1F83;03B1 0314 0300 0345;1F83;03B1 0314 0300 0345; 
    // (ᾃ; ᾃ; α◌̔◌̀◌ͅ; ᾃ; α◌̔◌̀◌ͅ; ) GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F83 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F83 }};
        std::array<char32_t, 4> const c3 = {{ 0x03B1, 0x0314, 0x0300, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F83 }};
        std::array<char32_t, 4> const c5 = {{ 0x03B1, 0x0314, 0x0300, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_027)
{
    // 1F84;1F84;03B1 0313 0301 0345;1F84;03B1 0313 0301 0345; 
    // (ᾄ; ᾄ; α◌̓◌́◌ͅ; ᾄ; α◌̓◌́◌ͅ; ) GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F84 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F84 }};
        std::array<char32_t, 4> const c3 = {{ 0x03B1, 0x0313, 0x0301, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F84 }};
        std::array<char32_t, 4> const c5 = {{ 0x03B1, 0x0313, 0x0301, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_028)
{
    // 1F85;1F85;03B1 0314 0301 0345;1F85;03B1 0314 0301 0345; 
    // (ᾅ; ᾅ; α◌̔◌́◌ͅ; ᾅ; α◌̔◌́◌ͅ; ) GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F85 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F85 }};
        std::array<char32_t, 4> const c3 = {{ 0x03B1, 0x0314, 0x0301, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F85 }};
        std::array<char32_t, 4> const c5 = {{ 0x03B1, 0x0314, 0x0301, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_029)
{
    // 1F86;1F86;03B1 0313 0342 0345;1F86;03B1 0313 0342 0345; 
    // (ᾆ; ᾆ; α◌̓◌͂◌ͅ; ᾆ; α◌̓◌͂◌ͅ; ) GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F86 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F86 }};
        std::array<char32_t, 4> const c3 = {{ 0x03B1, 0x0313, 0x0342, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F86 }};
        std::array<char32_t, 4> const c5 = {{ 0x03B1, 0x0313, 0x0342, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_030)
{
    // 1F87;1F87;03B1 0314 0342 0345;1F87;03B1 0314 0342 0345; 
    // (ᾇ; ᾇ; α◌̔◌͂◌ͅ; ᾇ; α◌̔◌͂◌ͅ; ) GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F87 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F87 }};
        std::array<char32_t, 4> const c3 = {{ 0x03B1, 0x0314, 0x0342, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F87 }};
        std::array<char32_t, 4> const c5 = {{ 0x03B1, 0x0314, 0x0342, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_031)
{
    // 1F88;1F88;0391 0313 0345;1F88;0391 0313 0345; 
    // (ᾈ; ᾈ; Α◌̓◌ͅ; ᾈ; Α◌̓◌ͅ; ) GREEK CAPITAL LETTER ALPHA WITH PSILI AND PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F88 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F88 }};
        std::array<char32_t, 3> const c3 = {{ 0x0391, 0x0313, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F88 }};
        std::array<char32_t, 3> const c5 = {{ 0x0391, 0x0313, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_032)
{
    // 1F89;1F89;0391 0314 0345;1F89;0391 0314 0345; 
    // (ᾉ; ᾉ; Α◌̔◌ͅ; ᾉ; Α◌̔◌ͅ; ) GREEK CAPITAL LETTER ALPHA WITH DASIA AND PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F89 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F89 }};
        std::array<char32_t, 3> const c3 = {{ 0x0391, 0x0314, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F89 }};
        std::array<char32_t, 3> const c5 = {{ 0x0391, 0x0314, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_033)
{
    // 1F8A;1F8A;0391 0313 0300 0345;1F8A;0391 0313 0300 0345; 
    // (ᾊ; ᾊ; Α◌̓◌̀◌ͅ; ᾊ; Α◌̓◌̀◌ͅ; ) GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F8A }};
        std::array<char32_t, 1> const c2 = {{ 0x1F8A }};
        std::array<char32_t, 4> const c3 = {{ 0x0391, 0x0313, 0x0300, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F8A }};
        std::array<char32_t, 4> const c5 = {{ 0x0391, 0x0313, 0x0300, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_034)
{
    // 1F8B;1F8B;0391 0314 0300 0345;1F8B;0391 0314 0300 0345; 
    // (ᾋ; ᾋ; Α◌̔◌̀◌ͅ; ᾋ; Α◌̔◌̀◌ͅ; ) GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F8B }};
        std::array<char32_t, 1> const c2 = {{ 0x1F8B }};
        std::array<char32_t, 4> const c3 = {{ 0x0391, 0x0314, 0x0300, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F8B }};
        std::array<char32_t, 4> const c5 = {{ 0x0391, 0x0314, 0x0300, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_035)
{
    // 1F8C;1F8C;0391 0313 0301 0345;1F8C;0391 0313 0301 0345; 
    // (ᾌ; ᾌ; Α◌̓◌́◌ͅ; ᾌ; Α◌̓◌́◌ͅ; ) GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F8C }};
        std::array<char32_t, 1> const c2 = {{ 0x1F8C }};
        std::array<char32_t, 4> const c3 = {{ 0x0391, 0x0313, 0x0301, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F8C }};
        std::array<char32_t, 4> const c5 = {{ 0x0391, 0x0313, 0x0301, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_036)
{
    // 1F8D;1F8D;0391 0314 0301 0345;1F8D;0391 0314 0301 0345; 
    // (ᾍ; ᾍ; Α◌̔◌́◌ͅ; ᾍ; Α◌̔◌́◌ͅ; ) GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F8D }};
        std::array<char32_t, 1> const c2 = {{ 0x1F8D }};
        std::array<char32_t, 4> const c3 = {{ 0x0391, 0x0314, 0x0301, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F8D }};
        std::array<char32_t, 4> const c5 = {{ 0x0391, 0x0314, 0x0301, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_037)
{
    // 1F8E;1F8E;0391 0313 0342 0345;1F8E;0391 0313 0342 0345; 
    // (ᾎ; ᾎ; Α◌̓◌͂◌ͅ; ᾎ; Α◌̓◌͂◌ͅ; ) GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F8E }};
        std::array<char32_t, 1> const c2 = {{ 0x1F8E }};
        std::array<char32_t, 4> const c3 = {{ 0x0391, 0x0313, 0x0342, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F8E }};
        std::array<char32_t, 4> const c5 = {{ 0x0391, 0x0313, 0x0342, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_038)
{
    // 1F8F;1F8F;0391 0314 0342 0345;1F8F;0391 0314 0342 0345; 
    // (ᾏ; ᾏ; Α◌̔◌͂◌ͅ; ᾏ; Α◌̔◌͂◌ͅ; ) GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F8F }};
        std::array<char32_t, 1> const c2 = {{ 0x1F8F }};
        std::array<char32_t, 4> const c3 = {{ 0x0391, 0x0314, 0x0342, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F8F }};
        std::array<char32_t, 4> const c5 = {{ 0x0391, 0x0314, 0x0342, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_039)
{
    // 1F90;1F90;03B7 0313 0345;1F90;03B7 0313 0345; 
    // (ᾐ; ᾐ; η◌̓◌ͅ; ᾐ; η◌̓◌ͅ; ) GREEK SMALL LETTER ETA WITH PSILI AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F90 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F90 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B7, 0x0313, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F90 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B7, 0x0313, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_040)
{
    // 1F91;1F91;03B7 0314 0345;1F91;03B7 0314 0345; 
    // (ᾑ; ᾑ; η◌̔◌ͅ; ᾑ; η◌̔◌ͅ; ) GREEK SMALL LETTER ETA WITH DASIA AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F91 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F91 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B7, 0x0314, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F91 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B7, 0x0314, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_041)
{
    // 1F92;1F92;03B7 0313 0300 0345;1F92;03B7 0313 0300 0345; 
    // (ᾒ; ᾒ; η◌̓◌̀◌ͅ; ᾒ; η◌̓◌̀◌ͅ; ) GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F92 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F92 }};
        std::array<char32_t, 4> const c3 = {{ 0x03B7, 0x0313, 0x0300, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F92 }};
        std::array<char32_t, 4> const c5 = {{ 0x03B7, 0x0313, 0x0300, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_042)
{
    // 1F93;1F93;03B7 0314 0300 0345;1F93;03B7 0314 0300 0345; 
    // (ᾓ; ᾓ; η◌̔◌̀◌ͅ; ᾓ; η◌̔◌̀◌ͅ; ) GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F93 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F93 }};
        std::array<char32_t, 4> const c3 = {{ 0x03B7, 0x0314, 0x0300, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F93 }};
        std::array<char32_t, 4> const c5 = {{ 0x03B7, 0x0314, 0x0300, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_043)
{
    // 1F94;1F94;03B7 0313 0301 0345;1F94;03B7 0313 0301 0345; 
    // (ᾔ; ᾔ; η◌̓◌́◌ͅ; ᾔ; η◌̓◌́◌ͅ; ) GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F94 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F94 }};
        std::array<char32_t, 4> const c3 = {{ 0x03B7, 0x0313, 0x0301, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F94 }};
        std::array<char32_t, 4> const c5 = {{ 0x03B7, 0x0313, 0x0301, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_044)
{
    // 1F95;1F95;03B7 0314 0301 0345;1F95;03B7 0314 0301 0345; 
    // (ᾕ; ᾕ; η◌̔◌́◌ͅ; ᾕ; η◌̔◌́◌ͅ; ) GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F95 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F95 }};
        std::array<char32_t, 4> const c3 = {{ 0x03B7, 0x0314, 0x0301, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F95 }};
        std::array<char32_t, 4> const c5 = {{ 0x03B7, 0x0314, 0x0301, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_045)
{
    // 1F96;1F96;03B7 0313 0342 0345;1F96;03B7 0313 0342 0345; 
    // (ᾖ; ᾖ; η◌̓◌͂◌ͅ; ᾖ; η◌̓◌͂◌ͅ; ) GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F96 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F96 }};
        std::array<char32_t, 4> const c3 = {{ 0x03B7, 0x0313, 0x0342, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F96 }};
        std::array<char32_t, 4> const c5 = {{ 0x03B7, 0x0313, 0x0342, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_046)
{
    // 1F97;1F97;03B7 0314 0342 0345;1F97;03B7 0314 0342 0345; 
    // (ᾗ; ᾗ; η◌̔◌͂◌ͅ; ᾗ; η◌̔◌͂◌ͅ; ) GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F97 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F97 }};
        std::array<char32_t, 4> const c3 = {{ 0x03B7, 0x0314, 0x0342, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F97 }};
        std::array<char32_t, 4> const c5 = {{ 0x03B7, 0x0314, 0x0342, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_047)
{
    // 1F98;1F98;0397 0313 0345;1F98;0397 0313 0345; 
    // (ᾘ; ᾘ; Η◌̓◌ͅ; ᾘ; Η◌̓◌ͅ; ) GREEK CAPITAL LETTER ETA WITH PSILI AND PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F98 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F98 }};
        std::array<char32_t, 3> const c3 = {{ 0x0397, 0x0313, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F98 }};
        std::array<char32_t, 3> const c5 = {{ 0x0397, 0x0313, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_048)
{
    // 1F99;1F99;0397 0314 0345;1F99;0397 0314 0345; 
    // (ᾙ; ᾙ; Η◌̔◌ͅ; ᾙ; Η◌̔◌ͅ; ) GREEK CAPITAL LETTER ETA WITH DASIA AND PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F99 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F99 }};
        std::array<char32_t, 3> const c3 = {{ 0x0397, 0x0314, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F99 }};
        std::array<char32_t, 3> const c5 = {{ 0x0397, 0x0314, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_049)
{
    // 1F9A;1F9A;0397 0313 0300 0345;1F9A;0397 0313 0300 0345; 
    // (ᾚ; ᾚ; Η◌̓◌̀◌ͅ; ᾚ; Η◌̓◌̀◌ͅ; ) GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F9A }};
        std::array<char32_t, 1> const c2 = {{ 0x1F9A }};
        std::array<char32_t, 4> const c3 = {{ 0x0397, 0x0313, 0x0300, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F9A }};
        std::array<char32_t, 4> const c5 = {{ 0x0397, 0x0313, 0x0300, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_050)
{
    // 1F9B;1F9B;0397 0314 0300 0345;1F9B;0397 0314 0300 0345; 
    // (ᾛ; ᾛ; Η◌̔◌̀◌ͅ; ᾛ; Η◌̔◌̀◌ͅ; ) GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F9B }};
        std::array<char32_t, 1> const c2 = {{ 0x1F9B }};
        std::array<char32_t, 4> const c3 = {{ 0x0397, 0x0314, 0x0300, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F9B }};
        std::array<char32_t, 4> const c5 = {{ 0x0397, 0x0314, 0x0300, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_051)
{
    // 1F9C;1F9C;0397 0313 0301 0345;1F9C;0397 0313 0301 0345; 
    // (ᾜ; ᾜ; Η◌̓◌́◌ͅ; ᾜ; Η◌̓◌́◌ͅ; ) GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F9C }};
        std::array<char32_t, 1> const c2 = {{ 0x1F9C }};
        std::array<char32_t, 4> const c3 = {{ 0x0397, 0x0313, 0x0301, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F9C }};
        std::array<char32_t, 4> const c5 = {{ 0x0397, 0x0313, 0x0301, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_052)
{
    // 1F9D;1F9D;0397 0314 0301 0345;1F9D;0397 0314 0301 0345; 
    // (ᾝ; ᾝ; Η◌̔◌́◌ͅ; ᾝ; Η◌̔◌́◌ͅ; ) GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F9D }};
        std::array<char32_t, 1> const c2 = {{ 0x1F9D }};
        std::array<char32_t, 4> const c3 = {{ 0x0397, 0x0314, 0x0301, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F9D }};
        std::array<char32_t, 4> const c5 = {{ 0x0397, 0x0314, 0x0301, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_053)
{
    // 1F9E;1F9E;0397 0313 0342 0345;1F9E;0397 0313 0342 0345; 
    // (ᾞ; ᾞ; Η◌̓◌͂◌ͅ; ᾞ; Η◌̓◌͂◌ͅ; ) GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F9E }};
        std::array<char32_t, 1> const c2 = {{ 0x1F9E }};
        std::array<char32_t, 4> const c3 = {{ 0x0397, 0x0313, 0x0342, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F9E }};
        std::array<char32_t, 4> const c5 = {{ 0x0397, 0x0313, 0x0342, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_054)
{
    // 1F9F;1F9F;0397 0314 0342 0345;1F9F;0397 0314 0342 0345; 
    // (ᾟ; ᾟ; Η◌̔◌͂◌ͅ; ᾟ; Η◌̔◌͂◌ͅ; ) GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F9F }};
        std::array<char32_t, 1> const c2 = {{ 0x1F9F }};
        std::array<char32_t, 4> const c3 = {{ 0x0397, 0x0314, 0x0342, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F9F }};
        std::array<char32_t, 4> const c5 = {{ 0x0397, 0x0314, 0x0342, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_055)
{
    // 1FA0;1FA0;03C9 0313 0345;1FA0;03C9 0313 0345; 
    // (ᾠ; ᾠ; ω◌̓◌ͅ; ᾠ; ω◌̓◌ͅ; ) GREEK SMALL LETTER OMEGA WITH PSILI AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FA0 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FA0 }};
        std::array<char32_t, 3> const c3 = {{ 0x03C9, 0x0313, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FA0 }};
        std::array<char32_t, 3> const c5 = {{ 0x03C9, 0x0313, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_056)
{
    // 1FA1;1FA1;03C9 0314 0345;1FA1;03C9 0314 0345; 
    // (ᾡ; ᾡ; ω◌̔◌ͅ; ᾡ; ω◌̔◌ͅ; ) GREEK SMALL LETTER OMEGA WITH DASIA AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FA1 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FA1 }};
        std::array<char32_t, 3> const c3 = {{ 0x03C9, 0x0314, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FA1 }};
        std::array<char32_t, 3> const c5 = {{ 0x03C9, 0x0314, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_057)
{
    // 1FA2;1FA2;03C9 0313 0300 0345;1FA2;03C9 0313 0300 0345; 
    // (ᾢ; ᾢ; ω◌̓◌̀◌ͅ; ᾢ; ω◌̓◌̀◌ͅ; ) GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FA2 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FA2 }};
        std::array<char32_t, 4> const c3 = {{ 0x03C9, 0x0313, 0x0300, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FA2 }};
        std::array<char32_t, 4> const c5 = {{ 0x03C9, 0x0313, 0x0300, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_058)
{
    // 1FA3;1FA3;03C9 0314 0300 0345;1FA3;03C9 0314 0300 0345; 
    // (ᾣ; ᾣ; ω◌̔◌̀◌ͅ; ᾣ; ω◌̔◌̀◌ͅ; ) GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FA3 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FA3 }};
        std::array<char32_t, 4> const c3 = {{ 0x03C9, 0x0314, 0x0300, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FA3 }};
        std::array<char32_t, 4> const c5 = {{ 0x03C9, 0x0314, 0x0300, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_059)
{
    // 1FA4;1FA4;03C9 0313 0301 0345;1FA4;03C9 0313 0301 0345; 
    // (ᾤ; ᾤ; ω◌̓◌́◌ͅ; ᾤ; ω◌̓◌́◌ͅ; ) GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FA4 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FA4 }};
        std::array<char32_t, 4> const c3 = {{ 0x03C9, 0x0313, 0x0301, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FA4 }};
        std::array<char32_t, 4> const c5 = {{ 0x03C9, 0x0313, 0x0301, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_060)
{
    // 1FA5;1FA5;03C9 0314 0301 0345;1FA5;03C9 0314 0301 0345; 
    // (ᾥ; ᾥ; ω◌̔◌́◌ͅ; ᾥ; ω◌̔◌́◌ͅ; ) GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FA5 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FA5 }};
        std::array<char32_t, 4> const c3 = {{ 0x03C9, 0x0314, 0x0301, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FA5 }};
        std::array<char32_t, 4> const c5 = {{ 0x03C9, 0x0314, 0x0301, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_061)
{
    // 1FA6;1FA6;03C9 0313 0342 0345;1FA6;03C9 0313 0342 0345; 
    // (ᾦ; ᾦ; ω◌̓◌͂◌ͅ; ᾦ; ω◌̓◌͂◌ͅ; ) GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FA6 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FA6 }};
        std::array<char32_t, 4> const c3 = {{ 0x03C9, 0x0313, 0x0342, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FA6 }};
        std::array<char32_t, 4> const c5 = {{ 0x03C9, 0x0313, 0x0342, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_062)
{
    // 1FA7;1FA7;03C9 0314 0342 0345;1FA7;03C9 0314 0342 0345; 
    // (ᾧ; ᾧ; ω◌̔◌͂◌ͅ; ᾧ; ω◌̔◌͂◌ͅ; ) GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FA7 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FA7 }};
        std::array<char32_t, 4> const c3 = {{ 0x03C9, 0x0314, 0x0342, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FA7 }};
        std::array<char32_t, 4> const c5 = {{ 0x03C9, 0x0314, 0x0342, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_063)
{
    // 1FA8;1FA8;03A9 0313 0345;1FA8;03A9 0313 0345; 
    // (ᾨ; ᾨ; Ω◌̓◌ͅ; ᾨ; Ω◌̓◌ͅ; ) GREEK CAPITAL LETTER OMEGA WITH PSILI AND PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FA8 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FA8 }};
        std::array<char32_t, 3> const c3 = {{ 0x03A9, 0x0313, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FA8 }};
        std::array<char32_t, 3> const c5 = {{ 0x03A9, 0x0313, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_064)
{
    // 1FA9;1FA9;03A9 0314 0345;1FA9;03A9 0314 0345; 
    // (ᾩ; ᾩ; Ω◌̔◌ͅ; ᾩ; Ω◌̔◌ͅ; ) GREEK CAPITAL LETTER OMEGA WITH DASIA AND PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FA9 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FA9 }};
        std::array<char32_t, 3> const c3 = {{ 0x03A9, 0x0314, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FA9 }};
        std::array<char32_t, 3> const c5 = {{ 0x03A9, 0x0314, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_065)
{
    // 1FAA;1FAA;03A9 0313 0300 0345;1FAA;03A9 0313 0300 0345; 
    // (ᾪ; ᾪ; Ω◌̓◌̀◌ͅ; ᾪ; Ω◌̓◌̀◌ͅ; ) GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FAA }};
        std::array<char32_t, 1> const c2 = {{ 0x1FAA }};
        std::array<char32_t, 4> const c3 = {{ 0x03A9, 0x0313, 0x0300, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FAA }};
        std::array<char32_t, 4> const c5 = {{ 0x03A9, 0x0313, 0x0300, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_066)
{
    // 1FAB;1FAB;03A9 0314 0300 0345;1FAB;03A9 0314 0300 0345; 
    // (ᾫ; ᾫ; Ω◌̔◌̀◌ͅ; ᾫ; Ω◌̔◌̀◌ͅ; ) GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FAB }};
        std::array<char32_t, 1> const c2 = {{ 0x1FAB }};
        std::array<char32_t, 4> const c3 = {{ 0x03A9, 0x0314, 0x0300, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FAB }};
        std::array<char32_t, 4> const c5 = {{ 0x03A9, 0x0314, 0x0300, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_067)
{
    // 1FAC;1FAC;03A9 0313 0301 0345;1FAC;03A9 0313 0301 0345; 
    // (ᾬ; ᾬ; Ω◌̓◌́◌ͅ; ᾬ; Ω◌̓◌́◌ͅ; ) GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FAC }};
        std::array<char32_t, 1> const c2 = {{ 0x1FAC }};
        std::array<char32_t, 4> const c3 = {{ 0x03A9, 0x0313, 0x0301, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FAC }};
        std::array<char32_t, 4> const c5 = {{ 0x03A9, 0x0313, 0x0301, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_068)
{
    // 1FAD;1FAD;03A9 0314 0301 0345;1FAD;03A9 0314 0301 0345; 
    // (ᾭ; ᾭ; Ω◌̔◌́◌ͅ; ᾭ; Ω◌̔◌́◌ͅ; ) GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FAD }};
        std::array<char32_t, 1> const c2 = {{ 0x1FAD }};
        std::array<char32_t, 4> const c3 = {{ 0x03A9, 0x0314, 0x0301, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FAD }};
        std::array<char32_t, 4> const c5 = {{ 0x03A9, 0x0314, 0x0301, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_069)
{
    // 1FAE;1FAE;03A9 0313 0342 0345;1FAE;03A9 0313 0342 0345; 
    // (ᾮ; ᾮ; Ω◌̓◌͂◌ͅ; ᾮ; Ω◌̓◌͂◌ͅ; ) GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FAE }};
        std::array<char32_t, 1> const c2 = {{ 0x1FAE }};
        std::array<char32_t, 4> const c3 = {{ 0x03A9, 0x0313, 0x0342, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FAE }};
        std::array<char32_t, 4> const c5 = {{ 0x03A9, 0x0313, 0x0342, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_070)
{
    // 1FAF;1FAF;03A9 0314 0342 0345;1FAF;03A9 0314 0342 0345; 
    // (ᾯ; ᾯ; Ω◌̔◌͂◌ͅ; ᾯ; Ω◌̔◌͂◌ͅ; ) GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FAF }};
        std::array<char32_t, 1> const c2 = {{ 0x1FAF }};
        std::array<char32_t, 4> const c3 = {{ 0x03A9, 0x0314, 0x0342, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FAF }};
        std::array<char32_t, 4> const c5 = {{ 0x03A9, 0x0314, 0x0342, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_071)
{
    // 1FB0;1FB0;03B1 0306;1FB0;03B1 0306; 
    // (ᾰ; ᾰ; α◌̆; ᾰ; α◌̆; ) GREEK SMALL LETTER ALPHA WITH VRACHY
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FB0 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FB0 }};
        std::array<char32_t, 2> const c3 = {{ 0x03B1, 0x0306 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FB0 }};
        std::array<char32_t, 2> const c5 = {{ 0x03B1, 0x0306 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_072)
{
    // 1FB1;1FB1;03B1 0304;1FB1;03B1 0304; 
    // (ᾱ; ᾱ; α◌̄; ᾱ; α◌̄; ) GREEK SMALL LETTER ALPHA WITH MACRON
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FB1 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FB1 }};
        std::array<char32_t, 2> const c3 = {{ 0x03B1, 0x0304 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FB1 }};
        std::array<char32_t, 2> const c5 = {{ 0x03B1, 0x0304 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_073)
{
    // 1FB2;1FB2;03B1 0300 0345;1FB2;03B1 0300 0345; 
    // (ᾲ; ᾲ; α◌̀◌ͅ; ᾲ; α◌̀◌ͅ; ) GREEK SMALL LETTER ALPHA WITH VARIA AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FB2 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FB2 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B1, 0x0300, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FB2 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B1, 0x0300, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_074)
{
    // 1FB3;1FB3;03B1 0345;1FB3;03B1 0345; 
    // (ᾳ; ᾳ; α◌ͅ; ᾳ; α◌ͅ; ) GREEK SMALL LETTER ALPHA WITH YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FB3 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FB3 }};
        std::array<char32_t, 2> const c3 = {{ 0x03B1, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FB3 }};
        std::array<char32_t, 2> const c5 = {{ 0x03B1, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_075)
{
    // 1FB4;1FB4;03B1 0301 0345;1FB4;03B1 0301 0345; 
    // (ᾴ; ᾴ; α◌́◌ͅ; ᾴ; α◌́◌ͅ; ) GREEK SMALL LETTER ALPHA WITH OXIA AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FB4 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FB4 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B1, 0x0301, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FB4 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B1, 0x0301, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_076)
{
    // 1FB6;1FB6;03B1 0342;1FB6;03B1 0342; 
    // (ᾶ; ᾶ; α◌͂; ᾶ; α◌͂; ) GREEK SMALL LETTER ALPHA WITH PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FB6 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FB6 }};
        std::array<char32_t, 2> const c3 = {{ 0x03B1, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FB6 }};
        std::array<char32_t, 2> const c5 = {{ 0x03B1, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_077)
{
    // 1FB7;1FB7;03B1 0342 0345;1FB7;03B1 0342 0345; 
    // (ᾷ; ᾷ; α◌͂◌ͅ; ᾷ; α◌͂◌ͅ; ) GREEK SMALL LETTER ALPHA WITH PERISPOMENI AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FB7 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FB7 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B1, 0x0342, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FB7 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B1, 0x0342, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_078)
{
    // 1FB8;1FB8;0391 0306;1FB8;0391 0306; 
    // (Ᾰ; Ᾰ; Α◌̆; Ᾰ; Α◌̆; ) GREEK CAPITAL LETTER ALPHA WITH VRACHY
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FB8 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FB8 }};
        std::array<char32_t, 2> const c3 = {{ 0x0391, 0x0306 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FB8 }};
        std::array<char32_t, 2> const c5 = {{ 0x0391, 0x0306 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_079)
{
    // 1FB9;1FB9;0391 0304;1FB9;0391 0304; 
    // (Ᾱ; Ᾱ; Α◌̄; Ᾱ; Α◌̄; ) GREEK CAPITAL LETTER ALPHA WITH MACRON
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FB9 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FB9 }};
        std::array<char32_t, 2> const c3 = {{ 0x0391, 0x0304 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FB9 }};
        std::array<char32_t, 2> const c5 = {{ 0x0391, 0x0304 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_080)
{
    // 1FBA;1FBA;0391 0300;1FBA;0391 0300; 
    // (Ὰ; Ὰ; Α◌̀; Ὰ; Α◌̀; ) GREEK CAPITAL LETTER ALPHA WITH VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FBA }};
        std::array<char32_t, 1> const c2 = {{ 0x1FBA }};
        std::array<char32_t, 2> const c3 = {{ 0x0391, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FBA }};
        std::array<char32_t, 2> const c5 = {{ 0x0391, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_081)
{
    // 1FBB;0386;0391 0301;0386;0391 0301; 
    // (Ά; Ά; Α◌́; Ά; Α◌́; ) GREEK CAPITAL LETTER ALPHA WITH OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FBB }};
        std::array<char32_t, 1> const c2 = {{ 0x0386 }};
        std::array<char32_t, 2> const c3 = {{ 0x0391, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x0386 }};
        std::array<char32_t, 2> const c5 = {{ 0x0391, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_082)
{
    // 1FBC;1FBC;0391 0345;1FBC;0391 0345; 
    // (ᾼ; ᾼ; Α◌ͅ; ᾼ; Α◌ͅ; ) GREEK CAPITAL LETTER ALPHA WITH PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FBC }};
        std::array<char32_t, 1> const c2 = {{ 0x1FBC }};
        std::array<char32_t, 2> const c3 = {{ 0x0391, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FBC }};
        std::array<char32_t, 2> const c5 = {{ 0x0391, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_083)
{
    // 1FBD;1FBD;1FBD;0020 0313;0020 0313; 
    // (᾽; ᾽; ᾽;  ◌̓;  ◌̓; ) GREEK KORONIS
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FBD }};
        std::array<char32_t, 1> const c2 = {{ 0x1FBD }};
        std::array<char32_t, 1> const c3 = {{ 0x1FBD }};
        std::array<char32_t, 2> const c4 = {{ 0x0020, 0x0313 }};
        std::array<char32_t, 2> const c5 = {{ 0x0020, 0x0313 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_084)
{
    // 1FBE;03B9;03B9;03B9;03B9; 
    // (ι; ι; ι; ι; ι; ) GREEK PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FBE }};
        std::array<char32_t, 1> const c2 = {{ 0x03B9 }};
        std::array<char32_t, 1> const c3 = {{ 0x03B9 }};
        std::array<char32_t, 1> const c4 = {{ 0x03B9 }};
        std::array<char32_t, 1> const c5 = {{ 0x03B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_085)
{
    // 1FBF;1FBF;1FBF;0020 0313;0020 0313; 
    // (᾿; ᾿; ᾿;  ◌̓;  ◌̓; ) GREEK PSILI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FBF }};
        std::array<char32_t, 1> const c2 = {{ 0x1FBF }};
        std::array<char32_t, 1> const c3 = {{ 0x1FBF }};
        std::array<char32_t, 2> const c4 = {{ 0x0020, 0x0313 }};
        std::array<char32_t, 2> const c5 = {{ 0x0020, 0x0313 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_086)
{
    // 1FC0;1FC0;1FC0;0020 0342;0020 0342; 
    // (῀; ῀; ῀;  ◌͂;  ◌͂; ) GREEK PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FC0 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FC0 }};
        std::array<char32_t, 1> const c3 = {{ 0x1FC0 }};
        std::array<char32_t, 2> const c4 = {{ 0x0020, 0x0342 }};
        std::array<char32_t, 2> const c5 = {{ 0x0020, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_087)
{
    // 1FC1;1FC1;00A8 0342;0020 0308 0342;0020 0308 0342; 
    // (῁; ῁; ¨◌͂;  ◌̈◌͂;  ◌̈◌͂; ) GREEK DIALYTIKA AND PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FC1 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FC1 }};
        std::array<char32_t, 2> const c3 = {{ 0x00A8, 0x0342 }};
        std::array<char32_t, 3> const c4 = {{ 0x0020, 0x0308, 0x0342 }};
        std::array<char32_t, 3> const c5 = {{ 0x0020, 0x0308, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_088)
{
    // 1FC2;1FC2;03B7 0300 0345;1FC2;03B7 0300 0345; 
    // (ῂ; ῂ; η◌̀◌ͅ; ῂ; η◌̀◌ͅ; ) GREEK SMALL LETTER ETA WITH VARIA AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FC2 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FC2 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B7, 0x0300, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FC2 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B7, 0x0300, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_089)
{
    // 1FC3;1FC3;03B7 0345;1FC3;03B7 0345; 
    // (ῃ; ῃ; η◌ͅ; ῃ; η◌ͅ; ) GREEK SMALL LETTER ETA WITH YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FC3 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FC3 }};
        std::array<char32_t, 2> const c3 = {{ 0x03B7, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FC3 }};
        std::array<char32_t, 2> const c5 = {{ 0x03B7, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_090)
{
    // 1FC4;1FC4;03B7 0301 0345;1FC4;03B7 0301 0345; 
    // (ῄ; ῄ; η◌́◌ͅ; ῄ; η◌́◌ͅ; ) GREEK SMALL LETTER ETA WITH OXIA AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FC4 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FC4 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B7, 0x0301, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FC4 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B7, 0x0301, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_091)
{
    // 1FC6;1FC6;03B7 0342;1FC6;03B7 0342; 
    // (ῆ; ῆ; η◌͂; ῆ; η◌͂; ) GREEK SMALL LETTER ETA WITH PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FC6 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FC6 }};
        std::array<char32_t, 2> const c3 = {{ 0x03B7, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FC6 }};
        std::array<char32_t, 2> const c5 = {{ 0x03B7, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_092)
{
    // 1FC7;1FC7;03B7 0342 0345;1FC7;03B7 0342 0345; 
    // (ῇ; ῇ; η◌͂◌ͅ; ῇ; η◌͂◌ͅ; ) GREEK SMALL LETTER ETA WITH PERISPOMENI AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FC7 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FC7 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B7, 0x0342, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FC7 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B7, 0x0342, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_093)
{
    // 1FC8;1FC8;0395 0300;1FC8;0395 0300; 
    // (Ὲ; Ὲ; Ε◌̀; Ὲ; Ε◌̀; ) GREEK CAPITAL LETTER EPSILON WITH VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FC8 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FC8 }};
        std::array<char32_t, 2> const c3 = {{ 0x0395, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FC8 }};
        std::array<char32_t, 2> const c5 = {{ 0x0395, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_094)
{
    // 1FC9;0388;0395 0301;0388;0395 0301; 
    // (Έ; Έ; Ε◌́; Έ; Ε◌́; ) GREEK CAPITAL LETTER EPSILON WITH OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FC9 }};
        std::array<char32_t, 1> const c2 = {{ 0x0388 }};
        std::array<char32_t, 2> const c3 = {{ 0x0395, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x0388 }};
        std::array<char32_t, 2> const c5 = {{ 0x0395, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_095)
{
    // 1FCA;1FCA;0397 0300;1FCA;0397 0300; 
    // (Ὴ; Ὴ; Η◌̀; Ὴ; Η◌̀; ) GREEK CAPITAL LETTER ETA WITH VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FCA }};
        std::array<char32_t, 1> const c2 = {{ 0x1FCA }};
        std::array<char32_t, 2> const c3 = {{ 0x0397, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FCA }};
        std::array<char32_t, 2> const c5 = {{ 0x0397, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_096)
{
    // 1FCB;0389;0397 0301;0389;0397 0301; 
    // (Ή; Ή; Η◌́; Ή; Η◌́; ) GREEK CAPITAL LETTER ETA WITH OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FCB }};
        std::array<char32_t, 1> const c2 = {{ 0x0389 }};
        std::array<char32_t, 2> const c3 = {{ 0x0397, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x0389 }};
        std::array<char32_t, 2> const c5 = {{ 0x0397, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_097)
{
    // 1FCC;1FCC;0397 0345;1FCC;0397 0345; 
    // (ῌ; ῌ; Η◌ͅ; ῌ; Η◌ͅ; ) GREEK CAPITAL LETTER ETA WITH PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FCC }};
        std::array<char32_t, 1> const c2 = {{ 0x1FCC }};
        std::array<char32_t, 2> const c3 = {{ 0x0397, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FCC }};
        std::array<char32_t, 2> const c5 = {{ 0x0397, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_098)
{
    // 1FCD;1FCD;1FBF 0300;0020 0313 0300;0020 0313 0300; 
    // (῍; ῍; ᾿◌̀;  ◌̓◌̀;  ◌̓◌̀; ) GREEK PSILI AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FCD }};
        std::array<char32_t, 1> const c2 = {{ 0x1FCD }};
        std::array<char32_t, 2> const c3 = {{ 0x1FBF, 0x0300 }};
        std::array<char32_t, 3> const c4 = {{ 0x0020, 0x0313, 0x0300 }};
        std::array<char32_t, 3> const c5 = {{ 0x0020, 0x0313, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_099)
{
    // 1FCE;1FCE;1FBF 0301;0020 0313 0301;0020 0313 0301; 
    // (῎; ῎; ᾿◌́;  ◌̓◌́;  ◌̓◌́; ) GREEK PSILI AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FCE }};
        std::array<char32_t, 1> const c2 = {{ 0x1FCE }};
        std::array<char32_t, 2> const c3 = {{ 0x1FBF, 0x0301 }};
        std::array<char32_t, 3> const c4 = {{ 0x0020, 0x0313, 0x0301 }};
        std::array<char32_t, 3> const c5 = {{ 0x0020, 0x0313, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_100)
{
    // 1FCF;1FCF;1FBF 0342;0020 0313 0342;0020 0313 0342; 
    // (῏; ῏; ᾿◌͂;  ◌̓◌͂;  ◌̓◌͂; ) GREEK PSILI AND PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FCF }};
        std::array<char32_t, 1> const c2 = {{ 0x1FCF }};
        std::array<char32_t, 2> const c3 = {{ 0x1FBF, 0x0342 }};
        std::array<char32_t, 3> const c4 = {{ 0x0020, 0x0313, 0x0342 }};
        std::array<char32_t, 3> const c5 = {{ 0x0020, 0x0313, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_101)
{
    // 1FD0;1FD0;03B9 0306;1FD0;03B9 0306; 
    // (ῐ; ῐ; ι◌̆; ῐ; ι◌̆; ) GREEK SMALL LETTER IOTA WITH VRACHY
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FD0 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FD0 }};
        std::array<char32_t, 2> const c3 = {{ 0x03B9, 0x0306 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FD0 }};
        std::array<char32_t, 2> const c5 = {{ 0x03B9, 0x0306 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_102)
{
    // 1FD1;1FD1;03B9 0304;1FD1;03B9 0304; 
    // (ῑ; ῑ; ι◌̄; ῑ; ι◌̄; ) GREEK SMALL LETTER IOTA WITH MACRON
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FD1 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FD1 }};
        std::array<char32_t, 2> const c3 = {{ 0x03B9, 0x0304 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FD1 }};
        std::array<char32_t, 2> const c5 = {{ 0x03B9, 0x0304 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_103)
{
    // 1FD2;1FD2;03B9 0308 0300;1FD2;03B9 0308 0300; 
    // (ῒ; ῒ; ι◌̈◌̀; ῒ; ι◌̈◌̀; ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FD2 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FD2 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B9, 0x0308, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FD2 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B9, 0x0308, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_104)
{
    // 1FD3;0390;03B9 0308 0301;0390;03B9 0308 0301; 
    // (ΐ; ΐ; ι◌̈◌́; ΐ; ι◌̈◌́; ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FD3 }};
        std::array<char32_t, 1> const c2 = {{ 0x0390 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B9, 0x0308, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x0390 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B9, 0x0308, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_105)
{
    // 1FD6;1FD6;03B9 0342;1FD6;03B9 0342; 
    // (ῖ; ῖ; ι◌͂; ῖ; ι◌͂; ) GREEK SMALL LETTER IOTA WITH PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FD6 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FD6 }};
        std::array<char32_t, 2> const c3 = {{ 0x03B9, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FD6 }};
        std::array<char32_t, 2> const c5 = {{ 0x03B9, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_106)
{
    // 1FD7;1FD7;03B9 0308 0342;1FD7;03B9 0308 0342; 
    // (ῗ; ῗ; ι◌̈◌͂; ῗ; ι◌̈◌͂; ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FD7 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FD7 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B9, 0x0308, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FD7 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B9, 0x0308, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_107)
{
    // 1FD8;1FD8;0399 0306;1FD8;0399 0306; 
    // (Ῐ; Ῐ; Ι◌̆; Ῐ; Ι◌̆; ) GREEK CAPITAL LETTER IOTA WITH VRACHY
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FD8 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FD8 }};
        std::array<char32_t, 2> const c3 = {{ 0x0399, 0x0306 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FD8 }};
        std::array<char32_t, 2> const c5 = {{ 0x0399, 0x0306 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_108)
{
    // 1FD9;1FD9;0399 0304;1FD9;0399 0304; 
    // (Ῑ; Ῑ; Ι◌̄; Ῑ; Ι◌̄; ) GREEK CAPITAL LETTER IOTA WITH MACRON
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FD9 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FD9 }};
        std::array<char32_t, 2> const c3 = {{ 0x0399, 0x0304 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FD9 }};
        std::array<char32_t, 2> const c5 = {{ 0x0399, 0x0304 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_109)
{
    // 1FDA;1FDA;0399 0300;1FDA;0399 0300; 
    // (Ὶ; Ὶ; Ι◌̀; Ὶ; Ι◌̀; ) GREEK CAPITAL LETTER IOTA WITH VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FDA }};
        std::array<char32_t, 1> const c2 = {{ 0x1FDA }};
        std::array<char32_t, 2> const c3 = {{ 0x0399, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FDA }};
        std::array<char32_t, 2> const c5 = {{ 0x0399, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_110)
{
    // 1FDB;038A;0399 0301;038A;0399 0301; 
    // (Ί; Ί; Ι◌́; Ί; Ι◌́; ) GREEK CAPITAL LETTER IOTA WITH OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FDB }};
        std::array<char32_t, 1> const c2 = {{ 0x038A }};
        std::array<char32_t, 2> const c3 = {{ 0x0399, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x038A }};
        std::array<char32_t, 2> const c5 = {{ 0x0399, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_111)
{
    // 1FDD;1FDD;1FFE 0300;0020 0314 0300;0020 0314 0300; 
    // (῝; ῝; ῾◌̀;  ◌̔◌̀;  ◌̔◌̀; ) GREEK DASIA AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FDD }};
        std::array<char32_t, 1> const c2 = {{ 0x1FDD }};
        std::array<char32_t, 2> const c3 = {{ 0x1FFE, 0x0300 }};
        std::array<char32_t, 3> const c4 = {{ 0x0020, 0x0314, 0x0300 }};
        std::array<char32_t, 3> const c5 = {{ 0x0020, 0x0314, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_112)
{
    // 1FDE;1FDE;1FFE 0301;0020 0314 0301;0020 0314 0301; 
    // (῞; ῞; ῾◌́;  ◌̔◌́;  ◌̔◌́; ) GREEK DASIA AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FDE }};
        std::array<char32_t, 1> const c2 = {{ 0x1FDE }};
        std::array<char32_t, 2> const c3 = {{ 0x1FFE, 0x0301 }};
        std::array<char32_t, 3> const c4 = {{ 0x0020, 0x0314, 0x0301 }};
        std::array<char32_t, 3> const c5 = {{ 0x0020, 0x0314, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_113)
{
    // 1FDF;1FDF;1FFE 0342;0020 0314 0342;0020 0314 0342; 
    // (῟; ῟; ῾◌͂;  ◌̔◌͂;  ◌̔◌͂; ) GREEK DASIA AND PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FDF }};
        std::array<char32_t, 1> const c2 = {{ 0x1FDF }};
        std::array<char32_t, 2> const c3 = {{ 0x1FFE, 0x0342 }};
        std::array<char32_t, 3> const c4 = {{ 0x0020, 0x0314, 0x0342 }};
        std::array<char32_t, 3> const c5 = {{ 0x0020, 0x0314, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_114)
{
    // 1FE0;1FE0;03C5 0306;1FE0;03C5 0306; 
    // (ῠ; ῠ; υ◌̆; ῠ; υ◌̆; ) GREEK SMALL LETTER UPSILON WITH VRACHY
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FE0 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FE0 }};
        std::array<char32_t, 2> const c3 = {{ 0x03C5, 0x0306 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FE0 }};
        std::array<char32_t, 2> const c5 = {{ 0x03C5, 0x0306 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_115)
{
    // 1FE1;1FE1;03C5 0304;1FE1;03C5 0304; 
    // (ῡ; ῡ; υ◌̄; ῡ; υ◌̄; ) GREEK SMALL LETTER UPSILON WITH MACRON
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FE1 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FE1 }};
        std::array<char32_t, 2> const c3 = {{ 0x03C5, 0x0304 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FE1 }};
        std::array<char32_t, 2> const c5 = {{ 0x03C5, 0x0304 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_116)
{
    // 1FE2;1FE2;03C5 0308 0300;1FE2;03C5 0308 0300; 
    // (ῢ; ῢ; υ◌̈◌̀; ῢ; υ◌̈◌̀; ) GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FE2 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FE2 }};
        std::array<char32_t, 3> const c3 = {{ 0x03C5, 0x0308, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FE2 }};
        std::array<char32_t, 3> const c5 = {{ 0x03C5, 0x0308, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_117)
{
    // 1FE3;03B0;03C5 0308 0301;03B0;03C5 0308 0301; 
    // (ΰ; ΰ; υ◌̈◌́; ΰ; υ◌̈◌́; ) GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FE3 }};
        std::array<char32_t, 1> const c2 = {{ 0x03B0 }};
        std::array<char32_t, 3> const c3 = {{ 0x03C5, 0x0308, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x03B0 }};
        std::array<char32_t, 3> const c5 = {{ 0x03C5, 0x0308, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_118)
{
    // 1FE4;1FE4;03C1 0313;1FE4;03C1 0313; 
    // (ῤ; ῤ; ρ◌̓; ῤ; ρ◌̓; ) GREEK SMALL LETTER RHO WITH PSILI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FE4 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FE4 }};
        std::array<char32_t, 2> const c3 = {{ 0x03C1, 0x0313 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FE4 }};
        std::array<char32_t, 2> const c5 = {{ 0x03C1, 0x0313 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_119)
{
    // 1FE5;1FE5;03C1 0314;1FE5;03C1 0314; 
    // (ῥ; ῥ; ρ◌̔; ῥ; ρ◌̔; ) GREEK SMALL LETTER RHO WITH DASIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FE5 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FE5 }};
        std::array<char32_t, 2> const c3 = {{ 0x03C1, 0x0314 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FE5 }};
        std::array<char32_t, 2> const c5 = {{ 0x03C1, 0x0314 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_120)
{
    // 1FE6;1FE6;03C5 0342;1FE6;03C5 0342; 
    // (ῦ; ῦ; υ◌͂; ῦ; υ◌͂; ) GREEK SMALL LETTER UPSILON WITH PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FE6 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FE6 }};
        std::array<char32_t, 2> const c3 = {{ 0x03C5, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FE6 }};
        std::array<char32_t, 2> const c5 = {{ 0x03C5, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_121)
{
    // 1FE7;1FE7;03C5 0308 0342;1FE7;03C5 0308 0342; 
    // (ῧ; ῧ; υ◌̈◌͂; ῧ; υ◌̈◌͂; ) GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FE7 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FE7 }};
        std::array<char32_t, 3> const c3 = {{ 0x03C5, 0x0308, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FE7 }};
        std::array<char32_t, 3> const c5 = {{ 0x03C5, 0x0308, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_122)
{
    // 1FE8;1FE8;03A5 0306;1FE8;03A5 0306; 
    // (Ῠ; Ῠ; Υ◌̆; Ῠ; Υ◌̆; ) GREEK CAPITAL LETTER UPSILON WITH VRACHY
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FE8 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FE8 }};
        std::array<char32_t, 2> const c3 = {{ 0x03A5, 0x0306 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FE8 }};
        std::array<char32_t, 2> const c5 = {{ 0x03A5, 0x0306 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_123)
{
    // 1FE9;1FE9;03A5 0304;1FE9;03A5 0304; 
    // (Ῡ; Ῡ; Υ◌̄; Ῡ; Υ◌̄; ) GREEK CAPITAL LETTER UPSILON WITH MACRON
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FE9 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FE9 }};
        std::array<char32_t, 2> const c3 = {{ 0x03A5, 0x0304 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FE9 }};
        std::array<char32_t, 2> const c5 = {{ 0x03A5, 0x0304 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_124)
{
    // 1FEA;1FEA;03A5 0300;1FEA;03A5 0300; 
    // (Ὺ; Ὺ; Υ◌̀; Ὺ; Υ◌̀; ) GREEK CAPITAL LETTER UPSILON WITH VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FEA }};
        std::array<char32_t, 1> const c2 = {{ 0x1FEA }};
        std::array<char32_t, 2> const c3 = {{ 0x03A5, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FEA }};
        std::array<char32_t, 2> const c5 = {{ 0x03A5, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_125)
{
    // 1FEB;038E;03A5 0301;038E;03A5 0301; 
    // (Ύ; Ύ; Υ◌́; Ύ; Υ◌́; ) GREEK CAPITAL LETTER UPSILON WITH OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FEB }};
        std::array<char32_t, 1> const c2 = {{ 0x038E }};
        std::array<char32_t, 2> const c3 = {{ 0x03A5, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x038E }};
        std::array<char32_t, 2> const c5 = {{ 0x03A5, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_126)
{
    // 1FEC;1FEC;03A1 0314;1FEC;03A1 0314; 
    // (Ῥ; Ῥ; Ρ◌̔; Ῥ; Ρ◌̔; ) GREEK CAPITAL LETTER RHO WITH DASIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FEC }};
        std::array<char32_t, 1> const c2 = {{ 0x1FEC }};
        std::array<char32_t, 2> const c3 = {{ 0x03A1, 0x0314 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FEC }};
        std::array<char32_t, 2> const c5 = {{ 0x03A1, 0x0314 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_127)
{
    // 1FED;1FED;00A8 0300;0020 0308 0300;0020 0308 0300; 
    // (῭; ῭; ¨◌̀;  ◌̈◌̀;  ◌̈◌̀; ) GREEK DIALYTIKA AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FED }};
        std::array<char32_t, 1> const c2 = {{ 0x1FED }};
        std::array<char32_t, 2> const c3 = {{ 0x00A8, 0x0300 }};
        std::array<char32_t, 3> const c4 = {{ 0x0020, 0x0308, 0x0300 }};
        std::array<char32_t, 3> const c5 = {{ 0x0020, 0x0308, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_128)
{
    // 1FEE;0385;00A8 0301;0020 0308 0301;0020 0308 0301; 
    // (΅; ΅; ¨◌́;  ◌̈◌́;  ◌̈◌́; ) GREEK DIALYTIKA AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FEE }};
        std::array<char32_t, 1> const c2 = {{ 0x0385 }};
        std::array<char32_t, 2> const c3 = {{ 0x00A8, 0x0301 }};
        std::array<char32_t, 3> const c4 = {{ 0x0020, 0x0308, 0x0301 }};
        std::array<char32_t, 3> const c5 = {{ 0x0020, 0x0308, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_129)
{
    // 1FEF;0060;0060;0060;0060; 
    // (`; `; `; `; `; ) GREEK VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FEF }};
        std::array<char32_t, 1> const c2 = {{ 0x0060 }};
        std::array<char32_t, 1> const c3 = {{ 0x0060 }};
        std::array<char32_t, 1> const c4 = {{ 0x0060 }};
        std::array<char32_t, 1> const c5 = {{ 0x0060 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_130)
{
    // 1FF2;1FF2;03C9 0300 0345;1FF2;03C9 0300 0345; 
    // (ῲ; ῲ; ω◌̀◌ͅ; ῲ; ω◌̀◌ͅ; ) GREEK SMALL LETTER OMEGA WITH VARIA AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FF2 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FF2 }};
        std::array<char32_t, 3> const c3 = {{ 0x03C9, 0x0300, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FF2 }};
        std::array<char32_t, 3> const c5 = {{ 0x03C9, 0x0300, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_131)
{
    // 1FF3;1FF3;03C9 0345;1FF3;03C9 0345; 
    // (ῳ; ῳ; ω◌ͅ; ῳ; ω◌ͅ; ) GREEK SMALL LETTER OMEGA WITH YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FF3 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FF3 }};
        std::array<char32_t, 2> const c3 = {{ 0x03C9, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FF3 }};
        std::array<char32_t, 2> const c5 = {{ 0x03C9, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_132)
{
    // 1FF4;1FF4;03C9 0301 0345;1FF4;03C9 0301 0345; 
    // (ῴ; ῴ; ω◌́◌ͅ; ῴ; ω◌́◌ͅ; ) GREEK SMALL LETTER OMEGA WITH OXIA AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FF4 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FF4 }};
        std::array<char32_t, 3> const c3 = {{ 0x03C9, 0x0301, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FF4 }};
        std::array<char32_t, 3> const c5 = {{ 0x03C9, 0x0301, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_133)
{
    // 1FF6;1FF6;03C9 0342;1FF6;03C9 0342; 
    // (ῶ; ῶ; ω◌͂; ῶ; ω◌͂; ) GREEK SMALL LETTER OMEGA WITH PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FF6 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FF6 }};
        std::array<char32_t, 2> const c3 = {{ 0x03C9, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FF6 }};
        std::array<char32_t, 2> const c5 = {{ 0x03C9, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_134)
{
    // 1FF7;1FF7;03C9 0342 0345;1FF7;03C9 0342 0345; 
    // (ῷ; ῷ; ω◌͂◌ͅ; ῷ; ω◌͂◌ͅ; ) GREEK SMALL LETTER OMEGA WITH PERISPOMENI AND YPOGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FF7 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FF7 }};
        std::array<char32_t, 3> const c3 = {{ 0x03C9, 0x0342, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FF7 }};
        std::array<char32_t, 3> const c5 = {{ 0x03C9, 0x0342, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_135)
{
    // 1FF8;1FF8;039F 0300;1FF8;039F 0300; 
    // (Ὸ; Ὸ; Ο◌̀; Ὸ; Ο◌̀; ) GREEK CAPITAL LETTER OMICRON WITH VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FF8 }};
        std::array<char32_t, 1> const c2 = {{ 0x1FF8 }};
        std::array<char32_t, 2> const c3 = {{ 0x039F, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FF8 }};
        std::array<char32_t, 2> const c5 = {{ 0x039F, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_136)
{
    // 1FF9;038C;039F 0301;038C;039F 0301; 
    // (Ό; Ό; Ο◌́; Ό; Ο◌́; ) GREEK CAPITAL LETTER OMICRON WITH OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FF9 }};
        std::array<char32_t, 1> const c2 = {{ 0x038C }};
        std::array<char32_t, 2> const c3 = {{ 0x039F, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x038C }};
        std::array<char32_t, 2> const c5 = {{ 0x039F, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_137)
{
    // 1FFA;1FFA;03A9 0300;1FFA;03A9 0300; 
    // (Ὼ; Ὼ; Ω◌̀; Ὼ; Ω◌̀; ) GREEK CAPITAL LETTER OMEGA WITH VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FFA }};
        std::array<char32_t, 1> const c2 = {{ 0x1FFA }};
        std::array<char32_t, 2> const c3 = {{ 0x03A9, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FFA }};
        std::array<char32_t, 2> const c5 = {{ 0x03A9, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_138)
{
    // 1FFB;038F;03A9 0301;038F;03A9 0301; 
    // (Ώ; Ώ; Ω◌́; Ώ; Ω◌́; ) GREEK CAPITAL LETTER OMEGA WITH OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FFB }};
        std::array<char32_t, 1> const c2 = {{ 0x038F }};
        std::array<char32_t, 2> const c3 = {{ 0x03A9, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x038F }};
        std::array<char32_t, 2> const c5 = {{ 0x03A9, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_139)
{
    // 1FFC;1FFC;03A9 0345;1FFC;03A9 0345; 
    // (ῼ; ῼ; Ω◌ͅ; ῼ; Ω◌ͅ; ) GREEK CAPITAL LETTER OMEGA WITH PROSGEGRAMMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FFC }};
        std::array<char32_t, 1> const c2 = {{ 0x1FFC }};
        std::array<char32_t, 2> const c3 = {{ 0x03A9, 0x0345 }};
        std::array<char32_t, 1> const c4 = {{ 0x1FFC }};
        std::array<char32_t, 2> const c5 = {{ 0x03A9, 0x0345 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_140)
{
    // 1FFD;00B4;00B4;0020 0301;0020 0301; 
    // (´; ´; ´;  ◌́;  ◌́; ) GREEK OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FFD }};
        std::array<char32_t, 1> const c2 = {{ 0x00B4 }};
        std::array<char32_t, 1> const c3 = {{ 0x00B4 }};
        std::array<char32_t, 2> const c4 = {{ 0x0020, 0x0301 }};
        std::array<char32_t, 2> const c5 = {{ 0x0020, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_141)
{
    // 1FFE;1FFE;1FFE;0020 0314;0020 0314; 
    // (῾; ῾; ῾;  ◌̔;  ◌̔; ) GREEK DASIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1FFE }};
        std::array<char32_t, 1> const c2 = {{ 0x1FFE }};
        std::array<char32_t, 1> const c3 = {{ 0x1FFE }};
        std::array<char32_t, 2> const c4 = {{ 0x0020, 0x0314 }};
        std::array<char32_t, 2> const c5 = {{ 0x0020, 0x0314 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_142)
{
    // 2000;2002;2002;0020;0020; 
    // ( ;  ;  ;  ;  ; ) EN QUAD
    {
        std::array<char32_t, 1> const c1 = {{ 0x2000 }};
        std::array<char32_t, 1> const c2 = {{ 0x2002 }};
        std::array<char32_t, 1> const c3 = {{ 0x2002 }};
        std::array<char32_t, 1> const c4 = {{ 0x0020 }};
        std::array<char32_t, 1> const c5 = {{ 0x0020 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_143)
{
    // 2001;2003;2003;0020;0020; 
    // ( ;  ;  ;  ;  ; ) EM QUAD
    {
        std::array<char32_t, 1> const c1 = {{ 0x2001 }};
        std::array<char32_t, 1> const c2 = {{ 0x2003 }};
        std::array<char32_t, 1> const c3 = {{ 0x2003 }};
        std::array<char32_t, 1> const c4 = {{ 0x0020 }};
        std::array<char32_t, 1> const c5 = {{ 0x0020 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_144)
{
    // 2002;2002;2002;0020;0020; 
    // ( ;  ;  ;  ;  ; ) EN SPACE
    {
        std::array<char32_t, 1> const c1 = {{ 0x2002 }};
        std::array<char32_t, 1> const c2 = {{ 0x2002 }};
        std::array<char32_t, 1> const c3 = {{ 0x2002 }};
        std::array<char32_t, 1> const c4 = {{ 0x0020 }};
        std::array<char32_t, 1> const c5 = {{ 0x0020 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_145)
{
    // 2003;2003;2003;0020;0020; 
    // ( ;  ;  ;  ;  ; ) EM SPACE
    {
        std::array<char32_t, 1> const c1 = {{ 0x2003 }};
        std::array<char32_t, 1> const c2 = {{ 0x2003 }};
        std::array<char32_t, 1> const c3 = {{ 0x2003 }};
        std::array<char32_t, 1> const c4 = {{ 0x0020 }};
        std::array<char32_t, 1> const c5 = {{ 0x0020 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_146)
{
    // 2004;2004;2004;0020;0020; 
    // ( ;  ;  ;  ;  ; ) THREE-PER-EM SPACE
    {
        std::array<char32_t, 1> const c1 = {{ 0x2004 }};
        std::array<char32_t, 1> const c2 = {{ 0x2004 }};
        std::array<char32_t, 1> const c3 = {{ 0x2004 }};
        std::array<char32_t, 1> const c4 = {{ 0x0020 }};
        std::array<char32_t, 1> const c5 = {{ 0x0020 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_147)
{
    // 2005;2005;2005;0020;0020; 
    // ( ;  ;  ;  ;  ; ) FOUR-PER-EM SPACE
    {
        std::array<char32_t, 1> const c1 = {{ 0x2005 }};
        std::array<char32_t, 1> const c2 = {{ 0x2005 }};
        std::array<char32_t, 1> const c3 = {{ 0x2005 }};
        std::array<char32_t, 1> const c4 = {{ 0x0020 }};
        std::array<char32_t, 1> const c5 = {{ 0x0020 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_148)
{
    // 2006;2006;2006;0020;0020; 
    // ( ;  ;  ;  ;  ; ) SIX-PER-EM SPACE
    {
        std::array<char32_t, 1> const c1 = {{ 0x2006 }};
        std::array<char32_t, 1> const c2 = {{ 0x2006 }};
        std::array<char32_t, 1> const c3 = {{ 0x2006 }};
        std::array<char32_t, 1> const c4 = {{ 0x0020 }};
        std::array<char32_t, 1> const c5 = {{ 0x0020 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_149)
{
    // 2007;2007;2007;0020;0020; 
    // ( ;  ;  ;  ;  ; ) FIGURE SPACE
    {
        std::array<char32_t, 1> const c1 = {{ 0x2007 }};
        std::array<char32_t, 1> const c2 = {{ 0x2007 }};
        std::array<char32_t, 1> const c3 = {{ 0x2007 }};
        std::array<char32_t, 1> const c4 = {{ 0x0020 }};
        std::array<char32_t, 1> const c5 = {{ 0x0020 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_150)
{
    // 2008;2008;2008;0020;0020; 
    // ( ;  ;  ;  ;  ; ) PUNCTUATION SPACE
    {
        std::array<char32_t, 1> const c1 = {{ 0x2008 }};
        std::array<char32_t, 1> const c2 = {{ 0x2008 }};
        std::array<char32_t, 1> const c3 = {{ 0x2008 }};
        std::array<char32_t, 1> const c4 = {{ 0x0020 }};
        std::array<char32_t, 1> const c5 = {{ 0x0020 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_151)
{
    // 2009;2009;2009;0020;0020; 
    // ( ;  ;  ;  ;  ; ) THIN SPACE
    {
        std::array<char32_t, 1> const c1 = {{ 0x2009 }};
        std::array<char32_t, 1> const c2 = {{ 0x2009 }};
        std::array<char32_t, 1> const c3 = {{ 0x2009 }};
        std::array<char32_t, 1> const c4 = {{ 0x0020 }};
        std::array<char32_t, 1> const c5 = {{ 0x0020 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_152)
{
    // 200A;200A;200A;0020;0020; 
    // ( ;  ;  ;  ;  ; ) HAIR SPACE
    {
        std::array<char32_t, 1> const c1 = {{ 0x200A }};
        std::array<char32_t, 1> const c2 = {{ 0x200A }};
        std::array<char32_t, 1> const c3 = {{ 0x200A }};
        std::array<char32_t, 1> const c4 = {{ 0x0020 }};
        std::array<char32_t, 1> const c5 = {{ 0x0020 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_153)
{
    // 2011;2011;2011;2010;2010; 
    // (‑; ‑; ‑; ‐; ‐; ) NON-BREAKING HYPHEN
    {
        std::array<char32_t, 1> const c1 = {{ 0x2011 }};
        std::array<char32_t, 1> const c2 = {{ 0x2011 }};
        std::array<char32_t, 1> const c3 = {{ 0x2011 }};
        std::array<char32_t, 1> const c4 = {{ 0x2010 }};
        std::array<char32_t, 1> const c5 = {{ 0x2010 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_154)
{
    // 2017;2017;2017;0020 0333;0020 0333; 
    // (‗; ‗; ‗;  ◌̳;  ◌̳; ) DOUBLE LOW LINE
    {
        std::array<char32_t, 1> const c1 = {{ 0x2017 }};
        std::array<char32_t, 1> const c2 = {{ 0x2017 }};
        std::array<char32_t, 1> const c3 = {{ 0x2017 }};
        std::array<char32_t, 2> const c4 = {{ 0x0020, 0x0333 }};
        std::array<char32_t, 2> const c5 = {{ 0x0020, 0x0333 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_155)
{
    // 2024;2024;2024;002E;002E; 
    // (․; ․; ․; .; .; ) ONE DOT LEADER
    {
        std::array<char32_t, 1> const c1 = {{ 0x2024 }};
        std::array<char32_t, 1> const c2 = {{ 0x2024 }};
        std::array<char32_t, 1> const c3 = {{ 0x2024 }};
        std::array<char32_t, 1> const c4 = {{ 0x002E }};
        std::array<char32_t, 1> const c5 = {{ 0x002E }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_156)
{
    // 2025;2025;2025;002E 002E;002E 002E; 
    // (‥; ‥; ‥; ..; ..; ) TWO DOT LEADER
    {
        std::array<char32_t, 1> const c1 = {{ 0x2025 }};
        std::array<char32_t, 1> const c2 = {{ 0x2025 }};
        std::array<char32_t, 1> const c3 = {{ 0x2025 }};
        std::array<char32_t, 2> const c4 = {{ 0x002E, 0x002E }};
        std::array<char32_t, 2> const c5 = {{ 0x002E, 0x002E }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_157)
{
    // 2026;2026;2026;002E 002E 002E;002E 002E 002E; 
    // (…; …; …; ...; ...; ) HORIZONTAL ELLIPSIS
    {
        std::array<char32_t, 1> const c1 = {{ 0x2026 }};
        std::array<char32_t, 1> const c2 = {{ 0x2026 }};
        std::array<char32_t, 1> const c3 = {{ 0x2026 }};
        std::array<char32_t, 3> const c4 = {{ 0x002E, 0x002E, 0x002E }};
        std::array<char32_t, 3> const c5 = {{ 0x002E, 0x002E, 0x002E }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_158)
{
    // 202F;202F;202F;0020;0020; 
    // ( ;  ;  ;  ;  ; ) NARROW NO-BREAK SPACE
    {
        std::array<char32_t, 1> const c1 = {{ 0x202F }};
        std::array<char32_t, 1> const c2 = {{ 0x202F }};
        std::array<char32_t, 1> const c3 = {{ 0x202F }};
        std::array<char32_t, 1> const c4 = {{ 0x0020 }};
        std::array<char32_t, 1> const c5 = {{ 0x0020 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_159)
{
    // 2033;2033;2033;2032 2032;2032 2032; 
    // (″; ″; ″; ′′; ′′; ) DOUBLE PRIME
    {
        std::array<char32_t, 1> const c1 = {{ 0x2033 }};
        std::array<char32_t, 1> const c2 = {{ 0x2033 }};
        std::array<char32_t, 1> const c3 = {{ 0x2033 }};
        std::array<char32_t, 2> const c4 = {{ 0x2032, 0x2032 }};
        std::array<char32_t, 2> const c5 = {{ 0x2032, 0x2032 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_160)
{
    // 2034;2034;2034;2032 2032 2032;2032 2032 2032; 
    // (‴; ‴; ‴; ′′′; ′′′; ) TRIPLE PRIME
    {
        std::array<char32_t, 1> const c1 = {{ 0x2034 }};
        std::array<char32_t, 1> const c2 = {{ 0x2034 }};
        std::array<char32_t, 1> const c3 = {{ 0x2034 }};
        std::array<char32_t, 3> const c4 = {{ 0x2032, 0x2032, 0x2032 }};
        std::array<char32_t, 3> const c5 = {{ 0x2032, 0x2032, 0x2032 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_161)
{
    // 2036;2036;2036;2035 2035;2035 2035; 
    // (‶; ‶; ‶; ‵‵; ‵‵; ) REVERSED DOUBLE PRIME
    {
        std::array<char32_t, 1> const c1 = {{ 0x2036 }};
        std::array<char32_t, 1> const c2 = {{ 0x2036 }};
        std::array<char32_t, 1> const c3 = {{ 0x2036 }};
        std::array<char32_t, 2> const c4 = {{ 0x2035, 0x2035 }};
        std::array<char32_t, 2> const c5 = {{ 0x2035, 0x2035 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_162)
{
    // 2037;2037;2037;2035 2035 2035;2035 2035 2035; 
    // (‷; ‷; ‷; ‵‵‵; ‵‵‵; ) REVERSED TRIPLE PRIME
    {
        std::array<char32_t, 1> const c1 = {{ 0x2037 }};
        std::array<char32_t, 1> const c2 = {{ 0x2037 }};
        std::array<char32_t, 1> const c3 = {{ 0x2037 }};
        std::array<char32_t, 3> const c4 = {{ 0x2035, 0x2035, 0x2035 }};
        std::array<char32_t, 3> const c5 = {{ 0x2035, 0x2035, 0x2035 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_163)
{
    // 203C;203C;203C;0021 0021;0021 0021; 
    // (‼; ‼; ‼; !!; !!; ) DOUBLE EXCLAMATION MARK
    {
        std::array<char32_t, 1> const c1 = {{ 0x203C }};
        std::array<char32_t, 1> const c2 = {{ 0x203C }};
        std::array<char32_t, 1> const c3 = {{ 0x203C }};
        std::array<char32_t, 2> const c4 = {{ 0x0021, 0x0021 }};
        std::array<char32_t, 2> const c5 = {{ 0x0021, 0x0021 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_164)
{
    // 203E;203E;203E;0020 0305;0020 0305; 
    // (‾; ‾; ‾;  ◌̅;  ◌̅; ) OVERLINE
    {
        std::array<char32_t, 1> const c1 = {{ 0x203E }};
        std::array<char32_t, 1> const c2 = {{ 0x203E }};
        std::array<char32_t, 1> const c3 = {{ 0x203E }};
        std::array<char32_t, 2> const c4 = {{ 0x0020, 0x0305 }};
        std::array<char32_t, 2> const c5 = {{ 0x0020, 0x0305 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_165)
{
    // 2047;2047;2047;003F 003F;003F 003F; 
    // (⁇; ⁇; ⁇; ??; ??; ) DOUBLE QUESTION MARK
    {
        std::array<char32_t, 1> const c1 = {{ 0x2047 }};
        std::array<char32_t, 1> const c2 = {{ 0x2047 }};
        std::array<char32_t, 1> const c3 = {{ 0x2047 }};
        std::array<char32_t, 2> const c4 = {{ 0x003F, 0x003F }};
        std::array<char32_t, 2> const c5 = {{ 0x003F, 0x003F }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_166)
{
    // 2048;2048;2048;003F 0021;003F 0021; 
    // (⁈; ⁈; ⁈; ?!; ?!; ) QUESTION EXCLAMATION MARK
    {
        std::array<char32_t, 1> const c1 = {{ 0x2048 }};
        std::array<char32_t, 1> const c2 = {{ 0x2048 }};
        std::array<char32_t, 1> const c3 = {{ 0x2048 }};
        std::array<char32_t, 2> const c4 = {{ 0x003F, 0x0021 }};
        std::array<char32_t, 2> const c5 = {{ 0x003F, 0x0021 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_167)
{
    // 2049;2049;2049;0021 003F;0021 003F; 
    // (⁉; ⁉; ⁉; !?; !?; ) EXCLAMATION QUESTION MARK
    {
        std::array<char32_t, 1> const c1 = {{ 0x2049 }};
        std::array<char32_t, 1> const c2 = {{ 0x2049 }};
        std::array<char32_t, 1> const c3 = {{ 0x2049 }};
        std::array<char32_t, 2> const c4 = {{ 0x0021, 0x003F }};
        std::array<char32_t, 2> const c5 = {{ 0x0021, 0x003F }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_168)
{
    // 2057;2057;2057;2032 2032 2032 2032;2032 2032 2032 2032; 
    // (⁗; ⁗; ⁗; ′′′′; ′′′′; ) QUADRUPLE PRIME
    {
        std::array<char32_t, 1> const c1 = {{ 0x2057 }};
        std::array<char32_t, 1> const c2 = {{ 0x2057 }};
        std::array<char32_t, 1> const c3 = {{ 0x2057 }};
        std::array<char32_t, 4> const c4 = {{ 0x2032, 0x2032, 0x2032, 0x2032 }};
        std::array<char32_t, 4> const c5 = {{ 0x2032, 0x2032, 0x2032, 0x2032 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_169)
{
    // 205F;205F;205F;0020;0020; 
    // ( ;  ;  ;  ;  ; ) MEDIUM MATHEMATICAL SPACE
    {
        std::array<char32_t, 1> const c1 = {{ 0x205F }};
        std::array<char32_t, 1> const c2 = {{ 0x205F }};
        std::array<char32_t, 1> const c3 = {{ 0x205F }};
        std::array<char32_t, 1> const c4 = {{ 0x0020 }};
        std::array<char32_t, 1> const c5 = {{ 0x0020 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_170)
{
    // 2070;2070;2070;0030;0030; 
    // (⁰; ⁰; ⁰; 0; 0; ) SUPERSCRIPT ZERO
    {
        std::array<char32_t, 1> const c1 = {{ 0x2070 }};
        std::array<char32_t, 1> const c2 = {{ 0x2070 }};
        std::array<char32_t, 1> const c3 = {{ 0x2070 }};
        std::array<char32_t, 1> const c4 = {{ 0x0030 }};
        std::array<char32_t, 1> const c5 = {{ 0x0030 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_171)
{
    // 2071;2071;2071;0069;0069; 
    // (ⁱ; ⁱ; ⁱ; i; i; ) SUPERSCRIPT LATIN SMALL LETTER I
    {
        std::array<char32_t, 1> const c1 = {{ 0x2071 }};
        std::array<char32_t, 1> const c2 = {{ 0x2071 }};
        std::array<char32_t, 1> const c3 = {{ 0x2071 }};
        std::array<char32_t, 1> const c4 = {{ 0x0069 }};
        std::array<char32_t, 1> const c5 = {{ 0x0069 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_172)
{
    // 2074;2074;2074;0034;0034; 
    // (⁴; ⁴; ⁴; 4; 4; ) SUPERSCRIPT FOUR
    {
        std::array<char32_t, 1> const c1 = {{ 0x2074 }};
        std::array<char32_t, 1> const c2 = {{ 0x2074 }};
        std::array<char32_t, 1> const c3 = {{ 0x2074 }};
        std::array<char32_t, 1> const c4 = {{ 0x0034 }};
        std::array<char32_t, 1> const c5 = {{ 0x0034 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_173)
{
    // 2075;2075;2075;0035;0035; 
    // (⁵; ⁵; ⁵; 5; 5; ) SUPERSCRIPT FIVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x2075 }};
        std::array<char32_t, 1> const c2 = {{ 0x2075 }};
        std::array<char32_t, 1> const c3 = {{ 0x2075 }};
        std::array<char32_t, 1> const c4 = {{ 0x0035 }};
        std::array<char32_t, 1> const c5 = {{ 0x0035 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_174)
{
    // 2076;2076;2076;0036;0036; 
    // (⁶; ⁶; ⁶; 6; 6; ) SUPERSCRIPT SIX
    {
        std::array<char32_t, 1> const c1 = {{ 0x2076 }};
        std::array<char32_t, 1> const c2 = {{ 0x2076 }};
        std::array<char32_t, 1> const c3 = {{ 0x2076 }};
        std::array<char32_t, 1> const c4 = {{ 0x0036 }};
        std::array<char32_t, 1> const c5 = {{ 0x0036 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_175)
{
    // 2077;2077;2077;0037;0037; 
    // (⁷; ⁷; ⁷; 7; 7; ) SUPERSCRIPT SEVEN
    {
        std::array<char32_t, 1> const c1 = {{ 0x2077 }};
        std::array<char32_t, 1> const c2 = {{ 0x2077 }};
        std::array<char32_t, 1> const c3 = {{ 0x2077 }};
        std::array<char32_t, 1> const c4 = {{ 0x0037 }};
        std::array<char32_t, 1> const c5 = {{ 0x0037 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_176)
{
    // 2078;2078;2078;0038;0038; 
    // (⁸; ⁸; ⁸; 8; 8; ) SUPERSCRIPT EIGHT
    {
        std::array<char32_t, 1> const c1 = {{ 0x2078 }};
        std::array<char32_t, 1> const c2 = {{ 0x2078 }};
        std::array<char32_t, 1> const c3 = {{ 0x2078 }};
        std::array<char32_t, 1> const c4 = {{ 0x0038 }};
        std::array<char32_t, 1> const c5 = {{ 0x0038 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_177)
{
    // 2079;2079;2079;0039;0039; 
    // (⁹; ⁹; ⁹; 9; 9; ) SUPERSCRIPT NINE
    {
        std::array<char32_t, 1> const c1 = {{ 0x2079 }};
        std::array<char32_t, 1> const c2 = {{ 0x2079 }};
        std::array<char32_t, 1> const c3 = {{ 0x2079 }};
        std::array<char32_t, 1> const c4 = {{ 0x0039 }};
        std::array<char32_t, 1> const c5 = {{ 0x0039 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_178)
{
    // 207A;207A;207A;002B;002B; 
    // (⁺; ⁺; ⁺; +; +; ) SUPERSCRIPT PLUS SIGN
    {
        std::array<char32_t, 1> const c1 = {{ 0x207A }};
        std::array<char32_t, 1> const c2 = {{ 0x207A }};
        std::array<char32_t, 1> const c3 = {{ 0x207A }};
        std::array<char32_t, 1> const c4 = {{ 0x002B }};
        std::array<char32_t, 1> const c5 = {{ 0x002B }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_179)
{
    // 207B;207B;207B;2212;2212; 
    // (⁻; ⁻; ⁻; −; −; ) SUPERSCRIPT MINUS
    {
        std::array<char32_t, 1> const c1 = {{ 0x207B }};
        std::array<char32_t, 1> const c2 = {{ 0x207B }};
        std::array<char32_t, 1> const c3 = {{ 0x207B }};
        std::array<char32_t, 1> const c4 = {{ 0x2212 }};
        std::array<char32_t, 1> const c5 = {{ 0x2212 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_180)
{
    // 207C;207C;207C;003D;003D; 
    // (⁼; ⁼; ⁼; =; =; ) SUPERSCRIPT EQUALS SIGN
    {
        std::array<char32_t, 1> const c1 = {{ 0x207C }};
        std::array<char32_t, 1> const c2 = {{ 0x207C }};
        std::array<char32_t, 1> const c3 = {{ 0x207C }};
        std::array<char32_t, 1> const c4 = {{ 0x003D }};
        std::array<char32_t, 1> const c5 = {{ 0x003D }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_181)
{
    // 207D;207D;207D;0028;0028; 
    // (⁽; ⁽; ⁽; (; (; ) SUPERSCRIPT LEFT PARENTHESIS
    {
        std::array<char32_t, 1> const c1 = {{ 0x207D }};
        std::array<char32_t, 1> const c2 = {{ 0x207D }};
        std::array<char32_t, 1> const c3 = {{ 0x207D }};
        std::array<char32_t, 1> const c4 = {{ 0x0028 }};
        std::array<char32_t, 1> const c5 = {{ 0x0028 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_182)
{
    // 207E;207E;207E;0029;0029; 
    // (⁾; ⁾; ⁾; ); ); ) SUPERSCRIPT RIGHT PARENTHESIS
    {
        std::array<char32_t, 1> const c1 = {{ 0x207E }};
        std::array<char32_t, 1> const c2 = {{ 0x207E }};
        std::array<char32_t, 1> const c3 = {{ 0x207E }};
        std::array<char32_t, 1> const c4 = {{ 0x0029 }};
        std::array<char32_t, 1> const c5 = {{ 0x0029 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_183)
{
    // 207F;207F;207F;006E;006E; 
    // (ⁿ; ⁿ; ⁿ; n; n; ) SUPERSCRIPT LATIN SMALL LETTER N
    {
        std::array<char32_t, 1> const c1 = {{ 0x207F }};
        std::array<char32_t, 1> const c2 = {{ 0x207F }};
        std::array<char32_t, 1> const c3 = {{ 0x207F }};
        std::array<char32_t, 1> const c4 = {{ 0x006E }};
        std::array<char32_t, 1> const c5 = {{ 0x006E }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_184)
{
    // 2080;2080;2080;0030;0030; 
    // (₀; ₀; ₀; 0; 0; ) SUBSCRIPT ZERO
    {
        std::array<char32_t, 1> const c1 = {{ 0x2080 }};
        std::array<char32_t, 1> const c2 = {{ 0x2080 }};
        std::array<char32_t, 1> const c3 = {{ 0x2080 }};
        std::array<char32_t, 1> const c4 = {{ 0x0030 }};
        std::array<char32_t, 1> const c5 = {{ 0x0030 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_185)
{
    // 2081;2081;2081;0031;0031; 
    // (₁; ₁; ₁; 1; 1; ) SUBSCRIPT ONE
    {
        std::array<char32_t, 1> const c1 = {{ 0x2081 }};
        std::array<char32_t, 1> const c2 = {{ 0x2081 }};
        std::array<char32_t, 1> const c3 = {{ 0x2081 }};
        std::array<char32_t, 1> const c4 = {{ 0x0031 }};
        std::array<char32_t, 1> const c5 = {{ 0x0031 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_186)
{
    // 2082;2082;2082;0032;0032; 
    // (₂; ₂; ₂; 2; 2; ) SUBSCRIPT TWO
    {
        std::array<char32_t, 1> const c1 = {{ 0x2082 }};
        std::array<char32_t, 1> const c2 = {{ 0x2082 }};
        std::array<char32_t, 1> const c3 = {{ 0x2082 }};
        std::array<char32_t, 1> const c4 = {{ 0x0032 }};
        std::array<char32_t, 1> const c5 = {{ 0x0032 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_187)
{
    // 2083;2083;2083;0033;0033; 
    // (₃; ₃; ₃; 3; 3; ) SUBSCRIPT THREE
    {
        std::array<char32_t, 1> const c1 = {{ 0x2083 }};
        std::array<char32_t, 1> const c2 = {{ 0x2083 }};
        std::array<char32_t, 1> const c3 = {{ 0x2083 }};
        std::array<char32_t, 1> const c4 = {{ 0x0033 }};
        std::array<char32_t, 1> const c5 = {{ 0x0033 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_188)
{
    // 2084;2084;2084;0034;0034; 
    // (₄; ₄; ₄; 4; 4; ) SUBSCRIPT FOUR
    {
        std::array<char32_t, 1> const c1 = {{ 0x2084 }};
        std::array<char32_t, 1> const c2 = {{ 0x2084 }};
        std::array<char32_t, 1> const c3 = {{ 0x2084 }};
        std::array<char32_t, 1> const c4 = {{ 0x0034 }};
        std::array<char32_t, 1> const c5 = {{ 0x0034 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_189)
{
    // 2085;2085;2085;0035;0035; 
    // (₅; ₅; ₅; 5; 5; ) SUBSCRIPT FIVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x2085 }};
        std::array<char32_t, 1> const c2 = {{ 0x2085 }};
        std::array<char32_t, 1> const c3 = {{ 0x2085 }};
        std::array<char32_t, 1> const c4 = {{ 0x0035 }};
        std::array<char32_t, 1> const c5 = {{ 0x0035 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_190)
{
    // 2086;2086;2086;0036;0036; 
    // (₆; ₆; ₆; 6; 6; ) SUBSCRIPT SIX
    {
        std::array<char32_t, 1> const c1 = {{ 0x2086 }};
        std::array<char32_t, 1> const c2 = {{ 0x2086 }};
        std::array<char32_t, 1> const c3 = {{ 0x2086 }};
        std::array<char32_t, 1> const c4 = {{ 0x0036 }};
        std::array<char32_t, 1> const c5 = {{ 0x0036 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_191)
{
    // 2087;2087;2087;0037;0037; 
    // (₇; ₇; ₇; 7; 7; ) SUBSCRIPT SEVEN
    {
        std::array<char32_t, 1> const c1 = {{ 0x2087 }};
        std::array<char32_t, 1> const c2 = {{ 0x2087 }};
        std::array<char32_t, 1> const c3 = {{ 0x2087 }};
        std::array<char32_t, 1> const c4 = {{ 0x0037 }};
        std::array<char32_t, 1> const c5 = {{ 0x0037 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_192)
{
    // 2088;2088;2088;0038;0038; 
    // (₈; ₈; ₈; 8; 8; ) SUBSCRIPT EIGHT
    {
        std::array<char32_t, 1> const c1 = {{ 0x2088 }};
        std::array<char32_t, 1> const c2 = {{ 0x2088 }};
        std::array<char32_t, 1> const c3 = {{ 0x2088 }};
        std::array<char32_t, 1> const c4 = {{ 0x0038 }};
        std::array<char32_t, 1> const c5 = {{ 0x0038 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_193)
{
    // 2089;2089;2089;0039;0039; 
    // (₉; ₉; ₉; 9; 9; ) SUBSCRIPT NINE
    {
        std::array<char32_t, 1> const c1 = {{ 0x2089 }};
        std::array<char32_t, 1> const c2 = {{ 0x2089 }};
        std::array<char32_t, 1> const c3 = {{ 0x2089 }};
        std::array<char32_t, 1> const c4 = {{ 0x0039 }};
        std::array<char32_t, 1> const c5 = {{ 0x0039 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_194)
{
    // 208A;208A;208A;002B;002B; 
    // (₊; ₊; ₊; +; +; ) SUBSCRIPT PLUS SIGN
    {
        std::array<char32_t, 1> const c1 = {{ 0x208A }};
        std::array<char32_t, 1> const c2 = {{ 0x208A }};
        std::array<char32_t, 1> const c3 = {{ 0x208A }};
        std::array<char32_t, 1> const c4 = {{ 0x002B }};
        std::array<char32_t, 1> const c5 = {{ 0x002B }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_195)
{
    // 208B;208B;208B;2212;2212; 
    // (₋; ₋; ₋; −; −; ) SUBSCRIPT MINUS
    {
        std::array<char32_t, 1> const c1 = {{ 0x208B }};
        std::array<char32_t, 1> const c2 = {{ 0x208B }};
        std::array<char32_t, 1> const c3 = {{ 0x208B }};
        std::array<char32_t, 1> const c4 = {{ 0x2212 }};
        std::array<char32_t, 1> const c5 = {{ 0x2212 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_196)
{
    // 208C;208C;208C;003D;003D; 
    // (₌; ₌; ₌; =; =; ) SUBSCRIPT EQUALS SIGN
    {
        std::array<char32_t, 1> const c1 = {{ 0x208C }};
        std::array<char32_t, 1> const c2 = {{ 0x208C }};
        std::array<char32_t, 1> const c3 = {{ 0x208C }};
        std::array<char32_t, 1> const c4 = {{ 0x003D }};
        std::array<char32_t, 1> const c5 = {{ 0x003D }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_197)
{
    // 208D;208D;208D;0028;0028; 
    // (₍; ₍; ₍; (; (; ) SUBSCRIPT LEFT PARENTHESIS
    {
        std::array<char32_t, 1> const c1 = {{ 0x208D }};
        std::array<char32_t, 1> const c2 = {{ 0x208D }};
        std::array<char32_t, 1> const c3 = {{ 0x208D }};
        std::array<char32_t, 1> const c4 = {{ 0x0028 }};
        std::array<char32_t, 1> const c5 = {{ 0x0028 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_198)
{
    // 208E;208E;208E;0029;0029; 
    // (₎; ₎; ₎; ); ); ) SUBSCRIPT RIGHT PARENTHESIS
    {
        std::array<char32_t, 1> const c1 = {{ 0x208E }};
        std::array<char32_t, 1> const c2 = {{ 0x208E }};
        std::array<char32_t, 1> const c3 = {{ 0x208E }};
        std::array<char32_t, 1> const c4 = {{ 0x0029 }};
        std::array<char32_t, 1> const c5 = {{ 0x0029 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_005_199)
{
    // 2090;2090;2090;0061;0061; 
    // (ₐ; ₐ; ₐ; a; a; ) LATIN SUBSCRIPT SMALL LETTER A
    {
        std::array<char32_t, 1> const c1 = {{ 0x2090 }};
        std::array<char32_t, 1> const c2 = {{ 0x2090 }};
        std::array<char32_t, 1> const c3 = {{ 0x2090 }};
        std::array<char32_t, 1> const c4 = {{ 0x0061 }};
        std::array<char32_t, 1> const c5 = {{ 0x0061 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


