// Copyright (C) 2020 T. Zachary Laine
//
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

// Warning! This file is autogenerated.
#include <boost/text/normalize_string.hpp>
#include <boost/text/transcode_view.hpp>
#include <boost/text/string_utility.hpp>

#include <gtest/gtest.h>

#include <algorithm>



TEST(normalization, nfkd_050_000)
{
    // C9A0;C9A0;110C 1173 11BF;C9A0;110C 1173 11BF; 
    // (즠; 즠; 즠; 즠; 즠; ) HANGUL SYLLABLE JEUK
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9A0 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9A0 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1173, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xC9A0 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1173, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_001)
{
    // C9A1;C9A1;110C 1173 11C0;C9A1;110C 1173 11C0; 
    // (즡; 즡; 즡; 즡; 즡; ) HANGUL SYLLABLE JEUT
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9A1 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9A1 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1173, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9A1 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1173, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_002)
{
    // C9A2;C9A2;110C 1173 11C1;C9A2;110C 1173 11C1; 
    // (즢; 즢; 즢; 즢; 즢; ) HANGUL SYLLABLE JEUP
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9A2 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9A2 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1173, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9A2 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1173, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_003)
{
    // C9A3;C9A3;110C 1173 11C2;C9A3;110C 1173 11C2; 
    // (즣; 즣; 즣; 즣; 즣; ) HANGUL SYLLABLE JEUH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9A3 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9A3 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1173, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9A3 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1173, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_004)
{
    // C9A4;C9A4;110C 1174;C9A4;110C 1174; 
    // (즤; 즤; 즤; 즤; 즤; ) HANGUL SYLLABLE JYI
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9A4 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9A4 }};
        std::array<char32_t, 2> const c3 = {{ 0x110C, 0x1174 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9A4 }};
        std::array<char32_t, 2> const c5 = {{ 0x110C, 0x1174 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_005)
{
    // C9A5;C9A5;110C 1174 11A8;C9A5;110C 1174 11A8; 
    // (즥; 즥; 즥; 즥; 즥; ) HANGUL SYLLABLE JYIG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9A5 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9A5 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9A5 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_006)
{
    // C9A6;C9A6;110C 1174 11A9;C9A6;110C 1174 11A9; 
    // (즦; 즦; 즦; 즦; 즦; ) HANGUL SYLLABLE JYIGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9A6 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9A6 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9A6 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_007)
{
    // C9A7;C9A7;110C 1174 11AA;C9A7;110C 1174 11AA; 
    // (즧; 즧; 즧; 즧; 즧; ) HANGUL SYLLABLE JYIGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9A7 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9A7 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xC9A7 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_008)
{
    // C9A8;C9A8;110C 1174 11AB;C9A8;110C 1174 11AB; 
    // (즨; 즨; 즨; 즨; 즨; ) HANGUL SYLLABLE JYIN
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9A8 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9A8 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xC9A8 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_009)
{
    // C9A9;C9A9;110C 1174 11AC;C9A9;110C 1174 11AC; 
    // (즩; 즩; 즩; 즩; 즩; ) HANGUL SYLLABLE JYINJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9A9 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9A9 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xC9A9 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_010)
{
    // C9AA;C9AA;110C 1174 11AD;C9AA;110C 1174 11AD; 
    // (즪; 즪; 즪; 즪; 즪; ) HANGUL SYLLABLE JYINH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9AA }};
        std::array<char32_t, 1> const c2 = {{ 0xC9AA }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xC9AA }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_011)
{
    // C9AB;C9AB;110C 1174 11AE;C9AB;110C 1174 11AE; 
    // (즫; 즫; 즫; 즫; 즫; ) HANGUL SYLLABLE JYID
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9AB }};
        std::array<char32_t, 1> const c2 = {{ 0xC9AB }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xC9AB }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_012)
{
    // C9AC;C9AC;110C 1174 11AF;C9AC;110C 1174 11AF; 
    // (즬; 즬; 즬; 즬; 즬; ) HANGUL SYLLABLE JYIL
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9AC }};
        std::array<char32_t, 1> const c2 = {{ 0xC9AC }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xC9AC }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_013)
{
    // C9AD;C9AD;110C 1174 11B0;C9AD;110C 1174 11B0; 
    // (즭; 즭; 즭; 즭; 즭; ) HANGUL SYLLABLE JYILG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9AD }};
        std::array<char32_t, 1> const c2 = {{ 0xC9AD }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9AD }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_014)
{
    // C9AE;C9AE;110C 1174 11B1;C9AE;110C 1174 11B1; 
    // (즮; 즮; 즮; 즮; 즮; ) HANGUL SYLLABLE JYILM
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9AE }};
        std::array<char32_t, 1> const c2 = {{ 0xC9AE }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9AE }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_015)
{
    // C9AF;C9AF;110C 1174 11B2;C9AF;110C 1174 11B2; 
    // (즯; 즯; 즯; 즯; 즯; ) HANGUL SYLLABLE JYILB
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9AF }};
        std::array<char32_t, 1> const c2 = {{ 0xC9AF }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9AF }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_016)
{
    // C9B0;C9B0;110C 1174 11B3;C9B0;110C 1174 11B3; 
    // (즰; 즰; 즰; 즰; 즰; ) HANGUL SYLLABLE JYILS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9B0 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9B0 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9B0 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_017)
{
    // C9B1;C9B1;110C 1174 11B4;C9B1;110C 1174 11B4; 
    // (즱; 즱; 즱; 즱; 즱; ) HANGUL SYLLABLE JYILT
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9B1 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9B1 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9B1 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_018)
{
    // C9B2;C9B2;110C 1174 11B5;C9B2;110C 1174 11B5; 
    // (즲; 즲; 즲; 즲; 즲; ) HANGUL SYLLABLE JYILP
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9B2 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9B2 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9B2 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_019)
{
    // C9B3;C9B3;110C 1174 11B6;C9B3;110C 1174 11B6; 
    // (즳; 즳; 즳; 즳; 즳; ) HANGUL SYLLABLE JYILH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9B3 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9B3 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9B3 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_020)
{
    // C9B4;C9B4;110C 1174 11B7;C9B4;110C 1174 11B7; 
    // (즴; 즴; 즴; 즴; 즴; ) HANGUL SYLLABLE JYIM
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9B4 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9B4 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9B4 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_021)
{
    // C9B5;C9B5;110C 1174 11B8;C9B5;110C 1174 11B8; 
    // (즵; 즵; 즵; 즵; 즵; ) HANGUL SYLLABLE JYIB
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9B5 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9B5 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9B5 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_022)
{
    // C9B6;C9B6;110C 1174 11B9;C9B6;110C 1174 11B9; 
    // (즶; 즶; 즶; 즶; 즶; ) HANGUL SYLLABLE JYIBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9B6 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9B6 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9B6 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_023)
{
    // C9B7;C9B7;110C 1174 11BA;C9B7;110C 1174 11BA; 
    // (즷; 즷; 즷; 즷; 즷; ) HANGUL SYLLABLE JYIS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9B7 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9B7 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xC9B7 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_024)
{
    // C9B8;C9B8;110C 1174 11BB;C9B8;110C 1174 11BB; 
    // (즸; 즸; 즸; 즸; 즸; ) HANGUL SYLLABLE JYISS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9B8 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9B8 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xC9B8 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_025)
{
    // C9B9;C9B9;110C 1174 11BC;C9B9;110C 1174 11BC; 
    // (즹; 즹; 즹; 즹; 즹; ) HANGUL SYLLABLE JYING
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9B9 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9B9 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xC9B9 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_026)
{
    // C9BA;C9BA;110C 1174 11BD;C9BA;110C 1174 11BD; 
    // (즺; 즺; 즺; 즺; 즺; ) HANGUL SYLLABLE JYIJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9BA }};
        std::array<char32_t, 1> const c2 = {{ 0xC9BA }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xC9BA }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_027)
{
    // C9BB;C9BB;110C 1174 11BE;C9BB;110C 1174 11BE; 
    // (즻; 즻; 즻; 즻; 즻; ) HANGUL SYLLABLE JYIC
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9BB }};
        std::array<char32_t, 1> const c2 = {{ 0xC9BB }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xC9BB }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_028)
{
    // C9BC;C9BC;110C 1174 11BF;C9BC;110C 1174 11BF; 
    // (즼; 즼; 즼; 즼; 즼; ) HANGUL SYLLABLE JYIK
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9BC }};
        std::array<char32_t, 1> const c2 = {{ 0xC9BC }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xC9BC }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_029)
{
    // C9BD;C9BD;110C 1174 11C0;C9BD;110C 1174 11C0; 
    // (즽; 즽; 즽; 즽; 즽; ) HANGUL SYLLABLE JYIT
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9BD }};
        std::array<char32_t, 1> const c2 = {{ 0xC9BD }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9BD }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_030)
{
    // C9BE;C9BE;110C 1174 11C1;C9BE;110C 1174 11C1; 
    // (즾; 즾; 즾; 즾; 즾; ) HANGUL SYLLABLE JYIP
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9BE }};
        std::array<char32_t, 1> const c2 = {{ 0xC9BE }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9BE }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_031)
{
    // C9BF;C9BF;110C 1174 11C2;C9BF;110C 1174 11C2; 
    // (즿; 즿; 즿; 즿; 즿; ) HANGUL SYLLABLE JYIH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9BF }};
        std::array<char32_t, 1> const c2 = {{ 0xC9BF }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1174, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9BF }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1174, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_032)
{
    // C9C0;C9C0;110C 1175;C9C0;110C 1175; 
    // (지; 지; 지; 지; 지; ) HANGUL SYLLABLE JI
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9C0 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9C0 }};
        std::array<char32_t, 2> const c3 = {{ 0x110C, 0x1175 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9C0 }};
        std::array<char32_t, 2> const c5 = {{ 0x110C, 0x1175 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_033)
{
    // C9C1;C9C1;110C 1175 11A8;C9C1;110C 1175 11A8; 
    // (직; 직; 직; 직; 직; ) HANGUL SYLLABLE JIG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9C1 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9C1 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9C1 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_034)
{
    // C9C2;C9C2;110C 1175 11A9;C9C2;110C 1175 11A9; 
    // (짂; 짂; 짂; 짂; 짂; ) HANGUL SYLLABLE JIGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9C2 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9C2 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9C2 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_035)
{
    // C9C3;C9C3;110C 1175 11AA;C9C3;110C 1175 11AA; 
    // (짃; 짃; 짃; 짃; 짃; ) HANGUL SYLLABLE JIGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9C3 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9C3 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xC9C3 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_036)
{
    // C9C4;C9C4;110C 1175 11AB;C9C4;110C 1175 11AB; 
    // (진; 진; 진; 진; 진; ) HANGUL SYLLABLE JIN
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9C4 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9C4 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xC9C4 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_037)
{
    // C9C5;C9C5;110C 1175 11AC;C9C5;110C 1175 11AC; 
    // (짅; 짅; 짅; 짅; 짅; ) HANGUL SYLLABLE JINJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9C5 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9C5 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xC9C5 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_038)
{
    // C9C6;C9C6;110C 1175 11AD;C9C6;110C 1175 11AD; 
    // (짆; 짆; 짆; 짆; 짆; ) HANGUL SYLLABLE JINH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9C6 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9C6 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xC9C6 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_039)
{
    // C9C7;C9C7;110C 1175 11AE;C9C7;110C 1175 11AE; 
    // (짇; 짇; 짇; 짇; 짇; ) HANGUL SYLLABLE JID
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9C7 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9C7 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xC9C7 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_040)
{
    // C9C8;C9C8;110C 1175 11AF;C9C8;110C 1175 11AF; 
    // (질; 질; 질; 질; 질; ) HANGUL SYLLABLE JIL
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9C8 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9C8 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xC9C8 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_041)
{
    // C9C9;C9C9;110C 1175 11B0;C9C9;110C 1175 11B0; 
    // (짉; 짉; 짉; 짉; 짉; ) HANGUL SYLLABLE JILG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9C9 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9C9 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9C9 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_042)
{
    // C9CA;C9CA;110C 1175 11B1;C9CA;110C 1175 11B1; 
    // (짊; 짊; 짊; 짊; 짊; ) HANGUL SYLLABLE JILM
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9CA }};
        std::array<char32_t, 1> const c2 = {{ 0xC9CA }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9CA }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_043)
{
    // C9CB;C9CB;110C 1175 11B2;C9CB;110C 1175 11B2; 
    // (짋; 짋; 짋; 짋; 짋; ) HANGUL SYLLABLE JILB
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9CB }};
        std::array<char32_t, 1> const c2 = {{ 0xC9CB }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9CB }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_044)
{
    // C9CC;C9CC;110C 1175 11B3;C9CC;110C 1175 11B3; 
    // (짌; 짌; 짌; 짌; 짌; ) HANGUL SYLLABLE JILS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9CC }};
        std::array<char32_t, 1> const c2 = {{ 0xC9CC }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9CC }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_045)
{
    // C9CD;C9CD;110C 1175 11B4;C9CD;110C 1175 11B4; 
    // (짍; 짍; 짍; 짍; 짍; ) HANGUL SYLLABLE JILT
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9CD }};
        std::array<char32_t, 1> const c2 = {{ 0xC9CD }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9CD }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_046)
{
    // C9CE;C9CE;110C 1175 11B5;C9CE;110C 1175 11B5; 
    // (짎; 짎; 짎; 짎; 짎; ) HANGUL SYLLABLE JILP
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9CE }};
        std::array<char32_t, 1> const c2 = {{ 0xC9CE }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9CE }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_047)
{
    // C9CF;C9CF;110C 1175 11B6;C9CF;110C 1175 11B6; 
    // (짏; 짏; 짏; 짏; 짏; ) HANGUL SYLLABLE JILH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9CF }};
        std::array<char32_t, 1> const c2 = {{ 0xC9CF }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9CF }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_048)
{
    // C9D0;C9D0;110C 1175 11B7;C9D0;110C 1175 11B7; 
    // (짐; 짐; 짐; 짐; 짐; ) HANGUL SYLLABLE JIM
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9D0 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9D0 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9D0 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_049)
{
    // C9D1;C9D1;110C 1175 11B8;C9D1;110C 1175 11B8; 
    // (집; 집; 집; 집; 집; ) HANGUL SYLLABLE JIB
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9D1 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9D1 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9D1 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_050)
{
    // C9D2;C9D2;110C 1175 11B9;C9D2;110C 1175 11B9; 
    // (짒; 짒; 짒; 짒; 짒; ) HANGUL SYLLABLE JIBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9D2 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9D2 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9D2 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_051)
{
    // C9D3;C9D3;110C 1175 11BA;C9D3;110C 1175 11BA; 
    // (짓; 짓; 짓; 짓; 짓; ) HANGUL SYLLABLE JIS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9D3 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9D3 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xC9D3 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_052)
{
    // C9D4;C9D4;110C 1175 11BB;C9D4;110C 1175 11BB; 
    // (짔; 짔; 짔; 짔; 짔; ) HANGUL SYLLABLE JISS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9D4 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9D4 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xC9D4 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_053)
{
    // C9D5;C9D5;110C 1175 11BC;C9D5;110C 1175 11BC; 
    // (징; 징; 징; 징; 징; ) HANGUL SYLLABLE JING
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9D5 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9D5 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xC9D5 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_054)
{
    // C9D6;C9D6;110C 1175 11BD;C9D6;110C 1175 11BD; 
    // (짖; 짖; 짖; 짖; 짖; ) HANGUL SYLLABLE JIJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9D6 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9D6 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xC9D6 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_055)
{
    // C9D7;C9D7;110C 1175 11BE;C9D7;110C 1175 11BE; 
    // (짗; 짗; 짗; 짗; 짗; ) HANGUL SYLLABLE JIC
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9D7 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9D7 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xC9D7 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_056)
{
    // C9D8;C9D8;110C 1175 11BF;C9D8;110C 1175 11BF; 
    // (짘; 짘; 짘; 짘; 짘; ) HANGUL SYLLABLE JIK
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9D8 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9D8 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xC9D8 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_057)
{
    // C9D9;C9D9;110C 1175 11C0;C9D9;110C 1175 11C0; 
    // (짙; 짙; 짙; 짙; 짙; ) HANGUL SYLLABLE JIT
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9D9 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9D9 }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9D9 }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_058)
{
    // C9DA;C9DA;110C 1175 11C1;C9DA;110C 1175 11C1; 
    // (짚; 짚; 짚; 짚; 짚; ) HANGUL SYLLABLE JIP
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9DA }};
        std::array<char32_t, 1> const c2 = {{ 0xC9DA }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9DA }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_059)
{
    // C9DB;C9DB;110C 1175 11C2;C9DB;110C 1175 11C2; 
    // (짛; 짛; 짛; 짛; 짛; ) HANGUL SYLLABLE JIH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9DB }};
        std::array<char32_t, 1> const c2 = {{ 0xC9DB }};
        std::array<char32_t, 3> const c3 = {{ 0x110C, 0x1175, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9DB }};
        std::array<char32_t, 3> const c5 = {{ 0x110C, 0x1175, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_060)
{
    // C9DC;C9DC;110D 1161;C9DC;110D 1161; 
    // (짜; 짜; 짜; 짜; 짜; ) HANGUL SYLLABLE JJA
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9DC }};
        std::array<char32_t, 1> const c2 = {{ 0xC9DC }};
        std::array<char32_t, 2> const c3 = {{ 0x110D, 0x1161 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9DC }};
        std::array<char32_t, 2> const c5 = {{ 0x110D, 0x1161 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_061)
{
    // C9DD;C9DD;110D 1161 11A8;C9DD;110D 1161 11A8; 
    // (짝; 짝; 짝; 짝; 짝; ) HANGUL SYLLABLE JJAG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9DD }};
        std::array<char32_t, 1> const c2 = {{ 0xC9DD }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9DD }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_062)
{
    // C9DE;C9DE;110D 1161 11A9;C9DE;110D 1161 11A9; 
    // (짞; 짞; 짞; 짞; 짞; ) HANGUL SYLLABLE JJAGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9DE }};
        std::array<char32_t, 1> const c2 = {{ 0xC9DE }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9DE }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_063)
{
    // C9DF;C9DF;110D 1161 11AA;C9DF;110D 1161 11AA; 
    // (짟; 짟; 짟; 짟; 짟; ) HANGUL SYLLABLE JJAGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9DF }};
        std::array<char32_t, 1> const c2 = {{ 0xC9DF }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xC9DF }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_064)
{
    // C9E0;C9E0;110D 1161 11AB;C9E0;110D 1161 11AB; 
    // (짠; 짠; 짠; 짠; 짠; ) HANGUL SYLLABLE JJAN
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9E0 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9E0 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xC9E0 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_065)
{
    // C9E1;C9E1;110D 1161 11AC;C9E1;110D 1161 11AC; 
    // (짡; 짡; 짡; 짡; 짡; ) HANGUL SYLLABLE JJANJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9E1 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9E1 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xC9E1 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_066)
{
    // C9E2;C9E2;110D 1161 11AD;C9E2;110D 1161 11AD; 
    // (짢; 짢; 짢; 짢; 짢; ) HANGUL SYLLABLE JJANH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9E2 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9E2 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xC9E2 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_067)
{
    // C9E3;C9E3;110D 1161 11AE;C9E3;110D 1161 11AE; 
    // (짣; 짣; 짣; 짣; 짣; ) HANGUL SYLLABLE JJAD
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9E3 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9E3 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xC9E3 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_068)
{
    // C9E4;C9E4;110D 1161 11AF;C9E4;110D 1161 11AF; 
    // (짤; 짤; 짤; 짤; 짤; ) HANGUL SYLLABLE JJAL
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9E4 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9E4 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xC9E4 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_069)
{
    // C9E5;C9E5;110D 1161 11B0;C9E5;110D 1161 11B0; 
    // (짥; 짥; 짥; 짥; 짥; ) HANGUL SYLLABLE JJALG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9E5 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9E5 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9E5 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_070)
{
    // C9E6;C9E6;110D 1161 11B1;C9E6;110D 1161 11B1; 
    // (짦; 짦; 짦; 짦; 짦; ) HANGUL SYLLABLE JJALM
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9E6 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9E6 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9E6 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_071)
{
    // C9E7;C9E7;110D 1161 11B2;C9E7;110D 1161 11B2; 
    // (짧; 짧; 짧; 짧; 짧; ) HANGUL SYLLABLE JJALB
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9E7 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9E7 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9E7 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_072)
{
    // C9E8;C9E8;110D 1161 11B3;C9E8;110D 1161 11B3; 
    // (짨; 짨; 짨; 짨; 짨; ) HANGUL SYLLABLE JJALS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9E8 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9E8 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9E8 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_073)
{
    // C9E9;C9E9;110D 1161 11B4;C9E9;110D 1161 11B4; 
    // (짩; 짩; 짩; 짩; 짩; ) HANGUL SYLLABLE JJALT
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9E9 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9E9 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9E9 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_074)
{
    // C9EA;C9EA;110D 1161 11B5;C9EA;110D 1161 11B5; 
    // (짪; 짪; 짪; 짪; 짪; ) HANGUL SYLLABLE JJALP
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9EA }};
        std::array<char32_t, 1> const c2 = {{ 0xC9EA }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9EA }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_075)
{
    // C9EB;C9EB;110D 1161 11B6;C9EB;110D 1161 11B6; 
    // (짫; 짫; 짫; 짫; 짫; ) HANGUL SYLLABLE JJALH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9EB }};
        std::array<char32_t, 1> const c2 = {{ 0xC9EB }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9EB }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_076)
{
    // C9EC;C9EC;110D 1161 11B7;C9EC;110D 1161 11B7; 
    // (짬; 짬; 짬; 짬; 짬; ) HANGUL SYLLABLE JJAM
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9EC }};
        std::array<char32_t, 1> const c2 = {{ 0xC9EC }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9EC }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_077)
{
    // C9ED;C9ED;110D 1161 11B8;C9ED;110D 1161 11B8; 
    // (짭; 짭; 짭; 짭; 짭; ) HANGUL SYLLABLE JJAB
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9ED }};
        std::array<char32_t, 1> const c2 = {{ 0xC9ED }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9ED }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_078)
{
    // C9EE;C9EE;110D 1161 11B9;C9EE;110D 1161 11B9; 
    // (짮; 짮; 짮; 짮; 짮; ) HANGUL SYLLABLE JJABS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9EE }};
        std::array<char32_t, 1> const c2 = {{ 0xC9EE }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9EE }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_079)
{
    // C9EF;C9EF;110D 1161 11BA;C9EF;110D 1161 11BA; 
    // (짯; 짯; 짯; 짯; 짯; ) HANGUL SYLLABLE JJAS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9EF }};
        std::array<char32_t, 1> const c2 = {{ 0xC9EF }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xC9EF }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_080)
{
    // C9F0;C9F0;110D 1161 11BB;C9F0;110D 1161 11BB; 
    // (짰; 짰; 짰; 짰; 짰; ) HANGUL SYLLABLE JJASS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9F0 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9F0 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xC9F0 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_081)
{
    // C9F1;C9F1;110D 1161 11BC;C9F1;110D 1161 11BC; 
    // (짱; 짱; 짱; 짱; 짱; ) HANGUL SYLLABLE JJANG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9F1 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9F1 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xC9F1 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_082)
{
    // C9F2;C9F2;110D 1161 11BD;C9F2;110D 1161 11BD; 
    // (짲; 짲; 짲; 짲; 짲; ) HANGUL SYLLABLE JJAJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9F2 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9F2 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xC9F2 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_083)
{
    // C9F3;C9F3;110D 1161 11BE;C9F3;110D 1161 11BE; 
    // (짳; 짳; 짳; 짳; 짳; ) HANGUL SYLLABLE JJAC
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9F3 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9F3 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xC9F3 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_084)
{
    // C9F4;C9F4;110D 1161 11BF;C9F4;110D 1161 11BF; 
    // (짴; 짴; 짴; 짴; 짴; ) HANGUL SYLLABLE JJAK
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9F4 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9F4 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xC9F4 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_085)
{
    // C9F5;C9F5;110D 1161 11C0;C9F5;110D 1161 11C0; 
    // (짵; 짵; 짵; 짵; 짵; ) HANGUL SYLLABLE JJAT
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9F5 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9F5 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9F5 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_086)
{
    // C9F6;C9F6;110D 1161 11C1;C9F6;110D 1161 11C1; 
    // (짶; 짶; 짶; 짶; 짶; ) HANGUL SYLLABLE JJAP
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9F6 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9F6 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9F6 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_087)
{
    // C9F7;C9F7;110D 1161 11C2;C9F7;110D 1161 11C2; 
    // (짷; 짷; 짷; 짷; 짷; ) HANGUL SYLLABLE JJAH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9F7 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9F7 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1161, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9F7 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1161, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_088)
{
    // C9F8;C9F8;110D 1162;C9F8;110D 1162; 
    // (째; 째; 째; 째; 째; ) HANGUL SYLLABLE JJAE
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9F8 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9F8 }};
        std::array<char32_t, 2> const c3 = {{ 0x110D, 0x1162 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9F8 }};
        std::array<char32_t, 2> const c5 = {{ 0x110D, 0x1162 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_089)
{
    // C9F9;C9F9;110D 1162 11A8;C9F9;110D 1162 11A8; 
    // (짹; 짹; 짹; 짹; 짹; ) HANGUL SYLLABLE JJAEG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9F9 }};
        std::array<char32_t, 1> const c2 = {{ 0xC9F9 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9F9 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_090)
{
    // C9FA;C9FA;110D 1162 11A9;C9FA;110D 1162 11A9; 
    // (짺; 짺; 짺; 짺; 짺; ) HANGUL SYLLABLE JJAEGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9FA }};
        std::array<char32_t, 1> const c2 = {{ 0xC9FA }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xC9FA }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_091)
{
    // C9FB;C9FB;110D 1162 11AA;C9FB;110D 1162 11AA; 
    // (짻; 짻; 짻; 짻; 짻; ) HANGUL SYLLABLE JJAEGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9FB }};
        std::array<char32_t, 1> const c2 = {{ 0xC9FB }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xC9FB }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_092)
{
    // C9FC;C9FC;110D 1162 11AB;C9FC;110D 1162 11AB; 
    // (짼; 짼; 짼; 짼; 짼; ) HANGUL SYLLABLE JJAEN
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9FC }};
        std::array<char32_t, 1> const c2 = {{ 0xC9FC }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xC9FC }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_093)
{
    // C9FD;C9FD;110D 1162 11AC;C9FD;110D 1162 11AC; 
    // (짽; 짽; 짽; 짽; 짽; ) HANGUL SYLLABLE JJAENJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9FD }};
        std::array<char32_t, 1> const c2 = {{ 0xC9FD }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xC9FD }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_094)
{
    // C9FE;C9FE;110D 1162 11AD;C9FE;110D 1162 11AD; 
    // (짾; 짾; 짾; 짾; 짾; ) HANGUL SYLLABLE JJAENH
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9FE }};
        std::array<char32_t, 1> const c2 = {{ 0xC9FE }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xC9FE }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_095)
{
    // C9FF;C9FF;110D 1162 11AE;C9FF;110D 1162 11AE; 
    // (짿; 짿; 짿; 짿; 짿; ) HANGUL SYLLABLE JJAED
    {
        std::array<char32_t, 1> const c1 = {{ 0xC9FF }};
        std::array<char32_t, 1> const c2 = {{ 0xC9FF }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xC9FF }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_096)
{
    // CA00;CA00;110D 1162 11AF;CA00;110D 1162 11AF; 
    // (쨀; 쨀; 쨀; 쨀; 쨀; ) HANGUL SYLLABLE JJAEL
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA00 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA00 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xCA00 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_097)
{
    // CA01;CA01;110D 1162 11B0;CA01;110D 1162 11B0; 
    // (쨁; 쨁; 쨁; 쨁; 쨁; ) HANGUL SYLLABLE JJAELG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA01 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA01 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA01 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_098)
{
    // CA02;CA02;110D 1162 11B1;CA02;110D 1162 11B1; 
    // (쨂; 쨂; 쨂; 쨂; 쨂; ) HANGUL SYLLABLE JJAELM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA02 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA02 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA02 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_099)
{
    // CA03;CA03;110D 1162 11B2;CA03;110D 1162 11B2; 
    // (쨃; 쨃; 쨃; 쨃; 쨃; ) HANGUL SYLLABLE JJAELB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA03 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA03 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA03 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_100)
{
    // CA04;CA04;110D 1162 11B3;CA04;110D 1162 11B3; 
    // (쨄; 쨄; 쨄; 쨄; 쨄; ) HANGUL SYLLABLE JJAELS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA04 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA04 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA04 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_101)
{
    // CA05;CA05;110D 1162 11B4;CA05;110D 1162 11B4; 
    // (쨅; 쨅; 쨅; 쨅; 쨅; ) HANGUL SYLLABLE JJAELT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA05 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA05 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA05 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_102)
{
    // CA06;CA06;110D 1162 11B5;CA06;110D 1162 11B5; 
    // (쨆; 쨆; 쨆; 쨆; 쨆; ) HANGUL SYLLABLE JJAELP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA06 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA06 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA06 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_103)
{
    // CA07;CA07;110D 1162 11B6;CA07;110D 1162 11B6; 
    // (쨇; 쨇; 쨇; 쨇; 쨇; ) HANGUL SYLLABLE JJAELH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA07 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA07 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA07 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_104)
{
    // CA08;CA08;110D 1162 11B7;CA08;110D 1162 11B7; 
    // (쨈; 쨈; 쨈; 쨈; 쨈; ) HANGUL SYLLABLE JJAEM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA08 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA08 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA08 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_105)
{
    // CA09;CA09;110D 1162 11B8;CA09;110D 1162 11B8; 
    // (쨉; 쨉; 쨉; 쨉; 쨉; ) HANGUL SYLLABLE JJAEB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA09 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA09 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA09 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_106)
{
    // CA0A;CA0A;110D 1162 11B9;CA0A;110D 1162 11B9; 
    // (쨊; 쨊; 쨊; 쨊; 쨊; ) HANGUL SYLLABLE JJAEBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA0A }};
        std::array<char32_t, 1> const c2 = {{ 0xCA0A }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA0A }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_107)
{
    // CA0B;CA0B;110D 1162 11BA;CA0B;110D 1162 11BA; 
    // (쨋; 쨋; 쨋; 쨋; 쨋; ) HANGUL SYLLABLE JJAES
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA0B }};
        std::array<char32_t, 1> const c2 = {{ 0xCA0B }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xCA0B }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_108)
{
    // CA0C;CA0C;110D 1162 11BB;CA0C;110D 1162 11BB; 
    // (쨌; 쨌; 쨌; 쨌; 쨌; ) HANGUL SYLLABLE JJAESS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA0C }};
        std::array<char32_t, 1> const c2 = {{ 0xCA0C }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xCA0C }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_109)
{
    // CA0D;CA0D;110D 1162 11BC;CA0D;110D 1162 11BC; 
    // (쨍; 쨍; 쨍; 쨍; 쨍; ) HANGUL SYLLABLE JJAENG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA0D }};
        std::array<char32_t, 1> const c2 = {{ 0xCA0D }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xCA0D }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_110)
{
    // CA0E;CA0E;110D 1162 11BD;CA0E;110D 1162 11BD; 
    // (쨎; 쨎; 쨎; 쨎; 쨎; ) HANGUL SYLLABLE JJAEJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA0E }};
        std::array<char32_t, 1> const c2 = {{ 0xCA0E }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xCA0E }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_111)
{
    // CA0F;CA0F;110D 1162 11BE;CA0F;110D 1162 11BE; 
    // (쨏; 쨏; 쨏; 쨏; 쨏; ) HANGUL SYLLABLE JJAEC
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA0F }};
        std::array<char32_t, 1> const c2 = {{ 0xCA0F }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xCA0F }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_112)
{
    // CA10;CA10;110D 1162 11BF;CA10;110D 1162 11BF; 
    // (쨐; 쨐; 쨐; 쨐; 쨐; ) HANGUL SYLLABLE JJAEK
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA10 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA10 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xCA10 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_113)
{
    // CA11;CA11;110D 1162 11C0;CA11;110D 1162 11C0; 
    // (쨑; 쨑; 쨑; 쨑; 쨑; ) HANGUL SYLLABLE JJAET
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA11 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA11 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA11 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_114)
{
    // CA12;CA12;110D 1162 11C1;CA12;110D 1162 11C1; 
    // (쨒; 쨒; 쨒; 쨒; 쨒; ) HANGUL SYLLABLE JJAEP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA12 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA12 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA12 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_115)
{
    // CA13;CA13;110D 1162 11C2;CA13;110D 1162 11C2; 
    // (쨓; 쨓; 쨓; 쨓; 쨓; ) HANGUL SYLLABLE JJAEH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA13 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA13 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1162, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA13 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1162, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_116)
{
    // CA14;CA14;110D 1163;CA14;110D 1163; 
    // (쨔; 쨔; 쨔; 쨔; 쨔; ) HANGUL SYLLABLE JJYA
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA14 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA14 }};
        std::array<char32_t, 2> const c3 = {{ 0x110D, 0x1163 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA14 }};
        std::array<char32_t, 2> const c5 = {{ 0x110D, 0x1163 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_117)
{
    // CA15;CA15;110D 1163 11A8;CA15;110D 1163 11A8; 
    // (쨕; 쨕; 쨕; 쨕; 쨕; ) HANGUL SYLLABLE JJYAG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA15 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA15 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA15 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_118)
{
    // CA16;CA16;110D 1163 11A9;CA16;110D 1163 11A9; 
    // (쨖; 쨖; 쨖; 쨖; 쨖; ) HANGUL SYLLABLE JJYAGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA16 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA16 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA16 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_119)
{
    // CA17;CA17;110D 1163 11AA;CA17;110D 1163 11AA; 
    // (쨗; 쨗; 쨗; 쨗; 쨗; ) HANGUL SYLLABLE JJYAGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA17 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA17 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xCA17 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_120)
{
    // CA18;CA18;110D 1163 11AB;CA18;110D 1163 11AB; 
    // (쨘; 쨘; 쨘; 쨘; 쨘; ) HANGUL SYLLABLE JJYAN
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA18 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA18 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xCA18 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_121)
{
    // CA19;CA19;110D 1163 11AC;CA19;110D 1163 11AC; 
    // (쨙; 쨙; 쨙; 쨙; 쨙; ) HANGUL SYLLABLE JJYANJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA19 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA19 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xCA19 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_122)
{
    // CA1A;CA1A;110D 1163 11AD;CA1A;110D 1163 11AD; 
    // (쨚; 쨚; 쨚; 쨚; 쨚; ) HANGUL SYLLABLE JJYANH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA1A }};
        std::array<char32_t, 1> const c2 = {{ 0xCA1A }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xCA1A }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_123)
{
    // CA1B;CA1B;110D 1163 11AE;CA1B;110D 1163 11AE; 
    // (쨛; 쨛; 쨛; 쨛; 쨛; ) HANGUL SYLLABLE JJYAD
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA1B }};
        std::array<char32_t, 1> const c2 = {{ 0xCA1B }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xCA1B }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_124)
{
    // CA1C;CA1C;110D 1163 11AF;CA1C;110D 1163 11AF; 
    // (쨜; 쨜; 쨜; 쨜; 쨜; ) HANGUL SYLLABLE JJYAL
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA1C }};
        std::array<char32_t, 1> const c2 = {{ 0xCA1C }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xCA1C }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_125)
{
    // CA1D;CA1D;110D 1163 11B0;CA1D;110D 1163 11B0; 
    // (쨝; 쨝; 쨝; 쨝; 쨝; ) HANGUL SYLLABLE JJYALG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA1D }};
        std::array<char32_t, 1> const c2 = {{ 0xCA1D }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA1D }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_126)
{
    // CA1E;CA1E;110D 1163 11B1;CA1E;110D 1163 11B1; 
    // (쨞; 쨞; 쨞; 쨞; 쨞; ) HANGUL SYLLABLE JJYALM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA1E }};
        std::array<char32_t, 1> const c2 = {{ 0xCA1E }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA1E }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_127)
{
    // CA1F;CA1F;110D 1163 11B2;CA1F;110D 1163 11B2; 
    // (쨟; 쨟; 쨟; 쨟; 쨟; ) HANGUL SYLLABLE JJYALB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA1F }};
        std::array<char32_t, 1> const c2 = {{ 0xCA1F }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA1F }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_128)
{
    // CA20;CA20;110D 1163 11B3;CA20;110D 1163 11B3; 
    // (쨠; 쨠; 쨠; 쨠; 쨠; ) HANGUL SYLLABLE JJYALS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA20 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA20 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA20 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_129)
{
    // CA21;CA21;110D 1163 11B4;CA21;110D 1163 11B4; 
    // (쨡; 쨡; 쨡; 쨡; 쨡; ) HANGUL SYLLABLE JJYALT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA21 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA21 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA21 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_130)
{
    // CA22;CA22;110D 1163 11B5;CA22;110D 1163 11B5; 
    // (쨢; 쨢; 쨢; 쨢; 쨢; ) HANGUL SYLLABLE JJYALP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA22 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA22 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA22 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_131)
{
    // CA23;CA23;110D 1163 11B6;CA23;110D 1163 11B6; 
    // (쨣; 쨣; 쨣; 쨣; 쨣; ) HANGUL SYLLABLE JJYALH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA23 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA23 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA23 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_132)
{
    // CA24;CA24;110D 1163 11B7;CA24;110D 1163 11B7; 
    // (쨤; 쨤; 쨤; 쨤; 쨤; ) HANGUL SYLLABLE JJYAM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA24 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA24 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA24 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_133)
{
    // CA25;CA25;110D 1163 11B8;CA25;110D 1163 11B8; 
    // (쨥; 쨥; 쨥; 쨥; 쨥; ) HANGUL SYLLABLE JJYAB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA25 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA25 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA25 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_134)
{
    // CA26;CA26;110D 1163 11B9;CA26;110D 1163 11B9; 
    // (쨦; 쨦; 쨦; 쨦; 쨦; ) HANGUL SYLLABLE JJYABS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA26 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA26 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA26 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_135)
{
    // CA27;CA27;110D 1163 11BA;CA27;110D 1163 11BA; 
    // (쨧; 쨧; 쨧; 쨧; 쨧; ) HANGUL SYLLABLE JJYAS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA27 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA27 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xCA27 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_136)
{
    // CA28;CA28;110D 1163 11BB;CA28;110D 1163 11BB; 
    // (쨨; 쨨; 쨨; 쨨; 쨨; ) HANGUL SYLLABLE JJYASS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA28 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA28 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xCA28 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_137)
{
    // CA29;CA29;110D 1163 11BC;CA29;110D 1163 11BC; 
    // (쨩; 쨩; 쨩; 쨩; 쨩; ) HANGUL SYLLABLE JJYANG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA29 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA29 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xCA29 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_138)
{
    // CA2A;CA2A;110D 1163 11BD;CA2A;110D 1163 11BD; 
    // (쨪; 쨪; 쨪; 쨪; 쨪; ) HANGUL SYLLABLE JJYAJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA2A }};
        std::array<char32_t, 1> const c2 = {{ 0xCA2A }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xCA2A }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_139)
{
    // CA2B;CA2B;110D 1163 11BE;CA2B;110D 1163 11BE; 
    // (쨫; 쨫; 쨫; 쨫; 쨫; ) HANGUL SYLLABLE JJYAC
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA2B }};
        std::array<char32_t, 1> const c2 = {{ 0xCA2B }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xCA2B }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_140)
{
    // CA2C;CA2C;110D 1163 11BF;CA2C;110D 1163 11BF; 
    // (쨬; 쨬; 쨬; 쨬; 쨬; ) HANGUL SYLLABLE JJYAK
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA2C }};
        std::array<char32_t, 1> const c2 = {{ 0xCA2C }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xCA2C }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_141)
{
    // CA2D;CA2D;110D 1163 11C0;CA2D;110D 1163 11C0; 
    // (쨭; 쨭; 쨭; 쨭; 쨭; ) HANGUL SYLLABLE JJYAT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA2D }};
        std::array<char32_t, 1> const c2 = {{ 0xCA2D }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA2D }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_142)
{
    // CA2E;CA2E;110D 1163 11C1;CA2E;110D 1163 11C1; 
    // (쨮; 쨮; 쨮; 쨮; 쨮; ) HANGUL SYLLABLE JJYAP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA2E }};
        std::array<char32_t, 1> const c2 = {{ 0xCA2E }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA2E }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_143)
{
    // CA2F;CA2F;110D 1163 11C2;CA2F;110D 1163 11C2; 
    // (쨯; 쨯; 쨯; 쨯; 쨯; ) HANGUL SYLLABLE JJYAH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA2F }};
        std::array<char32_t, 1> const c2 = {{ 0xCA2F }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1163, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA2F }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1163, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_144)
{
    // CA30;CA30;110D 1164;CA30;110D 1164; 
    // (쨰; 쨰; 쨰; 쨰; 쨰; ) HANGUL SYLLABLE JJYAE
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA30 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA30 }};
        std::array<char32_t, 2> const c3 = {{ 0x110D, 0x1164 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA30 }};
        std::array<char32_t, 2> const c5 = {{ 0x110D, 0x1164 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_145)
{
    // CA31;CA31;110D 1164 11A8;CA31;110D 1164 11A8; 
    // (쨱; 쨱; 쨱; 쨱; 쨱; ) HANGUL SYLLABLE JJYAEG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA31 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA31 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA31 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_146)
{
    // CA32;CA32;110D 1164 11A9;CA32;110D 1164 11A9; 
    // (쨲; 쨲; 쨲; 쨲; 쨲; ) HANGUL SYLLABLE JJYAEGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA32 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA32 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA32 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_147)
{
    // CA33;CA33;110D 1164 11AA;CA33;110D 1164 11AA; 
    // (쨳; 쨳; 쨳; 쨳; 쨳; ) HANGUL SYLLABLE JJYAEGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA33 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA33 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xCA33 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_148)
{
    // CA34;CA34;110D 1164 11AB;CA34;110D 1164 11AB; 
    // (쨴; 쨴; 쨴; 쨴; 쨴; ) HANGUL SYLLABLE JJYAEN
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA34 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA34 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xCA34 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_149)
{
    // CA35;CA35;110D 1164 11AC;CA35;110D 1164 11AC; 
    // (쨵; 쨵; 쨵; 쨵; 쨵; ) HANGUL SYLLABLE JJYAENJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA35 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA35 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xCA35 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_150)
{
    // CA36;CA36;110D 1164 11AD;CA36;110D 1164 11AD; 
    // (쨶; 쨶; 쨶; 쨶; 쨶; ) HANGUL SYLLABLE JJYAENH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA36 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA36 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xCA36 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_151)
{
    // CA37;CA37;110D 1164 11AE;CA37;110D 1164 11AE; 
    // (쨷; 쨷; 쨷; 쨷; 쨷; ) HANGUL SYLLABLE JJYAED
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA37 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA37 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xCA37 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_152)
{
    // CA38;CA38;110D 1164 11AF;CA38;110D 1164 11AF; 
    // (쨸; 쨸; 쨸; 쨸; 쨸; ) HANGUL SYLLABLE JJYAEL
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA38 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA38 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xCA38 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_153)
{
    // CA39;CA39;110D 1164 11B0;CA39;110D 1164 11B0; 
    // (쨹; 쨹; 쨹; 쨹; 쨹; ) HANGUL SYLLABLE JJYAELG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA39 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA39 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA39 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_154)
{
    // CA3A;CA3A;110D 1164 11B1;CA3A;110D 1164 11B1; 
    // (쨺; 쨺; 쨺; 쨺; 쨺; ) HANGUL SYLLABLE JJYAELM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA3A }};
        std::array<char32_t, 1> const c2 = {{ 0xCA3A }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA3A }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_155)
{
    // CA3B;CA3B;110D 1164 11B2;CA3B;110D 1164 11B2; 
    // (쨻; 쨻; 쨻; 쨻; 쨻; ) HANGUL SYLLABLE JJYAELB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA3B }};
        std::array<char32_t, 1> const c2 = {{ 0xCA3B }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA3B }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_156)
{
    // CA3C;CA3C;110D 1164 11B3;CA3C;110D 1164 11B3; 
    // (쨼; 쨼; 쨼; 쨼; 쨼; ) HANGUL SYLLABLE JJYAELS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA3C }};
        std::array<char32_t, 1> const c2 = {{ 0xCA3C }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA3C }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_157)
{
    // CA3D;CA3D;110D 1164 11B4;CA3D;110D 1164 11B4; 
    // (쨽; 쨽; 쨽; 쨽; 쨽; ) HANGUL SYLLABLE JJYAELT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA3D }};
        std::array<char32_t, 1> const c2 = {{ 0xCA3D }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA3D }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_158)
{
    // CA3E;CA3E;110D 1164 11B5;CA3E;110D 1164 11B5; 
    // (쨾; 쨾; 쨾; 쨾; 쨾; ) HANGUL SYLLABLE JJYAELP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA3E }};
        std::array<char32_t, 1> const c2 = {{ 0xCA3E }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA3E }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_159)
{
    // CA3F;CA3F;110D 1164 11B6;CA3F;110D 1164 11B6; 
    // (쨿; 쨿; 쨿; 쨿; 쨿; ) HANGUL SYLLABLE JJYAELH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA3F }};
        std::array<char32_t, 1> const c2 = {{ 0xCA3F }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA3F }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_160)
{
    // CA40;CA40;110D 1164 11B7;CA40;110D 1164 11B7; 
    // (쩀; 쩀; 쩀; 쩀; 쩀; ) HANGUL SYLLABLE JJYAEM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA40 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA40 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA40 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_161)
{
    // CA41;CA41;110D 1164 11B8;CA41;110D 1164 11B8; 
    // (쩁; 쩁; 쩁; 쩁; 쩁; ) HANGUL SYLLABLE JJYAEB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA41 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA41 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA41 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_162)
{
    // CA42;CA42;110D 1164 11B9;CA42;110D 1164 11B9; 
    // (쩂; 쩂; 쩂; 쩂; 쩂; ) HANGUL SYLLABLE JJYAEBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA42 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA42 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA42 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_163)
{
    // CA43;CA43;110D 1164 11BA;CA43;110D 1164 11BA; 
    // (쩃; 쩃; 쩃; 쩃; 쩃; ) HANGUL SYLLABLE JJYAES
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA43 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA43 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xCA43 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_164)
{
    // CA44;CA44;110D 1164 11BB;CA44;110D 1164 11BB; 
    // (쩄; 쩄; 쩄; 쩄; 쩄; ) HANGUL SYLLABLE JJYAESS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA44 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA44 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xCA44 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_165)
{
    // CA45;CA45;110D 1164 11BC;CA45;110D 1164 11BC; 
    // (쩅; 쩅; 쩅; 쩅; 쩅; ) HANGUL SYLLABLE JJYAENG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA45 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA45 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xCA45 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_166)
{
    // CA46;CA46;110D 1164 11BD;CA46;110D 1164 11BD; 
    // (쩆; 쩆; 쩆; 쩆; 쩆; ) HANGUL SYLLABLE JJYAEJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA46 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA46 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xCA46 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_167)
{
    // CA47;CA47;110D 1164 11BE;CA47;110D 1164 11BE; 
    // (쩇; 쩇; 쩇; 쩇; 쩇; ) HANGUL SYLLABLE JJYAEC
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA47 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA47 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xCA47 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_168)
{
    // CA48;CA48;110D 1164 11BF;CA48;110D 1164 11BF; 
    // (쩈; 쩈; 쩈; 쩈; 쩈; ) HANGUL SYLLABLE JJYAEK
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA48 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA48 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xCA48 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_169)
{
    // CA49;CA49;110D 1164 11C0;CA49;110D 1164 11C0; 
    // (쩉; 쩉; 쩉; 쩉; 쩉; ) HANGUL SYLLABLE JJYAET
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA49 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA49 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA49 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_170)
{
    // CA4A;CA4A;110D 1164 11C1;CA4A;110D 1164 11C1; 
    // (쩊; 쩊; 쩊; 쩊; 쩊; ) HANGUL SYLLABLE JJYAEP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA4A }};
        std::array<char32_t, 1> const c2 = {{ 0xCA4A }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA4A }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_171)
{
    // CA4B;CA4B;110D 1164 11C2;CA4B;110D 1164 11C2; 
    // (쩋; 쩋; 쩋; 쩋; 쩋; ) HANGUL SYLLABLE JJYAEH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA4B }};
        std::array<char32_t, 1> const c2 = {{ 0xCA4B }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1164, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA4B }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1164, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_172)
{
    // CA4C;CA4C;110D 1165;CA4C;110D 1165; 
    // (쩌; 쩌; 쩌; 쩌; 쩌; ) HANGUL SYLLABLE JJEO
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA4C }};
        std::array<char32_t, 1> const c2 = {{ 0xCA4C }};
        std::array<char32_t, 2> const c3 = {{ 0x110D, 0x1165 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA4C }};
        std::array<char32_t, 2> const c5 = {{ 0x110D, 0x1165 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_173)
{
    // CA4D;CA4D;110D 1165 11A8;CA4D;110D 1165 11A8; 
    // (쩍; 쩍; 쩍; 쩍; 쩍; ) HANGUL SYLLABLE JJEOG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA4D }};
        std::array<char32_t, 1> const c2 = {{ 0xCA4D }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA4D }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_174)
{
    // CA4E;CA4E;110D 1165 11A9;CA4E;110D 1165 11A9; 
    // (쩎; 쩎; 쩎; 쩎; 쩎; ) HANGUL SYLLABLE JJEOGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA4E }};
        std::array<char32_t, 1> const c2 = {{ 0xCA4E }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA4E }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_175)
{
    // CA4F;CA4F;110D 1165 11AA;CA4F;110D 1165 11AA; 
    // (쩏; 쩏; 쩏; 쩏; 쩏; ) HANGUL SYLLABLE JJEOGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA4F }};
        std::array<char32_t, 1> const c2 = {{ 0xCA4F }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xCA4F }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_176)
{
    // CA50;CA50;110D 1165 11AB;CA50;110D 1165 11AB; 
    // (쩐; 쩐; 쩐; 쩐; 쩐; ) HANGUL SYLLABLE JJEON
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA50 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA50 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xCA50 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_177)
{
    // CA51;CA51;110D 1165 11AC;CA51;110D 1165 11AC; 
    // (쩑; 쩑; 쩑; 쩑; 쩑; ) HANGUL SYLLABLE JJEONJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA51 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA51 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xCA51 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_178)
{
    // CA52;CA52;110D 1165 11AD;CA52;110D 1165 11AD; 
    // (쩒; 쩒; 쩒; 쩒; 쩒; ) HANGUL SYLLABLE JJEONH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA52 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA52 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xCA52 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_179)
{
    // CA53;CA53;110D 1165 11AE;CA53;110D 1165 11AE; 
    // (쩓; 쩓; 쩓; 쩓; 쩓; ) HANGUL SYLLABLE JJEOD
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA53 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA53 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xCA53 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_180)
{
    // CA54;CA54;110D 1165 11AF;CA54;110D 1165 11AF; 
    // (쩔; 쩔; 쩔; 쩔; 쩔; ) HANGUL SYLLABLE JJEOL
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA54 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA54 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xCA54 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_181)
{
    // CA55;CA55;110D 1165 11B0;CA55;110D 1165 11B0; 
    // (쩕; 쩕; 쩕; 쩕; 쩕; ) HANGUL SYLLABLE JJEOLG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA55 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA55 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA55 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_182)
{
    // CA56;CA56;110D 1165 11B1;CA56;110D 1165 11B1; 
    // (쩖; 쩖; 쩖; 쩖; 쩖; ) HANGUL SYLLABLE JJEOLM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA56 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA56 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA56 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_183)
{
    // CA57;CA57;110D 1165 11B2;CA57;110D 1165 11B2; 
    // (쩗; 쩗; 쩗; 쩗; 쩗; ) HANGUL SYLLABLE JJEOLB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA57 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA57 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA57 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_184)
{
    // CA58;CA58;110D 1165 11B3;CA58;110D 1165 11B3; 
    // (쩘; 쩘; 쩘; 쩘; 쩘; ) HANGUL SYLLABLE JJEOLS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA58 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA58 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA58 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_185)
{
    // CA59;CA59;110D 1165 11B4;CA59;110D 1165 11B4; 
    // (쩙; 쩙; 쩙; 쩙; 쩙; ) HANGUL SYLLABLE JJEOLT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA59 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA59 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA59 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_186)
{
    // CA5A;CA5A;110D 1165 11B5;CA5A;110D 1165 11B5; 
    // (쩚; 쩚; 쩚; 쩚; 쩚; ) HANGUL SYLLABLE JJEOLP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA5A }};
        std::array<char32_t, 1> const c2 = {{ 0xCA5A }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA5A }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_187)
{
    // CA5B;CA5B;110D 1165 11B6;CA5B;110D 1165 11B6; 
    // (쩛; 쩛; 쩛; 쩛; 쩛; ) HANGUL SYLLABLE JJEOLH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA5B }};
        std::array<char32_t, 1> const c2 = {{ 0xCA5B }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA5B }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_188)
{
    // CA5C;CA5C;110D 1165 11B7;CA5C;110D 1165 11B7; 
    // (쩜; 쩜; 쩜; 쩜; 쩜; ) HANGUL SYLLABLE JJEOM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA5C }};
        std::array<char32_t, 1> const c2 = {{ 0xCA5C }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA5C }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_189)
{
    // CA5D;CA5D;110D 1165 11B8;CA5D;110D 1165 11B8; 
    // (쩝; 쩝; 쩝; 쩝; 쩝; ) HANGUL SYLLABLE JJEOB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA5D }};
        std::array<char32_t, 1> const c2 = {{ 0xCA5D }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA5D }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_190)
{
    // CA5E;CA5E;110D 1165 11B9;CA5E;110D 1165 11B9; 
    // (쩞; 쩞; 쩞; 쩞; 쩞; ) HANGUL SYLLABLE JJEOBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA5E }};
        std::array<char32_t, 1> const c2 = {{ 0xCA5E }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA5E }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_191)
{
    // CA5F;CA5F;110D 1165 11BA;CA5F;110D 1165 11BA; 
    // (쩟; 쩟; 쩟; 쩟; 쩟; ) HANGUL SYLLABLE JJEOS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA5F }};
        std::array<char32_t, 1> const c2 = {{ 0xCA5F }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xCA5F }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_192)
{
    // CA60;CA60;110D 1165 11BB;CA60;110D 1165 11BB; 
    // (쩠; 쩠; 쩠; 쩠; 쩠; ) HANGUL SYLLABLE JJEOSS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA60 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA60 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xCA60 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_193)
{
    // CA61;CA61;110D 1165 11BC;CA61;110D 1165 11BC; 
    // (쩡; 쩡; 쩡; 쩡; 쩡; ) HANGUL SYLLABLE JJEONG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA61 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA61 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xCA61 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_194)
{
    // CA62;CA62;110D 1165 11BD;CA62;110D 1165 11BD; 
    // (쩢; 쩢; 쩢; 쩢; 쩢; ) HANGUL SYLLABLE JJEOJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA62 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA62 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xCA62 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_195)
{
    // CA63;CA63;110D 1165 11BE;CA63;110D 1165 11BE; 
    // (쩣; 쩣; 쩣; 쩣; 쩣; ) HANGUL SYLLABLE JJEOC
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA63 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA63 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xCA63 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_196)
{
    // CA64;CA64;110D 1165 11BF;CA64;110D 1165 11BF; 
    // (쩤; 쩤; 쩤; 쩤; 쩤; ) HANGUL SYLLABLE JJEOK
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA64 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA64 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xCA64 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_197)
{
    // CA65;CA65;110D 1165 11C0;CA65;110D 1165 11C0; 
    // (쩥; 쩥; 쩥; 쩥; 쩥; ) HANGUL SYLLABLE JJEOT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA65 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA65 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA65 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_198)
{
    // CA66;CA66;110D 1165 11C1;CA66;110D 1165 11C1; 
    // (쩦; 쩦; 쩦; 쩦; 쩦; ) HANGUL SYLLABLE JJEOP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA66 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA66 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA66 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_050_199)
{
    // CA67;CA67;110D 1165 11C2;CA67;110D 1165 11C2; 
    // (쩧; 쩧; 쩧; 쩧; 쩧; ) HANGUL SYLLABLE JJEOH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCA67 }};
        std::array<char32_t, 1> const c2 = {{ 0xCA67 }};
        std::array<char32_t, 3> const c3 = {{ 0x110D, 0x1165, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCA67 }};
        std::array<char32_t, 3> const c5 = {{ 0x110D, 0x1165, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


