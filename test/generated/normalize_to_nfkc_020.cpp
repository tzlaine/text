// Copyright (C) 2020 T. Zachary Laine
//
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

// Warning! This file is autogenerated.
#include <boost/text/normalize_string.hpp>
#include <boost/text/transcode_view.hpp>
#include <boost/text/string_utility.hpp>

#include <gtest/gtest.h>

#include <algorithm>



TEST(normalization, nfkc_020_000)
{
    // B230;B230;1102 116F 11B7;B230;1102 116F 11B7; 
    // (눰; 눰; 눰; 눰; 눰; ) HANGUL SYLLABLE NWEOM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB230 }};
        std::array<char32_t, 1> const c2 = {{ 0xB230 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x116F, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xB230 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x116F, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_001)
{
    // B231;B231;1102 116F 11B8;B231;1102 116F 11B8; 
    // (눱; 눱; 눱; 눱; 눱; ) HANGUL SYLLABLE NWEOB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB231 }};
        std::array<char32_t, 1> const c2 = {{ 0xB231 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x116F, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB231 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x116F, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_002)
{
    // B232;B232;1102 116F 11B9;B232;1102 116F 11B9; 
    // (눲; 눲; 눲; 눲; 눲; ) HANGUL SYLLABLE NWEOBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB232 }};
        std::array<char32_t, 1> const c2 = {{ 0xB232 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x116F, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB232 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x116F, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_003)
{
    // B233;B233;1102 116F 11BA;B233;1102 116F 11BA; 
    // (눳; 눳; 눳; 눳; 눳; ) HANGUL SYLLABLE NWEOS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB233 }};
        std::array<char32_t, 1> const c2 = {{ 0xB233 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x116F, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xB233 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x116F, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_004)
{
    // B234;B234;1102 116F 11BB;B234;1102 116F 11BB; 
    // (눴; 눴; 눴; 눴; 눴; ) HANGUL SYLLABLE NWEOSS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB234 }};
        std::array<char32_t, 1> const c2 = {{ 0xB234 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x116F, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xB234 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x116F, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_005)
{
    // B235;B235;1102 116F 11BC;B235;1102 116F 11BC; 
    // (눵; 눵; 눵; 눵; 눵; ) HANGUL SYLLABLE NWEONG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB235 }};
        std::array<char32_t, 1> const c2 = {{ 0xB235 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x116F, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xB235 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x116F, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_006)
{
    // B236;B236;1102 116F 11BD;B236;1102 116F 11BD; 
    // (눶; 눶; 눶; 눶; 눶; ) HANGUL SYLLABLE NWEOJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB236 }};
        std::array<char32_t, 1> const c2 = {{ 0xB236 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x116F, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xB236 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x116F, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_007)
{
    // B237;B237;1102 116F 11BE;B237;1102 116F 11BE; 
    // (눷; 눷; 눷; 눷; 눷; ) HANGUL SYLLABLE NWEOC
    {
        std::array<char32_t, 1> const c1 = {{ 0xB237 }};
        std::array<char32_t, 1> const c2 = {{ 0xB237 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x116F, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xB237 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x116F, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_008)
{
    // B238;B238;1102 116F 11BF;B238;1102 116F 11BF; 
    // (눸; 눸; 눸; 눸; 눸; ) HANGUL SYLLABLE NWEOK
    {
        std::array<char32_t, 1> const c1 = {{ 0xB238 }};
        std::array<char32_t, 1> const c2 = {{ 0xB238 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x116F, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xB238 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x116F, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_009)
{
    // B239;B239;1102 116F 11C0;B239;1102 116F 11C0; 
    // (눹; 눹; 눹; 눹; 눹; ) HANGUL SYLLABLE NWEOT
    {
        std::array<char32_t, 1> const c1 = {{ 0xB239 }};
        std::array<char32_t, 1> const c2 = {{ 0xB239 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x116F, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB239 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x116F, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_010)
{
    // B23A;B23A;1102 116F 11C1;B23A;1102 116F 11C1; 
    // (눺; 눺; 눺; 눺; 눺; ) HANGUL SYLLABLE NWEOP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB23A }};
        std::array<char32_t, 1> const c2 = {{ 0xB23A }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x116F, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB23A }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x116F, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_011)
{
    // B23B;B23B;1102 116F 11C2;B23B;1102 116F 11C2; 
    // (눻; 눻; 눻; 눻; 눻; ) HANGUL SYLLABLE NWEOH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB23B }};
        std::array<char32_t, 1> const c2 = {{ 0xB23B }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x116F, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB23B }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x116F, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_012)
{
    // B23C;B23C;1102 1170;B23C;1102 1170; 
    // (눼; 눼; 눼; 눼; 눼; ) HANGUL SYLLABLE NWE
    {
        std::array<char32_t, 1> const c1 = {{ 0xB23C }};
        std::array<char32_t, 1> const c2 = {{ 0xB23C }};
        std::array<char32_t, 2> const c3 = {{ 0x1102, 0x1170 }};
        std::array<char32_t, 1> const c4 = {{ 0xB23C }};
        std::array<char32_t, 2> const c5 = {{ 0x1102, 0x1170 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_013)
{
    // B23D;B23D;1102 1170 11A8;B23D;1102 1170 11A8; 
    // (눽; 눽; 눽; 눽; 눽; ) HANGUL SYLLABLE NWEG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB23D }};
        std::array<char32_t, 1> const c2 = {{ 0xB23D }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB23D }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_014)
{
    // B23E;B23E;1102 1170 11A9;B23E;1102 1170 11A9; 
    // (눾; 눾; 눾; 눾; 눾; ) HANGUL SYLLABLE NWEGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB23E }};
        std::array<char32_t, 1> const c2 = {{ 0xB23E }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB23E }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_015)
{
    // B23F;B23F;1102 1170 11AA;B23F;1102 1170 11AA; 
    // (눿; 눿; 눿; 눿; 눿; ) HANGUL SYLLABLE NWEGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB23F }};
        std::array<char32_t, 1> const c2 = {{ 0xB23F }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xB23F }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_016)
{
    // B240;B240;1102 1170 11AB;B240;1102 1170 11AB; 
    // (뉀; 뉀; 뉀; 뉀; 뉀; ) HANGUL SYLLABLE NWEN
    {
        std::array<char32_t, 1> const c1 = {{ 0xB240 }};
        std::array<char32_t, 1> const c2 = {{ 0xB240 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xB240 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_017)
{
    // B241;B241;1102 1170 11AC;B241;1102 1170 11AC; 
    // (뉁; 뉁; 뉁; 뉁; 뉁; ) HANGUL SYLLABLE NWENJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB241 }};
        std::array<char32_t, 1> const c2 = {{ 0xB241 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xB241 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_018)
{
    // B242;B242;1102 1170 11AD;B242;1102 1170 11AD; 
    // (뉂; 뉂; 뉂; 뉂; 뉂; ) HANGUL SYLLABLE NWENH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB242 }};
        std::array<char32_t, 1> const c2 = {{ 0xB242 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xB242 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_019)
{
    // B243;B243;1102 1170 11AE;B243;1102 1170 11AE; 
    // (뉃; 뉃; 뉃; 뉃; 뉃; ) HANGUL SYLLABLE NWED
    {
        std::array<char32_t, 1> const c1 = {{ 0xB243 }};
        std::array<char32_t, 1> const c2 = {{ 0xB243 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xB243 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_020)
{
    // B244;B244;1102 1170 11AF;B244;1102 1170 11AF; 
    // (뉄; 뉄; 뉄; 뉄; 뉄; ) HANGUL SYLLABLE NWEL
    {
        std::array<char32_t, 1> const c1 = {{ 0xB244 }};
        std::array<char32_t, 1> const c2 = {{ 0xB244 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xB244 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_021)
{
    // B245;B245;1102 1170 11B0;B245;1102 1170 11B0; 
    // (뉅; 뉅; 뉅; 뉅; 뉅; ) HANGUL SYLLABLE NWELG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB245 }};
        std::array<char32_t, 1> const c2 = {{ 0xB245 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB245 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_022)
{
    // B246;B246;1102 1170 11B1;B246;1102 1170 11B1; 
    // (뉆; 뉆; 뉆; 뉆; 뉆; ) HANGUL SYLLABLE NWELM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB246 }};
        std::array<char32_t, 1> const c2 = {{ 0xB246 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB246 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_023)
{
    // B247;B247;1102 1170 11B2;B247;1102 1170 11B2; 
    // (뉇; 뉇; 뉇; 뉇; 뉇; ) HANGUL SYLLABLE NWELB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB247 }};
        std::array<char32_t, 1> const c2 = {{ 0xB247 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB247 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_024)
{
    // B248;B248;1102 1170 11B3;B248;1102 1170 11B3; 
    // (뉈; 뉈; 뉈; 뉈; 뉈; ) HANGUL SYLLABLE NWELS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB248 }};
        std::array<char32_t, 1> const c2 = {{ 0xB248 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xB248 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_025)
{
    // B249;B249;1102 1170 11B4;B249;1102 1170 11B4; 
    // (뉉; 뉉; 뉉; 뉉; 뉉; ) HANGUL SYLLABLE NWELT
    {
        std::array<char32_t, 1> const c1 = {{ 0xB249 }};
        std::array<char32_t, 1> const c2 = {{ 0xB249 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xB249 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_026)
{
    // B24A;B24A;1102 1170 11B5;B24A;1102 1170 11B5; 
    // (뉊; 뉊; 뉊; 뉊; 뉊; ) HANGUL SYLLABLE NWELP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB24A }};
        std::array<char32_t, 1> const c2 = {{ 0xB24A }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xB24A }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_027)
{
    // B24B;B24B;1102 1170 11B6;B24B;1102 1170 11B6; 
    // (뉋; 뉋; 뉋; 뉋; 뉋; ) HANGUL SYLLABLE NWELH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB24B }};
        std::array<char32_t, 1> const c2 = {{ 0xB24B }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xB24B }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_028)
{
    // B24C;B24C;1102 1170 11B7;B24C;1102 1170 11B7; 
    // (뉌; 뉌; 뉌; 뉌; 뉌; ) HANGUL SYLLABLE NWEM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB24C }};
        std::array<char32_t, 1> const c2 = {{ 0xB24C }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xB24C }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_029)
{
    // B24D;B24D;1102 1170 11B8;B24D;1102 1170 11B8; 
    // (뉍; 뉍; 뉍; 뉍; 뉍; ) HANGUL SYLLABLE NWEB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB24D }};
        std::array<char32_t, 1> const c2 = {{ 0xB24D }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB24D }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_030)
{
    // B24E;B24E;1102 1170 11B9;B24E;1102 1170 11B9; 
    // (뉎; 뉎; 뉎; 뉎; 뉎; ) HANGUL SYLLABLE NWEBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB24E }};
        std::array<char32_t, 1> const c2 = {{ 0xB24E }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB24E }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_031)
{
    // B24F;B24F;1102 1170 11BA;B24F;1102 1170 11BA; 
    // (뉏; 뉏; 뉏; 뉏; 뉏; ) HANGUL SYLLABLE NWES
    {
        std::array<char32_t, 1> const c1 = {{ 0xB24F }};
        std::array<char32_t, 1> const c2 = {{ 0xB24F }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xB24F }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_032)
{
    // B250;B250;1102 1170 11BB;B250;1102 1170 11BB; 
    // (뉐; 뉐; 뉐; 뉐; 뉐; ) HANGUL SYLLABLE NWESS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB250 }};
        std::array<char32_t, 1> const c2 = {{ 0xB250 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xB250 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_033)
{
    // B251;B251;1102 1170 11BC;B251;1102 1170 11BC; 
    // (뉑; 뉑; 뉑; 뉑; 뉑; ) HANGUL SYLLABLE NWENG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB251 }};
        std::array<char32_t, 1> const c2 = {{ 0xB251 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xB251 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_034)
{
    // B252;B252;1102 1170 11BD;B252;1102 1170 11BD; 
    // (뉒; 뉒; 뉒; 뉒; 뉒; ) HANGUL SYLLABLE NWEJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB252 }};
        std::array<char32_t, 1> const c2 = {{ 0xB252 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xB252 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_035)
{
    // B253;B253;1102 1170 11BE;B253;1102 1170 11BE; 
    // (뉓; 뉓; 뉓; 뉓; 뉓; ) HANGUL SYLLABLE NWEC
    {
        std::array<char32_t, 1> const c1 = {{ 0xB253 }};
        std::array<char32_t, 1> const c2 = {{ 0xB253 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xB253 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_036)
{
    // B254;B254;1102 1170 11BF;B254;1102 1170 11BF; 
    // (뉔; 뉔; 뉔; 뉔; 뉔; ) HANGUL SYLLABLE NWEK
    {
        std::array<char32_t, 1> const c1 = {{ 0xB254 }};
        std::array<char32_t, 1> const c2 = {{ 0xB254 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xB254 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_037)
{
    // B255;B255;1102 1170 11C0;B255;1102 1170 11C0; 
    // (뉕; 뉕; 뉕; 뉕; 뉕; ) HANGUL SYLLABLE NWET
    {
        std::array<char32_t, 1> const c1 = {{ 0xB255 }};
        std::array<char32_t, 1> const c2 = {{ 0xB255 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB255 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_038)
{
    // B256;B256;1102 1170 11C1;B256;1102 1170 11C1; 
    // (뉖; 뉖; 뉖; 뉖; 뉖; ) HANGUL SYLLABLE NWEP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB256 }};
        std::array<char32_t, 1> const c2 = {{ 0xB256 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB256 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_039)
{
    // B257;B257;1102 1170 11C2;B257;1102 1170 11C2; 
    // (뉗; 뉗; 뉗; 뉗; 뉗; ) HANGUL SYLLABLE NWEH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB257 }};
        std::array<char32_t, 1> const c2 = {{ 0xB257 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1170, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB257 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1170, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_040)
{
    // B258;B258;1102 1171;B258;1102 1171; 
    // (뉘; 뉘; 뉘; 뉘; 뉘; ) HANGUL SYLLABLE NWI
    {
        std::array<char32_t, 1> const c1 = {{ 0xB258 }};
        std::array<char32_t, 1> const c2 = {{ 0xB258 }};
        std::array<char32_t, 2> const c3 = {{ 0x1102, 0x1171 }};
        std::array<char32_t, 1> const c4 = {{ 0xB258 }};
        std::array<char32_t, 2> const c5 = {{ 0x1102, 0x1171 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_041)
{
    // B259;B259;1102 1171 11A8;B259;1102 1171 11A8; 
    // (뉙; 뉙; 뉙; 뉙; 뉙; ) HANGUL SYLLABLE NWIG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB259 }};
        std::array<char32_t, 1> const c2 = {{ 0xB259 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB259 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_042)
{
    // B25A;B25A;1102 1171 11A9;B25A;1102 1171 11A9; 
    // (뉚; 뉚; 뉚; 뉚; 뉚; ) HANGUL SYLLABLE NWIGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB25A }};
        std::array<char32_t, 1> const c2 = {{ 0xB25A }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB25A }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_043)
{
    // B25B;B25B;1102 1171 11AA;B25B;1102 1171 11AA; 
    // (뉛; 뉛; 뉛; 뉛; 뉛; ) HANGUL SYLLABLE NWIGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB25B }};
        std::array<char32_t, 1> const c2 = {{ 0xB25B }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xB25B }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_044)
{
    // B25C;B25C;1102 1171 11AB;B25C;1102 1171 11AB; 
    // (뉜; 뉜; 뉜; 뉜; 뉜; ) HANGUL SYLLABLE NWIN
    {
        std::array<char32_t, 1> const c1 = {{ 0xB25C }};
        std::array<char32_t, 1> const c2 = {{ 0xB25C }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xB25C }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_045)
{
    // B25D;B25D;1102 1171 11AC;B25D;1102 1171 11AC; 
    // (뉝; 뉝; 뉝; 뉝; 뉝; ) HANGUL SYLLABLE NWINJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB25D }};
        std::array<char32_t, 1> const c2 = {{ 0xB25D }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xB25D }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_046)
{
    // B25E;B25E;1102 1171 11AD;B25E;1102 1171 11AD; 
    // (뉞; 뉞; 뉞; 뉞; 뉞; ) HANGUL SYLLABLE NWINH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB25E }};
        std::array<char32_t, 1> const c2 = {{ 0xB25E }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xB25E }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_047)
{
    // B25F;B25F;1102 1171 11AE;B25F;1102 1171 11AE; 
    // (뉟; 뉟; 뉟; 뉟; 뉟; ) HANGUL SYLLABLE NWID
    {
        std::array<char32_t, 1> const c1 = {{ 0xB25F }};
        std::array<char32_t, 1> const c2 = {{ 0xB25F }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xB25F }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_048)
{
    // B260;B260;1102 1171 11AF;B260;1102 1171 11AF; 
    // (뉠; 뉠; 뉠; 뉠; 뉠; ) HANGUL SYLLABLE NWIL
    {
        std::array<char32_t, 1> const c1 = {{ 0xB260 }};
        std::array<char32_t, 1> const c2 = {{ 0xB260 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xB260 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_049)
{
    // B261;B261;1102 1171 11B0;B261;1102 1171 11B0; 
    // (뉡; 뉡; 뉡; 뉡; 뉡; ) HANGUL SYLLABLE NWILG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB261 }};
        std::array<char32_t, 1> const c2 = {{ 0xB261 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB261 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_050)
{
    // B262;B262;1102 1171 11B1;B262;1102 1171 11B1; 
    // (뉢; 뉢; 뉢; 뉢; 뉢; ) HANGUL SYLLABLE NWILM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB262 }};
        std::array<char32_t, 1> const c2 = {{ 0xB262 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB262 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_051)
{
    // B263;B263;1102 1171 11B2;B263;1102 1171 11B2; 
    // (뉣; 뉣; 뉣; 뉣; 뉣; ) HANGUL SYLLABLE NWILB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB263 }};
        std::array<char32_t, 1> const c2 = {{ 0xB263 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB263 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_052)
{
    // B264;B264;1102 1171 11B3;B264;1102 1171 11B3; 
    // (뉤; 뉤; 뉤; 뉤; 뉤; ) HANGUL SYLLABLE NWILS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB264 }};
        std::array<char32_t, 1> const c2 = {{ 0xB264 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xB264 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_053)
{
    // B265;B265;1102 1171 11B4;B265;1102 1171 11B4; 
    // (뉥; 뉥; 뉥; 뉥; 뉥; ) HANGUL SYLLABLE NWILT
    {
        std::array<char32_t, 1> const c1 = {{ 0xB265 }};
        std::array<char32_t, 1> const c2 = {{ 0xB265 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xB265 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_054)
{
    // B266;B266;1102 1171 11B5;B266;1102 1171 11B5; 
    // (뉦; 뉦; 뉦; 뉦; 뉦; ) HANGUL SYLLABLE NWILP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB266 }};
        std::array<char32_t, 1> const c2 = {{ 0xB266 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xB266 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_055)
{
    // B267;B267;1102 1171 11B6;B267;1102 1171 11B6; 
    // (뉧; 뉧; 뉧; 뉧; 뉧; ) HANGUL SYLLABLE NWILH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB267 }};
        std::array<char32_t, 1> const c2 = {{ 0xB267 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xB267 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_056)
{
    // B268;B268;1102 1171 11B7;B268;1102 1171 11B7; 
    // (뉨; 뉨; 뉨; 뉨; 뉨; ) HANGUL SYLLABLE NWIM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB268 }};
        std::array<char32_t, 1> const c2 = {{ 0xB268 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xB268 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_057)
{
    // B269;B269;1102 1171 11B8;B269;1102 1171 11B8; 
    // (뉩; 뉩; 뉩; 뉩; 뉩; ) HANGUL SYLLABLE NWIB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB269 }};
        std::array<char32_t, 1> const c2 = {{ 0xB269 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB269 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_058)
{
    // B26A;B26A;1102 1171 11B9;B26A;1102 1171 11B9; 
    // (뉪; 뉪; 뉪; 뉪; 뉪; ) HANGUL SYLLABLE NWIBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB26A }};
        std::array<char32_t, 1> const c2 = {{ 0xB26A }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB26A }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_059)
{
    // B26B;B26B;1102 1171 11BA;B26B;1102 1171 11BA; 
    // (뉫; 뉫; 뉫; 뉫; 뉫; ) HANGUL SYLLABLE NWIS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB26B }};
        std::array<char32_t, 1> const c2 = {{ 0xB26B }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xB26B }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_060)
{
    // B26C;B26C;1102 1171 11BB;B26C;1102 1171 11BB; 
    // (뉬; 뉬; 뉬; 뉬; 뉬; ) HANGUL SYLLABLE NWISS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB26C }};
        std::array<char32_t, 1> const c2 = {{ 0xB26C }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xB26C }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_061)
{
    // B26D;B26D;1102 1171 11BC;B26D;1102 1171 11BC; 
    // (뉭; 뉭; 뉭; 뉭; 뉭; ) HANGUL SYLLABLE NWING
    {
        std::array<char32_t, 1> const c1 = {{ 0xB26D }};
        std::array<char32_t, 1> const c2 = {{ 0xB26D }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xB26D }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_062)
{
    // B26E;B26E;1102 1171 11BD;B26E;1102 1171 11BD; 
    // (뉮; 뉮; 뉮; 뉮; 뉮; ) HANGUL SYLLABLE NWIJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB26E }};
        std::array<char32_t, 1> const c2 = {{ 0xB26E }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xB26E }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_063)
{
    // B26F;B26F;1102 1171 11BE;B26F;1102 1171 11BE; 
    // (뉯; 뉯; 뉯; 뉯; 뉯; ) HANGUL SYLLABLE NWIC
    {
        std::array<char32_t, 1> const c1 = {{ 0xB26F }};
        std::array<char32_t, 1> const c2 = {{ 0xB26F }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xB26F }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_064)
{
    // B270;B270;1102 1171 11BF;B270;1102 1171 11BF; 
    // (뉰; 뉰; 뉰; 뉰; 뉰; ) HANGUL SYLLABLE NWIK
    {
        std::array<char32_t, 1> const c1 = {{ 0xB270 }};
        std::array<char32_t, 1> const c2 = {{ 0xB270 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xB270 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_065)
{
    // B271;B271;1102 1171 11C0;B271;1102 1171 11C0; 
    // (뉱; 뉱; 뉱; 뉱; 뉱; ) HANGUL SYLLABLE NWIT
    {
        std::array<char32_t, 1> const c1 = {{ 0xB271 }};
        std::array<char32_t, 1> const c2 = {{ 0xB271 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB271 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_066)
{
    // B272;B272;1102 1171 11C1;B272;1102 1171 11C1; 
    // (뉲; 뉲; 뉲; 뉲; 뉲; ) HANGUL SYLLABLE NWIP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB272 }};
        std::array<char32_t, 1> const c2 = {{ 0xB272 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB272 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_067)
{
    // B273;B273;1102 1171 11C2;B273;1102 1171 11C2; 
    // (뉳; 뉳; 뉳; 뉳; 뉳; ) HANGUL SYLLABLE NWIH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB273 }};
        std::array<char32_t, 1> const c2 = {{ 0xB273 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1171, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB273 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1171, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_068)
{
    // B274;B274;1102 1172;B274;1102 1172; 
    // (뉴; 뉴; 뉴; 뉴; 뉴; ) HANGUL SYLLABLE NYU
    {
        std::array<char32_t, 1> const c1 = {{ 0xB274 }};
        std::array<char32_t, 1> const c2 = {{ 0xB274 }};
        std::array<char32_t, 2> const c3 = {{ 0x1102, 0x1172 }};
        std::array<char32_t, 1> const c4 = {{ 0xB274 }};
        std::array<char32_t, 2> const c5 = {{ 0x1102, 0x1172 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_069)
{
    // B275;B275;1102 1172 11A8;B275;1102 1172 11A8; 
    // (뉵; 뉵; 뉵; 뉵; 뉵; ) HANGUL SYLLABLE NYUG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB275 }};
        std::array<char32_t, 1> const c2 = {{ 0xB275 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB275 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_070)
{
    // B276;B276;1102 1172 11A9;B276;1102 1172 11A9; 
    // (뉶; 뉶; 뉶; 뉶; 뉶; ) HANGUL SYLLABLE NYUGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB276 }};
        std::array<char32_t, 1> const c2 = {{ 0xB276 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB276 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_071)
{
    // B277;B277;1102 1172 11AA;B277;1102 1172 11AA; 
    // (뉷; 뉷; 뉷; 뉷; 뉷; ) HANGUL SYLLABLE NYUGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB277 }};
        std::array<char32_t, 1> const c2 = {{ 0xB277 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xB277 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_072)
{
    // B278;B278;1102 1172 11AB;B278;1102 1172 11AB; 
    // (뉸; 뉸; 뉸; 뉸; 뉸; ) HANGUL SYLLABLE NYUN
    {
        std::array<char32_t, 1> const c1 = {{ 0xB278 }};
        std::array<char32_t, 1> const c2 = {{ 0xB278 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xB278 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_073)
{
    // B279;B279;1102 1172 11AC;B279;1102 1172 11AC; 
    // (뉹; 뉹; 뉹; 뉹; 뉹; ) HANGUL SYLLABLE NYUNJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB279 }};
        std::array<char32_t, 1> const c2 = {{ 0xB279 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xB279 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_074)
{
    // B27A;B27A;1102 1172 11AD;B27A;1102 1172 11AD; 
    // (뉺; 뉺; 뉺; 뉺; 뉺; ) HANGUL SYLLABLE NYUNH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB27A }};
        std::array<char32_t, 1> const c2 = {{ 0xB27A }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xB27A }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_075)
{
    // B27B;B27B;1102 1172 11AE;B27B;1102 1172 11AE; 
    // (뉻; 뉻; 뉻; 뉻; 뉻; ) HANGUL SYLLABLE NYUD
    {
        std::array<char32_t, 1> const c1 = {{ 0xB27B }};
        std::array<char32_t, 1> const c2 = {{ 0xB27B }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xB27B }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_076)
{
    // B27C;B27C;1102 1172 11AF;B27C;1102 1172 11AF; 
    // (뉼; 뉼; 뉼; 뉼; 뉼; ) HANGUL SYLLABLE NYUL
    {
        std::array<char32_t, 1> const c1 = {{ 0xB27C }};
        std::array<char32_t, 1> const c2 = {{ 0xB27C }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xB27C }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_077)
{
    // B27D;B27D;1102 1172 11B0;B27D;1102 1172 11B0; 
    // (뉽; 뉽; 뉽; 뉽; 뉽; ) HANGUL SYLLABLE NYULG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB27D }};
        std::array<char32_t, 1> const c2 = {{ 0xB27D }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB27D }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_078)
{
    // B27E;B27E;1102 1172 11B1;B27E;1102 1172 11B1; 
    // (뉾; 뉾; 뉾; 뉾; 뉾; ) HANGUL SYLLABLE NYULM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB27E }};
        std::array<char32_t, 1> const c2 = {{ 0xB27E }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB27E }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_079)
{
    // B27F;B27F;1102 1172 11B2;B27F;1102 1172 11B2; 
    // (뉿; 뉿; 뉿; 뉿; 뉿; ) HANGUL SYLLABLE NYULB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB27F }};
        std::array<char32_t, 1> const c2 = {{ 0xB27F }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB27F }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_080)
{
    // B280;B280;1102 1172 11B3;B280;1102 1172 11B3; 
    // (늀; 늀; 늀; 늀; 늀; ) HANGUL SYLLABLE NYULS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB280 }};
        std::array<char32_t, 1> const c2 = {{ 0xB280 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xB280 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_081)
{
    // B281;B281;1102 1172 11B4;B281;1102 1172 11B4; 
    // (늁; 늁; 늁; 늁; 늁; ) HANGUL SYLLABLE NYULT
    {
        std::array<char32_t, 1> const c1 = {{ 0xB281 }};
        std::array<char32_t, 1> const c2 = {{ 0xB281 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xB281 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_082)
{
    // B282;B282;1102 1172 11B5;B282;1102 1172 11B5; 
    // (늂; 늂; 늂; 늂; 늂; ) HANGUL SYLLABLE NYULP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB282 }};
        std::array<char32_t, 1> const c2 = {{ 0xB282 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xB282 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_083)
{
    // B283;B283;1102 1172 11B6;B283;1102 1172 11B6; 
    // (늃; 늃; 늃; 늃; 늃; ) HANGUL SYLLABLE NYULH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB283 }};
        std::array<char32_t, 1> const c2 = {{ 0xB283 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xB283 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_084)
{
    // B284;B284;1102 1172 11B7;B284;1102 1172 11B7; 
    // (늄; 늄; 늄; 늄; 늄; ) HANGUL SYLLABLE NYUM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB284 }};
        std::array<char32_t, 1> const c2 = {{ 0xB284 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xB284 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_085)
{
    // B285;B285;1102 1172 11B8;B285;1102 1172 11B8; 
    // (늅; 늅; 늅; 늅; 늅; ) HANGUL SYLLABLE NYUB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB285 }};
        std::array<char32_t, 1> const c2 = {{ 0xB285 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB285 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_086)
{
    // B286;B286;1102 1172 11B9;B286;1102 1172 11B9; 
    // (늆; 늆; 늆; 늆; 늆; ) HANGUL SYLLABLE NYUBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB286 }};
        std::array<char32_t, 1> const c2 = {{ 0xB286 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB286 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_087)
{
    // B287;B287;1102 1172 11BA;B287;1102 1172 11BA; 
    // (늇; 늇; 늇; 늇; 늇; ) HANGUL SYLLABLE NYUS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB287 }};
        std::array<char32_t, 1> const c2 = {{ 0xB287 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xB287 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_088)
{
    // B288;B288;1102 1172 11BB;B288;1102 1172 11BB; 
    // (늈; 늈; 늈; 늈; 늈; ) HANGUL SYLLABLE NYUSS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB288 }};
        std::array<char32_t, 1> const c2 = {{ 0xB288 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xB288 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_089)
{
    // B289;B289;1102 1172 11BC;B289;1102 1172 11BC; 
    // (늉; 늉; 늉; 늉; 늉; ) HANGUL SYLLABLE NYUNG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB289 }};
        std::array<char32_t, 1> const c2 = {{ 0xB289 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xB289 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_090)
{
    // B28A;B28A;1102 1172 11BD;B28A;1102 1172 11BD; 
    // (늊; 늊; 늊; 늊; 늊; ) HANGUL SYLLABLE NYUJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB28A }};
        std::array<char32_t, 1> const c2 = {{ 0xB28A }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xB28A }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_091)
{
    // B28B;B28B;1102 1172 11BE;B28B;1102 1172 11BE; 
    // (늋; 늋; 늋; 늋; 늋; ) HANGUL SYLLABLE NYUC
    {
        std::array<char32_t, 1> const c1 = {{ 0xB28B }};
        std::array<char32_t, 1> const c2 = {{ 0xB28B }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xB28B }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_092)
{
    // B28C;B28C;1102 1172 11BF;B28C;1102 1172 11BF; 
    // (늌; 늌; 늌; 늌; 늌; ) HANGUL SYLLABLE NYUK
    {
        std::array<char32_t, 1> const c1 = {{ 0xB28C }};
        std::array<char32_t, 1> const c2 = {{ 0xB28C }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xB28C }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_093)
{
    // B28D;B28D;1102 1172 11C0;B28D;1102 1172 11C0; 
    // (늍; 늍; 늍; 늍; 늍; ) HANGUL SYLLABLE NYUT
    {
        std::array<char32_t, 1> const c1 = {{ 0xB28D }};
        std::array<char32_t, 1> const c2 = {{ 0xB28D }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB28D }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_094)
{
    // B28E;B28E;1102 1172 11C1;B28E;1102 1172 11C1; 
    // (늎; 늎; 늎; 늎; 늎; ) HANGUL SYLLABLE NYUP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB28E }};
        std::array<char32_t, 1> const c2 = {{ 0xB28E }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB28E }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_095)
{
    // B28F;B28F;1102 1172 11C2;B28F;1102 1172 11C2; 
    // (늏; 늏; 늏; 늏; 늏; ) HANGUL SYLLABLE NYUH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB28F }};
        std::array<char32_t, 1> const c2 = {{ 0xB28F }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1172, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB28F }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1172, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_096)
{
    // B290;B290;1102 1173;B290;1102 1173; 
    // (느; 느; 느; 느; 느; ) HANGUL SYLLABLE NEU
    {
        std::array<char32_t, 1> const c1 = {{ 0xB290 }};
        std::array<char32_t, 1> const c2 = {{ 0xB290 }};
        std::array<char32_t, 2> const c3 = {{ 0x1102, 0x1173 }};
        std::array<char32_t, 1> const c4 = {{ 0xB290 }};
        std::array<char32_t, 2> const c5 = {{ 0x1102, 0x1173 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_097)
{
    // B291;B291;1102 1173 11A8;B291;1102 1173 11A8; 
    // (늑; 늑; 늑; 늑; 늑; ) HANGUL SYLLABLE NEUG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB291 }};
        std::array<char32_t, 1> const c2 = {{ 0xB291 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB291 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_098)
{
    // B292;B292;1102 1173 11A9;B292;1102 1173 11A9; 
    // (늒; 늒; 늒; 늒; 늒; ) HANGUL SYLLABLE NEUGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB292 }};
        std::array<char32_t, 1> const c2 = {{ 0xB292 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB292 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_099)
{
    // B293;B293;1102 1173 11AA;B293;1102 1173 11AA; 
    // (늓; 늓; 늓; 늓; 늓; ) HANGUL SYLLABLE NEUGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB293 }};
        std::array<char32_t, 1> const c2 = {{ 0xB293 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xB293 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_100)
{
    // B294;B294;1102 1173 11AB;B294;1102 1173 11AB; 
    // (는; 는; 는; 는; 는; ) HANGUL SYLLABLE NEUN
    {
        std::array<char32_t, 1> const c1 = {{ 0xB294 }};
        std::array<char32_t, 1> const c2 = {{ 0xB294 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xB294 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_101)
{
    // B295;B295;1102 1173 11AC;B295;1102 1173 11AC; 
    // (늕; 늕; 늕; 늕; 늕; ) HANGUL SYLLABLE NEUNJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB295 }};
        std::array<char32_t, 1> const c2 = {{ 0xB295 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xB295 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_102)
{
    // B296;B296;1102 1173 11AD;B296;1102 1173 11AD; 
    // (늖; 늖; 늖; 늖; 늖; ) HANGUL SYLLABLE NEUNH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB296 }};
        std::array<char32_t, 1> const c2 = {{ 0xB296 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xB296 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_103)
{
    // B297;B297;1102 1173 11AE;B297;1102 1173 11AE; 
    // (늗; 늗; 늗; 늗; 늗; ) HANGUL SYLLABLE NEUD
    {
        std::array<char32_t, 1> const c1 = {{ 0xB297 }};
        std::array<char32_t, 1> const c2 = {{ 0xB297 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xB297 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_104)
{
    // B298;B298;1102 1173 11AF;B298;1102 1173 11AF; 
    // (늘; 늘; 늘; 늘; 늘; ) HANGUL SYLLABLE NEUL
    {
        std::array<char32_t, 1> const c1 = {{ 0xB298 }};
        std::array<char32_t, 1> const c2 = {{ 0xB298 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xB298 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_105)
{
    // B299;B299;1102 1173 11B0;B299;1102 1173 11B0; 
    // (늙; 늙; 늙; 늙; 늙; ) HANGUL SYLLABLE NEULG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB299 }};
        std::array<char32_t, 1> const c2 = {{ 0xB299 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB299 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_106)
{
    // B29A;B29A;1102 1173 11B1;B29A;1102 1173 11B1; 
    // (늚; 늚; 늚; 늚; 늚; ) HANGUL SYLLABLE NEULM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB29A }};
        std::array<char32_t, 1> const c2 = {{ 0xB29A }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB29A }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_107)
{
    // B29B;B29B;1102 1173 11B2;B29B;1102 1173 11B2; 
    // (늛; 늛; 늛; 늛; 늛; ) HANGUL SYLLABLE NEULB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB29B }};
        std::array<char32_t, 1> const c2 = {{ 0xB29B }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB29B }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_108)
{
    // B29C;B29C;1102 1173 11B3;B29C;1102 1173 11B3; 
    // (늜; 늜; 늜; 늜; 늜; ) HANGUL SYLLABLE NEULS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB29C }};
        std::array<char32_t, 1> const c2 = {{ 0xB29C }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xB29C }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_109)
{
    // B29D;B29D;1102 1173 11B4;B29D;1102 1173 11B4; 
    // (늝; 늝; 늝; 늝; 늝; ) HANGUL SYLLABLE NEULT
    {
        std::array<char32_t, 1> const c1 = {{ 0xB29D }};
        std::array<char32_t, 1> const c2 = {{ 0xB29D }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xB29D }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_110)
{
    // B29E;B29E;1102 1173 11B5;B29E;1102 1173 11B5; 
    // (늞; 늞; 늞; 늞; 늞; ) HANGUL SYLLABLE NEULP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB29E }};
        std::array<char32_t, 1> const c2 = {{ 0xB29E }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xB29E }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_111)
{
    // B29F;B29F;1102 1173 11B6;B29F;1102 1173 11B6; 
    // (늟; 늟; 늟; 늟; 늟; ) HANGUL SYLLABLE NEULH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB29F }};
        std::array<char32_t, 1> const c2 = {{ 0xB29F }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xB29F }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_112)
{
    // B2A0;B2A0;1102 1173 11B7;B2A0;1102 1173 11B7; 
    // (늠; 늠; 늠; 늠; 늠; ) HANGUL SYLLABLE NEUM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2A0 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2A0 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2A0 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_113)
{
    // B2A1;B2A1;1102 1173 11B8;B2A1;1102 1173 11B8; 
    // (늡; 늡; 늡; 늡; 늡; ) HANGUL SYLLABLE NEUB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2A1 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2A1 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2A1 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_114)
{
    // B2A2;B2A2;1102 1173 11B9;B2A2;1102 1173 11B9; 
    // (늢; 늢; 늢; 늢; 늢; ) HANGUL SYLLABLE NEUBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2A2 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2A2 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2A2 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_115)
{
    // B2A3;B2A3;1102 1173 11BA;B2A3;1102 1173 11BA; 
    // (늣; 늣; 늣; 늣; 늣; ) HANGUL SYLLABLE NEUS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2A3 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2A3 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xB2A3 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_116)
{
    // B2A4;B2A4;1102 1173 11BB;B2A4;1102 1173 11BB; 
    // (늤; 늤; 늤; 늤; 늤; ) HANGUL SYLLABLE NEUSS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2A4 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2A4 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xB2A4 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_117)
{
    // B2A5;B2A5;1102 1173 11BC;B2A5;1102 1173 11BC; 
    // (능; 능; 능; 능; 능; ) HANGUL SYLLABLE NEUNG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2A5 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2A5 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xB2A5 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_118)
{
    // B2A6;B2A6;1102 1173 11BD;B2A6;1102 1173 11BD; 
    // (늦; 늦; 늦; 늦; 늦; ) HANGUL SYLLABLE NEUJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2A6 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2A6 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xB2A6 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_119)
{
    // B2A7;B2A7;1102 1173 11BE;B2A7;1102 1173 11BE; 
    // (늧; 늧; 늧; 늧; 늧; ) HANGUL SYLLABLE NEUC
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2A7 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2A7 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xB2A7 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_120)
{
    // B2A8;B2A8;1102 1173 11BF;B2A8;1102 1173 11BF; 
    // (늨; 늨; 늨; 늨; 늨; ) HANGUL SYLLABLE NEUK
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2A8 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2A8 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xB2A8 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_121)
{
    // B2A9;B2A9;1102 1173 11C0;B2A9;1102 1173 11C0; 
    // (늩; 늩; 늩; 늩; 늩; ) HANGUL SYLLABLE NEUT
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2A9 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2A9 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2A9 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_122)
{
    // B2AA;B2AA;1102 1173 11C1;B2AA;1102 1173 11C1; 
    // (늪; 늪; 늪; 늪; 늪; ) HANGUL SYLLABLE NEUP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2AA }};
        std::array<char32_t, 1> const c2 = {{ 0xB2AA }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2AA }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_123)
{
    // B2AB;B2AB;1102 1173 11C2;B2AB;1102 1173 11C2; 
    // (늫; 늫; 늫; 늫; 늫; ) HANGUL SYLLABLE NEUH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2AB }};
        std::array<char32_t, 1> const c2 = {{ 0xB2AB }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1173, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2AB }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1173, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_124)
{
    // B2AC;B2AC;1102 1174;B2AC;1102 1174; 
    // (늬; 늬; 늬; 늬; 늬; ) HANGUL SYLLABLE NYI
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2AC }};
        std::array<char32_t, 1> const c2 = {{ 0xB2AC }};
        std::array<char32_t, 2> const c3 = {{ 0x1102, 0x1174 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2AC }};
        std::array<char32_t, 2> const c5 = {{ 0x1102, 0x1174 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_125)
{
    // B2AD;B2AD;1102 1174 11A8;B2AD;1102 1174 11A8; 
    // (늭; 늭; 늭; 늭; 늭; ) HANGUL SYLLABLE NYIG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2AD }};
        std::array<char32_t, 1> const c2 = {{ 0xB2AD }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2AD }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_126)
{
    // B2AE;B2AE;1102 1174 11A9;B2AE;1102 1174 11A9; 
    // (늮; 늮; 늮; 늮; 늮; ) HANGUL SYLLABLE NYIGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2AE }};
        std::array<char32_t, 1> const c2 = {{ 0xB2AE }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2AE }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_127)
{
    // B2AF;B2AF;1102 1174 11AA;B2AF;1102 1174 11AA; 
    // (늯; 늯; 늯; 늯; 늯; ) HANGUL SYLLABLE NYIGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2AF }};
        std::array<char32_t, 1> const c2 = {{ 0xB2AF }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xB2AF }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_128)
{
    // B2B0;B2B0;1102 1174 11AB;B2B0;1102 1174 11AB; 
    // (늰; 늰; 늰; 늰; 늰; ) HANGUL SYLLABLE NYIN
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2B0 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2B0 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xB2B0 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_129)
{
    // B2B1;B2B1;1102 1174 11AC;B2B1;1102 1174 11AC; 
    // (늱; 늱; 늱; 늱; 늱; ) HANGUL SYLLABLE NYINJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2B1 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2B1 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xB2B1 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_130)
{
    // B2B2;B2B2;1102 1174 11AD;B2B2;1102 1174 11AD; 
    // (늲; 늲; 늲; 늲; 늲; ) HANGUL SYLLABLE NYINH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2B2 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2B2 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xB2B2 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_131)
{
    // B2B3;B2B3;1102 1174 11AE;B2B3;1102 1174 11AE; 
    // (늳; 늳; 늳; 늳; 늳; ) HANGUL SYLLABLE NYID
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2B3 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2B3 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xB2B3 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_132)
{
    // B2B4;B2B4;1102 1174 11AF;B2B4;1102 1174 11AF; 
    // (늴; 늴; 늴; 늴; 늴; ) HANGUL SYLLABLE NYIL
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2B4 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2B4 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xB2B4 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_133)
{
    // B2B5;B2B5;1102 1174 11B0;B2B5;1102 1174 11B0; 
    // (늵; 늵; 늵; 늵; 늵; ) HANGUL SYLLABLE NYILG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2B5 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2B5 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2B5 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_134)
{
    // B2B6;B2B6;1102 1174 11B1;B2B6;1102 1174 11B1; 
    // (늶; 늶; 늶; 늶; 늶; ) HANGUL SYLLABLE NYILM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2B6 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2B6 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2B6 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_135)
{
    // B2B7;B2B7;1102 1174 11B2;B2B7;1102 1174 11B2; 
    // (늷; 늷; 늷; 늷; 늷; ) HANGUL SYLLABLE NYILB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2B7 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2B7 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2B7 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_136)
{
    // B2B8;B2B8;1102 1174 11B3;B2B8;1102 1174 11B3; 
    // (늸; 늸; 늸; 늸; 늸; ) HANGUL SYLLABLE NYILS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2B8 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2B8 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2B8 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_137)
{
    // B2B9;B2B9;1102 1174 11B4;B2B9;1102 1174 11B4; 
    // (늹; 늹; 늹; 늹; 늹; ) HANGUL SYLLABLE NYILT
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2B9 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2B9 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2B9 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_138)
{
    // B2BA;B2BA;1102 1174 11B5;B2BA;1102 1174 11B5; 
    // (늺; 늺; 늺; 늺; 늺; ) HANGUL SYLLABLE NYILP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2BA }};
        std::array<char32_t, 1> const c2 = {{ 0xB2BA }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2BA }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_139)
{
    // B2BB;B2BB;1102 1174 11B6;B2BB;1102 1174 11B6; 
    // (늻; 늻; 늻; 늻; 늻; ) HANGUL SYLLABLE NYILH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2BB }};
        std::array<char32_t, 1> const c2 = {{ 0xB2BB }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2BB }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_140)
{
    // B2BC;B2BC;1102 1174 11B7;B2BC;1102 1174 11B7; 
    // (늼; 늼; 늼; 늼; 늼; ) HANGUL SYLLABLE NYIM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2BC }};
        std::array<char32_t, 1> const c2 = {{ 0xB2BC }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2BC }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_141)
{
    // B2BD;B2BD;1102 1174 11B8;B2BD;1102 1174 11B8; 
    // (늽; 늽; 늽; 늽; 늽; ) HANGUL SYLLABLE NYIB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2BD }};
        std::array<char32_t, 1> const c2 = {{ 0xB2BD }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2BD }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_142)
{
    // B2BE;B2BE;1102 1174 11B9;B2BE;1102 1174 11B9; 
    // (늾; 늾; 늾; 늾; 늾; ) HANGUL SYLLABLE NYIBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2BE }};
        std::array<char32_t, 1> const c2 = {{ 0xB2BE }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2BE }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_143)
{
    // B2BF;B2BF;1102 1174 11BA;B2BF;1102 1174 11BA; 
    // (늿; 늿; 늿; 늿; 늿; ) HANGUL SYLLABLE NYIS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2BF }};
        std::array<char32_t, 1> const c2 = {{ 0xB2BF }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xB2BF }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_144)
{
    // B2C0;B2C0;1102 1174 11BB;B2C0;1102 1174 11BB; 
    // (닀; 닀; 닀; 닀; 닀; ) HANGUL SYLLABLE NYISS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2C0 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2C0 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xB2C0 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_145)
{
    // B2C1;B2C1;1102 1174 11BC;B2C1;1102 1174 11BC; 
    // (닁; 닁; 닁; 닁; 닁; ) HANGUL SYLLABLE NYING
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2C1 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2C1 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xB2C1 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_146)
{
    // B2C2;B2C2;1102 1174 11BD;B2C2;1102 1174 11BD; 
    // (닂; 닂; 닂; 닂; 닂; ) HANGUL SYLLABLE NYIJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2C2 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2C2 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xB2C2 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_147)
{
    // B2C3;B2C3;1102 1174 11BE;B2C3;1102 1174 11BE; 
    // (닃; 닃; 닃; 닃; 닃; ) HANGUL SYLLABLE NYIC
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2C3 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2C3 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xB2C3 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_148)
{
    // B2C4;B2C4;1102 1174 11BF;B2C4;1102 1174 11BF; 
    // (닄; 닄; 닄; 닄; 닄; ) HANGUL SYLLABLE NYIK
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2C4 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2C4 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xB2C4 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_149)
{
    // B2C5;B2C5;1102 1174 11C0;B2C5;1102 1174 11C0; 
    // (닅; 닅; 닅; 닅; 닅; ) HANGUL SYLLABLE NYIT
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2C5 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2C5 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2C5 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_150)
{
    // B2C6;B2C6;1102 1174 11C1;B2C6;1102 1174 11C1; 
    // (닆; 닆; 닆; 닆; 닆; ) HANGUL SYLLABLE NYIP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2C6 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2C6 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2C6 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_151)
{
    // B2C7;B2C7;1102 1174 11C2;B2C7;1102 1174 11C2; 
    // (닇; 닇; 닇; 닇; 닇; ) HANGUL SYLLABLE NYIH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2C7 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2C7 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1174, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2C7 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1174, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_152)
{
    // B2C8;B2C8;1102 1175;B2C8;1102 1175; 
    // (니; 니; 니; 니; 니; ) HANGUL SYLLABLE NI
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2C8 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2C8 }};
        std::array<char32_t, 2> const c3 = {{ 0x1102, 0x1175 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2C8 }};
        std::array<char32_t, 2> const c5 = {{ 0x1102, 0x1175 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_153)
{
    // B2C9;B2C9;1102 1175 11A8;B2C9;1102 1175 11A8; 
    // (닉; 닉; 닉; 닉; 닉; ) HANGUL SYLLABLE NIG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2C9 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2C9 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2C9 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_154)
{
    // B2CA;B2CA;1102 1175 11A9;B2CA;1102 1175 11A9; 
    // (닊; 닊; 닊; 닊; 닊; ) HANGUL SYLLABLE NIGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2CA }};
        std::array<char32_t, 1> const c2 = {{ 0xB2CA }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2CA }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_155)
{
    // B2CB;B2CB;1102 1175 11AA;B2CB;1102 1175 11AA; 
    // (닋; 닋; 닋; 닋; 닋; ) HANGUL SYLLABLE NIGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2CB }};
        std::array<char32_t, 1> const c2 = {{ 0xB2CB }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xB2CB }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_156)
{
    // B2CC;B2CC;1102 1175 11AB;B2CC;1102 1175 11AB; 
    // (닌; 닌; 닌; 닌; 닌; ) HANGUL SYLLABLE NIN
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2CC }};
        std::array<char32_t, 1> const c2 = {{ 0xB2CC }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xB2CC }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_157)
{
    // B2CD;B2CD;1102 1175 11AC;B2CD;1102 1175 11AC; 
    // (닍; 닍; 닍; 닍; 닍; ) HANGUL SYLLABLE NINJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2CD }};
        std::array<char32_t, 1> const c2 = {{ 0xB2CD }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xB2CD }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_158)
{
    // B2CE;B2CE;1102 1175 11AD;B2CE;1102 1175 11AD; 
    // (닎; 닎; 닎; 닎; 닎; ) HANGUL SYLLABLE NINH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2CE }};
        std::array<char32_t, 1> const c2 = {{ 0xB2CE }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xB2CE }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_159)
{
    // B2CF;B2CF;1102 1175 11AE;B2CF;1102 1175 11AE; 
    // (닏; 닏; 닏; 닏; 닏; ) HANGUL SYLLABLE NID
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2CF }};
        std::array<char32_t, 1> const c2 = {{ 0xB2CF }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xB2CF }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_160)
{
    // B2D0;B2D0;1102 1175 11AF;B2D0;1102 1175 11AF; 
    // (닐; 닐; 닐; 닐; 닐; ) HANGUL SYLLABLE NIL
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2D0 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2D0 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xB2D0 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_161)
{
    // B2D1;B2D1;1102 1175 11B0;B2D1;1102 1175 11B0; 
    // (닑; 닑; 닑; 닑; 닑; ) HANGUL SYLLABLE NILG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2D1 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2D1 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2D1 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_162)
{
    // B2D2;B2D2;1102 1175 11B1;B2D2;1102 1175 11B1; 
    // (닒; 닒; 닒; 닒; 닒; ) HANGUL SYLLABLE NILM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2D2 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2D2 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2D2 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_163)
{
    // B2D3;B2D3;1102 1175 11B2;B2D3;1102 1175 11B2; 
    // (닓; 닓; 닓; 닓; 닓; ) HANGUL SYLLABLE NILB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2D3 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2D3 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2D3 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_164)
{
    // B2D4;B2D4;1102 1175 11B3;B2D4;1102 1175 11B3; 
    // (닔; 닔; 닔; 닔; 닔; ) HANGUL SYLLABLE NILS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2D4 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2D4 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2D4 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_165)
{
    // B2D5;B2D5;1102 1175 11B4;B2D5;1102 1175 11B4; 
    // (닕; 닕; 닕; 닕; 닕; ) HANGUL SYLLABLE NILT
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2D5 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2D5 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2D5 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_166)
{
    // B2D6;B2D6;1102 1175 11B5;B2D6;1102 1175 11B5; 
    // (닖; 닖; 닖; 닖; 닖; ) HANGUL SYLLABLE NILP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2D6 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2D6 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2D6 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_167)
{
    // B2D7;B2D7;1102 1175 11B6;B2D7;1102 1175 11B6; 
    // (닗; 닗; 닗; 닗; 닗; ) HANGUL SYLLABLE NILH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2D7 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2D7 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2D7 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_168)
{
    // B2D8;B2D8;1102 1175 11B7;B2D8;1102 1175 11B7; 
    // (님; 님; 님; 님; 님; ) HANGUL SYLLABLE NIM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2D8 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2D8 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2D8 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_169)
{
    // B2D9;B2D9;1102 1175 11B8;B2D9;1102 1175 11B8; 
    // (닙; 닙; 닙; 닙; 닙; ) HANGUL SYLLABLE NIB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2D9 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2D9 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2D9 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_170)
{
    // B2DA;B2DA;1102 1175 11B9;B2DA;1102 1175 11B9; 
    // (닚; 닚; 닚; 닚; 닚; ) HANGUL SYLLABLE NIBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2DA }};
        std::array<char32_t, 1> const c2 = {{ 0xB2DA }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2DA }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_171)
{
    // B2DB;B2DB;1102 1175 11BA;B2DB;1102 1175 11BA; 
    // (닛; 닛; 닛; 닛; 닛; ) HANGUL SYLLABLE NIS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2DB }};
        std::array<char32_t, 1> const c2 = {{ 0xB2DB }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xB2DB }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_172)
{
    // B2DC;B2DC;1102 1175 11BB;B2DC;1102 1175 11BB; 
    // (닜; 닜; 닜; 닜; 닜; ) HANGUL SYLLABLE NISS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2DC }};
        std::array<char32_t, 1> const c2 = {{ 0xB2DC }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xB2DC }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_173)
{
    // B2DD;B2DD;1102 1175 11BC;B2DD;1102 1175 11BC; 
    // (닝; 닝; 닝; 닝; 닝; ) HANGUL SYLLABLE NING
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2DD }};
        std::array<char32_t, 1> const c2 = {{ 0xB2DD }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xB2DD }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_174)
{
    // B2DE;B2DE;1102 1175 11BD;B2DE;1102 1175 11BD; 
    // (닞; 닞; 닞; 닞; 닞; ) HANGUL SYLLABLE NIJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2DE }};
        std::array<char32_t, 1> const c2 = {{ 0xB2DE }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xB2DE }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_175)
{
    // B2DF;B2DF;1102 1175 11BE;B2DF;1102 1175 11BE; 
    // (닟; 닟; 닟; 닟; 닟; ) HANGUL SYLLABLE NIC
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2DF }};
        std::array<char32_t, 1> const c2 = {{ 0xB2DF }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xB2DF }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_176)
{
    // B2E0;B2E0;1102 1175 11BF;B2E0;1102 1175 11BF; 
    // (닠; 닠; 닠; 닠; 닠; ) HANGUL SYLLABLE NIK
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2E0 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2E0 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xB2E0 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_177)
{
    // B2E1;B2E1;1102 1175 11C0;B2E1;1102 1175 11C0; 
    // (닡; 닡; 닡; 닡; 닡; ) HANGUL SYLLABLE NIT
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2E1 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2E1 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2E1 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_178)
{
    // B2E2;B2E2;1102 1175 11C1;B2E2;1102 1175 11C1; 
    // (닢; 닢; 닢; 닢; 닢; ) HANGUL SYLLABLE NIP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2E2 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2E2 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2E2 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_179)
{
    // B2E3;B2E3;1102 1175 11C2;B2E3;1102 1175 11C2; 
    // (닣; 닣; 닣; 닣; 닣; ) HANGUL SYLLABLE NIH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2E3 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2E3 }};
        std::array<char32_t, 3> const c3 = {{ 0x1102, 0x1175, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2E3 }};
        std::array<char32_t, 3> const c5 = {{ 0x1102, 0x1175, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_180)
{
    // B2E4;B2E4;1103 1161;B2E4;1103 1161; 
    // (다; 다; 다; 다; 다; ) HANGUL SYLLABLE DA
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2E4 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2E4 }};
        std::array<char32_t, 2> const c3 = {{ 0x1103, 0x1161 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2E4 }};
        std::array<char32_t, 2> const c5 = {{ 0x1103, 0x1161 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_181)
{
    // B2E5;B2E5;1103 1161 11A8;B2E5;1103 1161 11A8; 
    // (닥; 닥; 닥; 닥; 닥; ) HANGUL SYLLABLE DAG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2E5 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2E5 }};
        std::array<char32_t, 3> const c3 = {{ 0x1103, 0x1161, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2E5 }};
        std::array<char32_t, 3> const c5 = {{ 0x1103, 0x1161, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_182)
{
    // B2E6;B2E6;1103 1161 11A9;B2E6;1103 1161 11A9; 
    // (닦; 닦; 닦; 닦; 닦; ) HANGUL SYLLABLE DAGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2E6 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2E6 }};
        std::array<char32_t, 3> const c3 = {{ 0x1103, 0x1161, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2E6 }};
        std::array<char32_t, 3> const c5 = {{ 0x1103, 0x1161, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_183)
{
    // B2E7;B2E7;1103 1161 11AA;B2E7;1103 1161 11AA; 
    // (닧; 닧; 닧; 닧; 닧; ) HANGUL SYLLABLE DAGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2E7 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2E7 }};
        std::array<char32_t, 3> const c3 = {{ 0x1103, 0x1161, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xB2E7 }};
        std::array<char32_t, 3> const c5 = {{ 0x1103, 0x1161, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_184)
{
    // B2E8;B2E8;1103 1161 11AB;B2E8;1103 1161 11AB; 
    // (단; 단; 단; 단; 단; ) HANGUL SYLLABLE DAN
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2E8 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2E8 }};
        std::array<char32_t, 3> const c3 = {{ 0x1103, 0x1161, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xB2E8 }};
        std::array<char32_t, 3> const c5 = {{ 0x1103, 0x1161, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_185)
{
    // B2E9;B2E9;1103 1161 11AC;B2E9;1103 1161 11AC; 
    // (닩; 닩; 닩; 닩; 닩; ) HANGUL SYLLABLE DANJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2E9 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2E9 }};
        std::array<char32_t, 3> const c3 = {{ 0x1103, 0x1161, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xB2E9 }};
        std::array<char32_t, 3> const c5 = {{ 0x1103, 0x1161, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_186)
{
    // B2EA;B2EA;1103 1161 11AD;B2EA;1103 1161 11AD; 
    // (닪; 닪; 닪; 닪; 닪; ) HANGUL SYLLABLE DANH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2EA }};
        std::array<char32_t, 1> const c2 = {{ 0xB2EA }};
        std::array<char32_t, 3> const c3 = {{ 0x1103, 0x1161, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xB2EA }};
        std::array<char32_t, 3> const c5 = {{ 0x1103, 0x1161, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_187)
{
    // B2EB;B2EB;1103 1161 11AE;B2EB;1103 1161 11AE; 
    // (닫; 닫; 닫; 닫; 닫; ) HANGUL SYLLABLE DAD
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2EB }};
        std::array<char32_t, 1> const c2 = {{ 0xB2EB }};
        std::array<char32_t, 3> const c3 = {{ 0x1103, 0x1161, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xB2EB }};
        std::array<char32_t, 3> const c5 = {{ 0x1103, 0x1161, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_188)
{
    // B2EC;B2EC;1103 1161 11AF;B2EC;1103 1161 11AF; 
    // (달; 달; 달; 달; 달; ) HANGUL SYLLABLE DAL
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2EC }};
        std::array<char32_t, 1> const c2 = {{ 0xB2EC }};
        std::array<char32_t, 3> const c3 = {{ 0x1103, 0x1161, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xB2EC }};
        std::array<char32_t, 3> const c5 = {{ 0x1103, 0x1161, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_189)
{
    // B2ED;B2ED;1103 1161 11B0;B2ED;1103 1161 11B0; 
    // (닭; 닭; 닭; 닭; 닭; ) HANGUL SYLLABLE DALG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2ED }};
        std::array<char32_t, 1> const c2 = {{ 0xB2ED }};
        std::array<char32_t, 3> const c3 = {{ 0x1103, 0x1161, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2ED }};
        std::array<char32_t, 3> const c5 = {{ 0x1103, 0x1161, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_190)
{
    // B2EE;B2EE;1103 1161 11B1;B2EE;1103 1161 11B1; 
    // (닮; 닮; 닮; 닮; 닮; ) HANGUL SYLLABLE DALM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2EE }};
        std::array<char32_t, 1> const c2 = {{ 0xB2EE }};
        std::array<char32_t, 3> const c3 = {{ 0x1103, 0x1161, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2EE }};
        std::array<char32_t, 3> const c5 = {{ 0x1103, 0x1161, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_191)
{
    // B2EF;B2EF;1103 1161 11B2;B2EF;1103 1161 11B2; 
    // (닯; 닯; 닯; 닯; 닯; ) HANGUL SYLLABLE DALB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2EF }};
        std::array<char32_t, 1> const c2 = {{ 0xB2EF }};
        std::array<char32_t, 3> const c3 = {{ 0x1103, 0x1161, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2EF }};
        std::array<char32_t, 3> const c5 = {{ 0x1103, 0x1161, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_192)
{
    // B2F0;B2F0;1103 1161 11B3;B2F0;1103 1161 11B3; 
    // (닰; 닰; 닰; 닰; 닰; ) HANGUL SYLLABLE DALS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2F0 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2F0 }};
        std::array<char32_t, 3> const c3 = {{ 0x1103, 0x1161, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2F0 }};
        std::array<char32_t, 3> const c5 = {{ 0x1103, 0x1161, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_193)
{
    // B2F1;B2F1;1103 1161 11B4;B2F1;1103 1161 11B4; 
    // (닱; 닱; 닱; 닱; 닱; ) HANGUL SYLLABLE DALT
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2F1 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2F1 }};
        std::array<char32_t, 3> const c3 = {{ 0x1103, 0x1161, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2F1 }};
        std::array<char32_t, 3> const c5 = {{ 0x1103, 0x1161, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_194)
{
    // B2F2;B2F2;1103 1161 11B5;B2F2;1103 1161 11B5; 
    // (닲; 닲; 닲; 닲; 닲; ) HANGUL SYLLABLE DALP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2F2 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2F2 }};
        std::array<char32_t, 3> const c3 = {{ 0x1103, 0x1161, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2F2 }};
        std::array<char32_t, 3> const c5 = {{ 0x1103, 0x1161, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_195)
{
    // B2F3;B2F3;1103 1161 11B6;B2F3;1103 1161 11B6; 
    // (닳; 닳; 닳; 닳; 닳; ) HANGUL SYLLABLE DALH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2F3 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2F3 }};
        std::array<char32_t, 3> const c3 = {{ 0x1103, 0x1161, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2F3 }};
        std::array<char32_t, 3> const c5 = {{ 0x1103, 0x1161, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_196)
{
    // B2F4;B2F4;1103 1161 11B7;B2F4;1103 1161 11B7; 
    // (담; 담; 담; 담; 담; ) HANGUL SYLLABLE DAM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2F4 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2F4 }};
        std::array<char32_t, 3> const c3 = {{ 0x1103, 0x1161, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2F4 }};
        std::array<char32_t, 3> const c5 = {{ 0x1103, 0x1161, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_197)
{
    // B2F5;B2F5;1103 1161 11B8;B2F5;1103 1161 11B8; 
    // (답; 답; 답; 답; 답; ) HANGUL SYLLABLE DAB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2F5 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2F5 }};
        std::array<char32_t, 3> const c3 = {{ 0x1103, 0x1161, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2F5 }};
        std::array<char32_t, 3> const c5 = {{ 0x1103, 0x1161, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_198)
{
    // B2F6;B2F6;1103 1161 11B9;B2F6;1103 1161 11B9; 
    // (닶; 닶; 닶; 닶; 닶; ) HANGUL SYLLABLE DABS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2F6 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2F6 }};
        std::array<char32_t, 3> const c3 = {{ 0x1103, 0x1161, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB2F6 }};
        std::array<char32_t, 3> const c5 = {{ 0x1103, 0x1161, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_020_199)
{
    // B2F7;B2F7;1103 1161 11BA;B2F7;1103 1161 11BA; 
    // (닷; 닷; 닷; 닷; 닷; ) HANGUL SYLLABLE DAS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB2F7 }};
        std::array<char32_t, 1> const c2 = {{ 0xB2F7 }};
        std::array<char32_t, 3> const c3 = {{ 0x1103, 0x1161, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xB2F7 }};
        std::array<char32_t, 3> const c5 = {{ 0x1103, 0x1161, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


