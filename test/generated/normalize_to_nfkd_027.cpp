// Copyright (C) 2020 T. Zachary Laine
//
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

// Warning! This file is autogenerated.
#include <boost/text/normalize_string.hpp>
#include <boost/text/transcode_view.hpp>
#include <boost/text/string_utility.hpp>

#include <gtest/gtest.h>

#include <algorithm>



TEST(normalization, nfkd_027_000)
{
    // B7A8;B7A8;1105 1162 11B7;B7A8;1105 1162 11B7; 
    // (램; 램; 램; 램; 램; ) HANGUL SYLLABLE RAEM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7A8 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7A8 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1162, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7A8 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1162, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_001)
{
    // B7A9;B7A9;1105 1162 11B8;B7A9;1105 1162 11B8; 
    // (랩; 랩; 랩; 랩; 랩; ) HANGUL SYLLABLE RAEB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7A9 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7A9 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1162, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7A9 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1162, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_002)
{
    // B7AA;B7AA;1105 1162 11B9;B7AA;1105 1162 11B9; 
    // (랪; 랪; 랪; 랪; 랪; ) HANGUL SYLLABLE RAEBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7AA }};
        std::array<char32_t, 1> const c2 = {{ 0xB7AA }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1162, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7AA }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1162, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_003)
{
    // B7AB;B7AB;1105 1162 11BA;B7AB;1105 1162 11BA; 
    // (랫; 랫; 랫; 랫; 랫; ) HANGUL SYLLABLE RAES
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7AB }};
        std::array<char32_t, 1> const c2 = {{ 0xB7AB }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1162, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xB7AB }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1162, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_004)
{
    // B7AC;B7AC;1105 1162 11BB;B7AC;1105 1162 11BB; 
    // (랬; 랬; 랬; 랬; 랬; ) HANGUL SYLLABLE RAESS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7AC }};
        std::array<char32_t, 1> const c2 = {{ 0xB7AC }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1162, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xB7AC }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1162, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_005)
{
    // B7AD;B7AD;1105 1162 11BC;B7AD;1105 1162 11BC; 
    // (랭; 랭; 랭; 랭; 랭; ) HANGUL SYLLABLE RAENG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7AD }};
        std::array<char32_t, 1> const c2 = {{ 0xB7AD }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1162, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xB7AD }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1162, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_006)
{
    // B7AE;B7AE;1105 1162 11BD;B7AE;1105 1162 11BD; 
    // (랮; 랮; 랮; 랮; 랮; ) HANGUL SYLLABLE RAEJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7AE }};
        std::array<char32_t, 1> const c2 = {{ 0xB7AE }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1162, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xB7AE }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1162, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_007)
{
    // B7AF;B7AF;1105 1162 11BE;B7AF;1105 1162 11BE; 
    // (랯; 랯; 랯; 랯; 랯; ) HANGUL SYLLABLE RAEC
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7AF }};
        std::array<char32_t, 1> const c2 = {{ 0xB7AF }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1162, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xB7AF }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1162, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_008)
{
    // B7B0;B7B0;1105 1162 11BF;B7B0;1105 1162 11BF; 
    // (랰; 랰; 랰; 랰; 랰; ) HANGUL SYLLABLE RAEK
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7B0 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7B0 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1162, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xB7B0 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1162, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_009)
{
    // B7B1;B7B1;1105 1162 11C0;B7B1;1105 1162 11C0; 
    // (랱; 랱; 랱; 랱; 랱; ) HANGUL SYLLABLE RAET
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7B1 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7B1 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1162, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7B1 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1162, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_010)
{
    // B7B2;B7B2;1105 1162 11C1;B7B2;1105 1162 11C1; 
    // (랲; 랲; 랲; 랲; 랲; ) HANGUL SYLLABLE RAEP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7B2 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7B2 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1162, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7B2 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1162, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_011)
{
    // B7B3;B7B3;1105 1162 11C2;B7B3;1105 1162 11C2; 
    // (랳; 랳; 랳; 랳; 랳; ) HANGUL SYLLABLE RAEH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7B3 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7B3 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1162, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7B3 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1162, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_012)
{
    // B7B4;B7B4;1105 1163;B7B4;1105 1163; 
    // (랴; 랴; 랴; 랴; 랴; ) HANGUL SYLLABLE RYA
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7B4 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7B4 }};
        std::array<char32_t, 2> const c3 = {{ 0x1105, 0x1163 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7B4 }};
        std::array<char32_t, 2> const c5 = {{ 0x1105, 0x1163 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_013)
{
    // B7B5;B7B5;1105 1163 11A8;B7B5;1105 1163 11A8; 
    // (략; 략; 략; 략; 략; ) HANGUL SYLLABLE RYAG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7B5 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7B5 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7B5 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_014)
{
    // B7B6;B7B6;1105 1163 11A9;B7B6;1105 1163 11A9; 
    // (랶; 랶; 랶; 랶; 랶; ) HANGUL SYLLABLE RYAGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7B6 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7B6 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7B6 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_015)
{
    // B7B7;B7B7;1105 1163 11AA;B7B7;1105 1163 11AA; 
    // (랷; 랷; 랷; 랷; 랷; ) HANGUL SYLLABLE RYAGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7B7 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7B7 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xB7B7 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_016)
{
    // B7B8;B7B8;1105 1163 11AB;B7B8;1105 1163 11AB; 
    // (랸; 랸; 랸; 랸; 랸; ) HANGUL SYLLABLE RYAN
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7B8 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7B8 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xB7B8 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_017)
{
    // B7B9;B7B9;1105 1163 11AC;B7B9;1105 1163 11AC; 
    // (랹; 랹; 랹; 랹; 랹; ) HANGUL SYLLABLE RYANJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7B9 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7B9 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xB7B9 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_018)
{
    // B7BA;B7BA;1105 1163 11AD;B7BA;1105 1163 11AD; 
    // (랺; 랺; 랺; 랺; 랺; ) HANGUL SYLLABLE RYANH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7BA }};
        std::array<char32_t, 1> const c2 = {{ 0xB7BA }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xB7BA }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_019)
{
    // B7BB;B7BB;1105 1163 11AE;B7BB;1105 1163 11AE; 
    // (랻; 랻; 랻; 랻; 랻; ) HANGUL SYLLABLE RYAD
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7BB }};
        std::array<char32_t, 1> const c2 = {{ 0xB7BB }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xB7BB }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_020)
{
    // B7BC;B7BC;1105 1163 11AF;B7BC;1105 1163 11AF; 
    // (랼; 랼; 랼; 랼; 랼; ) HANGUL SYLLABLE RYAL
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7BC }};
        std::array<char32_t, 1> const c2 = {{ 0xB7BC }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xB7BC }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_021)
{
    // B7BD;B7BD;1105 1163 11B0;B7BD;1105 1163 11B0; 
    // (랽; 랽; 랽; 랽; 랽; ) HANGUL SYLLABLE RYALG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7BD }};
        std::array<char32_t, 1> const c2 = {{ 0xB7BD }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7BD }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_022)
{
    // B7BE;B7BE;1105 1163 11B1;B7BE;1105 1163 11B1; 
    // (랾; 랾; 랾; 랾; 랾; ) HANGUL SYLLABLE RYALM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7BE }};
        std::array<char32_t, 1> const c2 = {{ 0xB7BE }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7BE }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_023)
{
    // B7BF;B7BF;1105 1163 11B2;B7BF;1105 1163 11B2; 
    // (랿; 랿; 랿; 랿; 랿; ) HANGUL SYLLABLE RYALB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7BF }};
        std::array<char32_t, 1> const c2 = {{ 0xB7BF }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7BF }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_024)
{
    // B7C0;B7C0;1105 1163 11B3;B7C0;1105 1163 11B3; 
    // (럀; 럀; 럀; 럀; 럀; ) HANGUL SYLLABLE RYALS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7C0 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7C0 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7C0 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_025)
{
    // B7C1;B7C1;1105 1163 11B4;B7C1;1105 1163 11B4; 
    // (럁; 럁; 럁; 럁; 럁; ) HANGUL SYLLABLE RYALT
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7C1 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7C1 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7C1 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_026)
{
    // B7C2;B7C2;1105 1163 11B5;B7C2;1105 1163 11B5; 
    // (럂; 럂; 럂; 럂; 럂; ) HANGUL SYLLABLE RYALP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7C2 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7C2 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7C2 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_027)
{
    // B7C3;B7C3;1105 1163 11B6;B7C3;1105 1163 11B6; 
    // (럃; 럃; 럃; 럃; 럃; ) HANGUL SYLLABLE RYALH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7C3 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7C3 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7C3 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_028)
{
    // B7C4;B7C4;1105 1163 11B7;B7C4;1105 1163 11B7; 
    // (럄; 럄; 럄; 럄; 럄; ) HANGUL SYLLABLE RYAM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7C4 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7C4 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7C4 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_029)
{
    // B7C5;B7C5;1105 1163 11B8;B7C5;1105 1163 11B8; 
    // (럅; 럅; 럅; 럅; 럅; ) HANGUL SYLLABLE RYAB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7C5 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7C5 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7C5 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_030)
{
    // B7C6;B7C6;1105 1163 11B9;B7C6;1105 1163 11B9; 
    // (럆; 럆; 럆; 럆; 럆; ) HANGUL SYLLABLE RYABS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7C6 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7C6 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7C6 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_031)
{
    // B7C7;B7C7;1105 1163 11BA;B7C7;1105 1163 11BA; 
    // (럇; 럇; 럇; 럇; 럇; ) HANGUL SYLLABLE RYAS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7C7 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7C7 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xB7C7 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_032)
{
    // B7C8;B7C8;1105 1163 11BB;B7C8;1105 1163 11BB; 
    // (럈; 럈; 럈; 럈; 럈; ) HANGUL SYLLABLE RYASS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7C8 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7C8 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xB7C8 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_033)
{
    // B7C9;B7C9;1105 1163 11BC;B7C9;1105 1163 11BC; 
    // (량; 량; 량; 량; 량; ) HANGUL SYLLABLE RYANG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7C9 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7C9 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xB7C9 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_034)
{
    // B7CA;B7CA;1105 1163 11BD;B7CA;1105 1163 11BD; 
    // (럊; 럊; 럊; 럊; 럊; ) HANGUL SYLLABLE RYAJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7CA }};
        std::array<char32_t, 1> const c2 = {{ 0xB7CA }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xB7CA }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_035)
{
    // B7CB;B7CB;1105 1163 11BE;B7CB;1105 1163 11BE; 
    // (럋; 럋; 럋; 럋; 럋; ) HANGUL SYLLABLE RYAC
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7CB }};
        std::array<char32_t, 1> const c2 = {{ 0xB7CB }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xB7CB }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_036)
{
    // B7CC;B7CC;1105 1163 11BF;B7CC;1105 1163 11BF; 
    // (럌; 럌; 럌; 럌; 럌; ) HANGUL SYLLABLE RYAK
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7CC }};
        std::array<char32_t, 1> const c2 = {{ 0xB7CC }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xB7CC }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_037)
{
    // B7CD;B7CD;1105 1163 11C0;B7CD;1105 1163 11C0; 
    // (럍; 럍; 럍; 럍; 럍; ) HANGUL SYLLABLE RYAT
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7CD }};
        std::array<char32_t, 1> const c2 = {{ 0xB7CD }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7CD }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_038)
{
    // B7CE;B7CE;1105 1163 11C1;B7CE;1105 1163 11C1; 
    // (럎; 럎; 럎; 럎; 럎; ) HANGUL SYLLABLE RYAP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7CE }};
        std::array<char32_t, 1> const c2 = {{ 0xB7CE }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7CE }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_039)
{
    // B7CF;B7CF;1105 1163 11C2;B7CF;1105 1163 11C2; 
    // (럏; 럏; 럏; 럏; 럏; ) HANGUL SYLLABLE RYAH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7CF }};
        std::array<char32_t, 1> const c2 = {{ 0xB7CF }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1163, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7CF }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1163, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_040)
{
    // B7D0;B7D0;1105 1164;B7D0;1105 1164; 
    // (럐; 럐; 럐; 럐; 럐; ) HANGUL SYLLABLE RYAE
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7D0 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7D0 }};
        std::array<char32_t, 2> const c3 = {{ 0x1105, 0x1164 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7D0 }};
        std::array<char32_t, 2> const c5 = {{ 0x1105, 0x1164 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_041)
{
    // B7D1;B7D1;1105 1164 11A8;B7D1;1105 1164 11A8; 
    // (럑; 럑; 럑; 럑; 럑; ) HANGUL SYLLABLE RYAEG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7D1 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7D1 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7D1 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_042)
{
    // B7D2;B7D2;1105 1164 11A9;B7D2;1105 1164 11A9; 
    // (럒; 럒; 럒; 럒; 럒; ) HANGUL SYLLABLE RYAEGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7D2 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7D2 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7D2 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_043)
{
    // B7D3;B7D3;1105 1164 11AA;B7D3;1105 1164 11AA; 
    // (럓; 럓; 럓; 럓; 럓; ) HANGUL SYLLABLE RYAEGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7D3 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7D3 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xB7D3 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_044)
{
    // B7D4;B7D4;1105 1164 11AB;B7D4;1105 1164 11AB; 
    // (럔; 럔; 럔; 럔; 럔; ) HANGUL SYLLABLE RYAEN
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7D4 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7D4 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xB7D4 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_045)
{
    // B7D5;B7D5;1105 1164 11AC;B7D5;1105 1164 11AC; 
    // (럕; 럕; 럕; 럕; 럕; ) HANGUL SYLLABLE RYAENJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7D5 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7D5 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xB7D5 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_046)
{
    // B7D6;B7D6;1105 1164 11AD;B7D6;1105 1164 11AD; 
    // (럖; 럖; 럖; 럖; 럖; ) HANGUL SYLLABLE RYAENH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7D6 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7D6 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xB7D6 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_047)
{
    // B7D7;B7D7;1105 1164 11AE;B7D7;1105 1164 11AE; 
    // (럗; 럗; 럗; 럗; 럗; ) HANGUL SYLLABLE RYAED
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7D7 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7D7 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xB7D7 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_048)
{
    // B7D8;B7D8;1105 1164 11AF;B7D8;1105 1164 11AF; 
    // (럘; 럘; 럘; 럘; 럘; ) HANGUL SYLLABLE RYAEL
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7D8 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7D8 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xB7D8 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_049)
{
    // B7D9;B7D9;1105 1164 11B0;B7D9;1105 1164 11B0; 
    // (럙; 럙; 럙; 럙; 럙; ) HANGUL SYLLABLE RYAELG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7D9 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7D9 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7D9 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_050)
{
    // B7DA;B7DA;1105 1164 11B1;B7DA;1105 1164 11B1; 
    // (럚; 럚; 럚; 럚; 럚; ) HANGUL SYLLABLE RYAELM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7DA }};
        std::array<char32_t, 1> const c2 = {{ 0xB7DA }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7DA }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_051)
{
    // B7DB;B7DB;1105 1164 11B2;B7DB;1105 1164 11B2; 
    // (럛; 럛; 럛; 럛; 럛; ) HANGUL SYLLABLE RYAELB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7DB }};
        std::array<char32_t, 1> const c2 = {{ 0xB7DB }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7DB }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_052)
{
    // B7DC;B7DC;1105 1164 11B3;B7DC;1105 1164 11B3; 
    // (럜; 럜; 럜; 럜; 럜; ) HANGUL SYLLABLE RYAELS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7DC }};
        std::array<char32_t, 1> const c2 = {{ 0xB7DC }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7DC }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_053)
{
    // B7DD;B7DD;1105 1164 11B4;B7DD;1105 1164 11B4; 
    // (럝; 럝; 럝; 럝; 럝; ) HANGUL SYLLABLE RYAELT
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7DD }};
        std::array<char32_t, 1> const c2 = {{ 0xB7DD }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7DD }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_054)
{
    // B7DE;B7DE;1105 1164 11B5;B7DE;1105 1164 11B5; 
    // (럞; 럞; 럞; 럞; 럞; ) HANGUL SYLLABLE RYAELP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7DE }};
        std::array<char32_t, 1> const c2 = {{ 0xB7DE }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7DE }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_055)
{
    // B7DF;B7DF;1105 1164 11B6;B7DF;1105 1164 11B6; 
    // (럟; 럟; 럟; 럟; 럟; ) HANGUL SYLLABLE RYAELH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7DF }};
        std::array<char32_t, 1> const c2 = {{ 0xB7DF }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7DF }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_056)
{
    // B7E0;B7E0;1105 1164 11B7;B7E0;1105 1164 11B7; 
    // (럠; 럠; 럠; 럠; 럠; ) HANGUL SYLLABLE RYAEM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7E0 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7E0 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7E0 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_057)
{
    // B7E1;B7E1;1105 1164 11B8;B7E1;1105 1164 11B8; 
    // (럡; 럡; 럡; 럡; 럡; ) HANGUL SYLLABLE RYAEB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7E1 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7E1 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7E1 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_058)
{
    // B7E2;B7E2;1105 1164 11B9;B7E2;1105 1164 11B9; 
    // (럢; 럢; 럢; 럢; 럢; ) HANGUL SYLLABLE RYAEBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7E2 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7E2 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7E2 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_059)
{
    // B7E3;B7E3;1105 1164 11BA;B7E3;1105 1164 11BA; 
    // (럣; 럣; 럣; 럣; 럣; ) HANGUL SYLLABLE RYAES
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7E3 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7E3 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xB7E3 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_060)
{
    // B7E4;B7E4;1105 1164 11BB;B7E4;1105 1164 11BB; 
    // (럤; 럤; 럤; 럤; 럤; ) HANGUL SYLLABLE RYAESS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7E4 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7E4 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xB7E4 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_061)
{
    // B7E5;B7E5;1105 1164 11BC;B7E5;1105 1164 11BC; 
    // (럥; 럥; 럥; 럥; 럥; ) HANGUL SYLLABLE RYAENG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7E5 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7E5 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xB7E5 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_062)
{
    // B7E6;B7E6;1105 1164 11BD;B7E6;1105 1164 11BD; 
    // (럦; 럦; 럦; 럦; 럦; ) HANGUL SYLLABLE RYAEJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7E6 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7E6 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xB7E6 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_063)
{
    // B7E7;B7E7;1105 1164 11BE;B7E7;1105 1164 11BE; 
    // (럧; 럧; 럧; 럧; 럧; ) HANGUL SYLLABLE RYAEC
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7E7 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7E7 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xB7E7 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_064)
{
    // B7E8;B7E8;1105 1164 11BF;B7E8;1105 1164 11BF; 
    // (럨; 럨; 럨; 럨; 럨; ) HANGUL SYLLABLE RYAEK
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7E8 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7E8 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xB7E8 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_065)
{
    // B7E9;B7E9;1105 1164 11C0;B7E9;1105 1164 11C0; 
    // (럩; 럩; 럩; 럩; 럩; ) HANGUL SYLLABLE RYAET
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7E9 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7E9 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7E9 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_066)
{
    // B7EA;B7EA;1105 1164 11C1;B7EA;1105 1164 11C1; 
    // (럪; 럪; 럪; 럪; 럪; ) HANGUL SYLLABLE RYAEP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7EA }};
        std::array<char32_t, 1> const c2 = {{ 0xB7EA }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7EA }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_067)
{
    // B7EB;B7EB;1105 1164 11C2;B7EB;1105 1164 11C2; 
    // (럫; 럫; 럫; 럫; 럫; ) HANGUL SYLLABLE RYAEH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7EB }};
        std::array<char32_t, 1> const c2 = {{ 0xB7EB }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1164, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7EB }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1164, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_068)
{
    // B7EC;B7EC;1105 1165;B7EC;1105 1165; 
    // (러; 러; 러; 러; 러; ) HANGUL SYLLABLE REO
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7EC }};
        std::array<char32_t, 1> const c2 = {{ 0xB7EC }};
        std::array<char32_t, 2> const c3 = {{ 0x1105, 0x1165 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7EC }};
        std::array<char32_t, 2> const c5 = {{ 0x1105, 0x1165 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_069)
{
    // B7ED;B7ED;1105 1165 11A8;B7ED;1105 1165 11A8; 
    // (럭; 럭; 럭; 럭; 럭; ) HANGUL SYLLABLE REOG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7ED }};
        std::array<char32_t, 1> const c2 = {{ 0xB7ED }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7ED }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_070)
{
    // B7EE;B7EE;1105 1165 11A9;B7EE;1105 1165 11A9; 
    // (럮; 럮; 럮; 럮; 럮; ) HANGUL SYLLABLE REOGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7EE }};
        std::array<char32_t, 1> const c2 = {{ 0xB7EE }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7EE }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_071)
{
    // B7EF;B7EF;1105 1165 11AA;B7EF;1105 1165 11AA; 
    // (럯; 럯; 럯; 럯; 럯; ) HANGUL SYLLABLE REOGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7EF }};
        std::array<char32_t, 1> const c2 = {{ 0xB7EF }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xB7EF }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_072)
{
    // B7F0;B7F0;1105 1165 11AB;B7F0;1105 1165 11AB; 
    // (런; 런; 런; 런; 런; ) HANGUL SYLLABLE REON
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7F0 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7F0 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xB7F0 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_073)
{
    // B7F1;B7F1;1105 1165 11AC;B7F1;1105 1165 11AC; 
    // (럱; 럱; 럱; 럱; 럱; ) HANGUL SYLLABLE REONJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7F1 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7F1 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xB7F1 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_074)
{
    // B7F2;B7F2;1105 1165 11AD;B7F2;1105 1165 11AD; 
    // (럲; 럲; 럲; 럲; 럲; ) HANGUL SYLLABLE REONH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7F2 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7F2 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xB7F2 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_075)
{
    // B7F3;B7F3;1105 1165 11AE;B7F3;1105 1165 11AE; 
    // (럳; 럳; 럳; 럳; 럳; ) HANGUL SYLLABLE REOD
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7F3 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7F3 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xB7F3 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_076)
{
    // B7F4;B7F4;1105 1165 11AF;B7F4;1105 1165 11AF; 
    // (럴; 럴; 럴; 럴; 럴; ) HANGUL SYLLABLE REOL
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7F4 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7F4 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xB7F4 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_077)
{
    // B7F5;B7F5;1105 1165 11B0;B7F5;1105 1165 11B0; 
    // (럵; 럵; 럵; 럵; 럵; ) HANGUL SYLLABLE REOLG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7F5 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7F5 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7F5 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_078)
{
    // B7F6;B7F6;1105 1165 11B1;B7F6;1105 1165 11B1; 
    // (럶; 럶; 럶; 럶; 럶; ) HANGUL SYLLABLE REOLM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7F6 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7F6 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7F6 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_079)
{
    // B7F7;B7F7;1105 1165 11B2;B7F7;1105 1165 11B2; 
    // (럷; 럷; 럷; 럷; 럷; ) HANGUL SYLLABLE REOLB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7F7 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7F7 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7F7 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_080)
{
    // B7F8;B7F8;1105 1165 11B3;B7F8;1105 1165 11B3; 
    // (럸; 럸; 럸; 럸; 럸; ) HANGUL SYLLABLE REOLS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7F8 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7F8 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7F8 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_081)
{
    // B7F9;B7F9;1105 1165 11B4;B7F9;1105 1165 11B4; 
    // (럹; 럹; 럹; 럹; 럹; ) HANGUL SYLLABLE REOLT
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7F9 }};
        std::array<char32_t, 1> const c2 = {{ 0xB7F9 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7F9 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_082)
{
    // B7FA;B7FA;1105 1165 11B5;B7FA;1105 1165 11B5; 
    // (럺; 럺; 럺; 럺; 럺; ) HANGUL SYLLABLE REOLP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7FA }};
        std::array<char32_t, 1> const c2 = {{ 0xB7FA }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7FA }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_083)
{
    // B7FB;B7FB;1105 1165 11B6;B7FB;1105 1165 11B6; 
    // (럻; 럻; 럻; 럻; 럻; ) HANGUL SYLLABLE REOLH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7FB }};
        std::array<char32_t, 1> const c2 = {{ 0xB7FB }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7FB }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_084)
{
    // B7FC;B7FC;1105 1165 11B7;B7FC;1105 1165 11B7; 
    // (럼; 럼; 럼; 럼; 럼; ) HANGUL SYLLABLE REOM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7FC }};
        std::array<char32_t, 1> const c2 = {{ 0xB7FC }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7FC }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_085)
{
    // B7FD;B7FD;1105 1165 11B8;B7FD;1105 1165 11B8; 
    // (럽; 럽; 럽; 럽; 럽; ) HANGUL SYLLABLE REOB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7FD }};
        std::array<char32_t, 1> const c2 = {{ 0xB7FD }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7FD }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_086)
{
    // B7FE;B7FE;1105 1165 11B9;B7FE;1105 1165 11B9; 
    // (럾; 럾; 럾; 럾; 럾; ) HANGUL SYLLABLE REOBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7FE }};
        std::array<char32_t, 1> const c2 = {{ 0xB7FE }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB7FE }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_087)
{
    // B7FF;B7FF;1105 1165 11BA;B7FF;1105 1165 11BA; 
    // (럿; 럿; 럿; 럿; 럿; ) HANGUL SYLLABLE REOS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB7FF }};
        std::array<char32_t, 1> const c2 = {{ 0xB7FF }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xB7FF }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_088)
{
    // B800;B800;1105 1165 11BB;B800;1105 1165 11BB; 
    // (렀; 렀; 렀; 렀; 렀; ) HANGUL SYLLABLE REOSS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB800 }};
        std::array<char32_t, 1> const c2 = {{ 0xB800 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xB800 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_089)
{
    // B801;B801;1105 1165 11BC;B801;1105 1165 11BC; 
    // (렁; 렁; 렁; 렁; 렁; ) HANGUL SYLLABLE REONG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB801 }};
        std::array<char32_t, 1> const c2 = {{ 0xB801 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xB801 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_090)
{
    // B802;B802;1105 1165 11BD;B802;1105 1165 11BD; 
    // (렂; 렂; 렂; 렂; 렂; ) HANGUL SYLLABLE REOJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB802 }};
        std::array<char32_t, 1> const c2 = {{ 0xB802 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xB802 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_091)
{
    // B803;B803;1105 1165 11BE;B803;1105 1165 11BE; 
    // (렃; 렃; 렃; 렃; 렃; ) HANGUL SYLLABLE REOC
    {
        std::array<char32_t, 1> const c1 = {{ 0xB803 }};
        std::array<char32_t, 1> const c2 = {{ 0xB803 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xB803 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_092)
{
    // B804;B804;1105 1165 11BF;B804;1105 1165 11BF; 
    // (렄; 렄; 렄; 렄; 렄; ) HANGUL SYLLABLE REOK
    {
        std::array<char32_t, 1> const c1 = {{ 0xB804 }};
        std::array<char32_t, 1> const c2 = {{ 0xB804 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xB804 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_093)
{
    // B805;B805;1105 1165 11C0;B805;1105 1165 11C0; 
    // (렅; 렅; 렅; 렅; 렅; ) HANGUL SYLLABLE REOT
    {
        std::array<char32_t, 1> const c1 = {{ 0xB805 }};
        std::array<char32_t, 1> const c2 = {{ 0xB805 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB805 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_094)
{
    // B806;B806;1105 1165 11C1;B806;1105 1165 11C1; 
    // (렆; 렆; 렆; 렆; 렆; ) HANGUL SYLLABLE REOP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB806 }};
        std::array<char32_t, 1> const c2 = {{ 0xB806 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB806 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_095)
{
    // B807;B807;1105 1165 11C2;B807;1105 1165 11C2; 
    // (렇; 렇; 렇; 렇; 렇; ) HANGUL SYLLABLE REOH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB807 }};
        std::array<char32_t, 1> const c2 = {{ 0xB807 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1165, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB807 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1165, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_096)
{
    // B808;B808;1105 1166;B808;1105 1166; 
    // (레; 레; 레; 레; 레; ) HANGUL SYLLABLE RE
    {
        std::array<char32_t, 1> const c1 = {{ 0xB808 }};
        std::array<char32_t, 1> const c2 = {{ 0xB808 }};
        std::array<char32_t, 2> const c3 = {{ 0x1105, 0x1166 }};
        std::array<char32_t, 1> const c4 = {{ 0xB808 }};
        std::array<char32_t, 2> const c5 = {{ 0x1105, 0x1166 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_097)
{
    // B809;B809;1105 1166 11A8;B809;1105 1166 11A8; 
    // (렉; 렉; 렉; 렉; 렉; ) HANGUL SYLLABLE REG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB809 }};
        std::array<char32_t, 1> const c2 = {{ 0xB809 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB809 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_098)
{
    // B80A;B80A;1105 1166 11A9;B80A;1105 1166 11A9; 
    // (렊; 렊; 렊; 렊; 렊; ) HANGUL SYLLABLE REGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB80A }};
        std::array<char32_t, 1> const c2 = {{ 0xB80A }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB80A }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_099)
{
    // B80B;B80B;1105 1166 11AA;B80B;1105 1166 11AA; 
    // (렋; 렋; 렋; 렋; 렋; ) HANGUL SYLLABLE REGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB80B }};
        std::array<char32_t, 1> const c2 = {{ 0xB80B }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xB80B }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_100)
{
    // B80C;B80C;1105 1166 11AB;B80C;1105 1166 11AB; 
    // (렌; 렌; 렌; 렌; 렌; ) HANGUL SYLLABLE REN
    {
        std::array<char32_t, 1> const c1 = {{ 0xB80C }};
        std::array<char32_t, 1> const c2 = {{ 0xB80C }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xB80C }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_101)
{
    // B80D;B80D;1105 1166 11AC;B80D;1105 1166 11AC; 
    // (렍; 렍; 렍; 렍; 렍; ) HANGUL SYLLABLE RENJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB80D }};
        std::array<char32_t, 1> const c2 = {{ 0xB80D }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xB80D }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_102)
{
    // B80E;B80E;1105 1166 11AD;B80E;1105 1166 11AD; 
    // (렎; 렎; 렎; 렎; 렎; ) HANGUL SYLLABLE RENH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB80E }};
        std::array<char32_t, 1> const c2 = {{ 0xB80E }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xB80E }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_103)
{
    // B80F;B80F;1105 1166 11AE;B80F;1105 1166 11AE; 
    // (렏; 렏; 렏; 렏; 렏; ) HANGUL SYLLABLE RED
    {
        std::array<char32_t, 1> const c1 = {{ 0xB80F }};
        std::array<char32_t, 1> const c2 = {{ 0xB80F }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xB80F }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_104)
{
    // B810;B810;1105 1166 11AF;B810;1105 1166 11AF; 
    // (렐; 렐; 렐; 렐; 렐; ) HANGUL SYLLABLE REL
    {
        std::array<char32_t, 1> const c1 = {{ 0xB810 }};
        std::array<char32_t, 1> const c2 = {{ 0xB810 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xB810 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_105)
{
    // B811;B811;1105 1166 11B0;B811;1105 1166 11B0; 
    // (렑; 렑; 렑; 렑; 렑; ) HANGUL SYLLABLE RELG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB811 }};
        std::array<char32_t, 1> const c2 = {{ 0xB811 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB811 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_106)
{
    // B812;B812;1105 1166 11B1;B812;1105 1166 11B1; 
    // (렒; 렒; 렒; 렒; 렒; ) HANGUL SYLLABLE RELM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB812 }};
        std::array<char32_t, 1> const c2 = {{ 0xB812 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB812 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_107)
{
    // B813;B813;1105 1166 11B2;B813;1105 1166 11B2; 
    // (렓; 렓; 렓; 렓; 렓; ) HANGUL SYLLABLE RELB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB813 }};
        std::array<char32_t, 1> const c2 = {{ 0xB813 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB813 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_108)
{
    // B814;B814;1105 1166 11B3;B814;1105 1166 11B3; 
    // (렔; 렔; 렔; 렔; 렔; ) HANGUL SYLLABLE RELS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB814 }};
        std::array<char32_t, 1> const c2 = {{ 0xB814 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xB814 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_109)
{
    // B815;B815;1105 1166 11B4;B815;1105 1166 11B4; 
    // (렕; 렕; 렕; 렕; 렕; ) HANGUL SYLLABLE RELT
    {
        std::array<char32_t, 1> const c1 = {{ 0xB815 }};
        std::array<char32_t, 1> const c2 = {{ 0xB815 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xB815 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_110)
{
    // B816;B816;1105 1166 11B5;B816;1105 1166 11B5; 
    // (렖; 렖; 렖; 렖; 렖; ) HANGUL SYLLABLE RELP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB816 }};
        std::array<char32_t, 1> const c2 = {{ 0xB816 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xB816 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_111)
{
    // B817;B817;1105 1166 11B6;B817;1105 1166 11B6; 
    // (렗; 렗; 렗; 렗; 렗; ) HANGUL SYLLABLE RELH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB817 }};
        std::array<char32_t, 1> const c2 = {{ 0xB817 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xB817 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_112)
{
    // B818;B818;1105 1166 11B7;B818;1105 1166 11B7; 
    // (렘; 렘; 렘; 렘; 렘; ) HANGUL SYLLABLE REM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB818 }};
        std::array<char32_t, 1> const c2 = {{ 0xB818 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xB818 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_113)
{
    // B819;B819;1105 1166 11B8;B819;1105 1166 11B8; 
    // (렙; 렙; 렙; 렙; 렙; ) HANGUL SYLLABLE REB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB819 }};
        std::array<char32_t, 1> const c2 = {{ 0xB819 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB819 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_114)
{
    // B81A;B81A;1105 1166 11B9;B81A;1105 1166 11B9; 
    // (렚; 렚; 렚; 렚; 렚; ) HANGUL SYLLABLE REBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB81A }};
        std::array<char32_t, 1> const c2 = {{ 0xB81A }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB81A }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_115)
{
    // B81B;B81B;1105 1166 11BA;B81B;1105 1166 11BA; 
    // (렛; 렛; 렛; 렛; 렛; ) HANGUL SYLLABLE RES
    {
        std::array<char32_t, 1> const c1 = {{ 0xB81B }};
        std::array<char32_t, 1> const c2 = {{ 0xB81B }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xB81B }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_116)
{
    // B81C;B81C;1105 1166 11BB;B81C;1105 1166 11BB; 
    // (렜; 렜; 렜; 렜; 렜; ) HANGUL SYLLABLE RESS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB81C }};
        std::array<char32_t, 1> const c2 = {{ 0xB81C }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xB81C }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_117)
{
    // B81D;B81D;1105 1166 11BC;B81D;1105 1166 11BC; 
    // (렝; 렝; 렝; 렝; 렝; ) HANGUL SYLLABLE RENG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB81D }};
        std::array<char32_t, 1> const c2 = {{ 0xB81D }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xB81D }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_118)
{
    // B81E;B81E;1105 1166 11BD;B81E;1105 1166 11BD; 
    // (렞; 렞; 렞; 렞; 렞; ) HANGUL SYLLABLE REJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB81E }};
        std::array<char32_t, 1> const c2 = {{ 0xB81E }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xB81E }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_119)
{
    // B81F;B81F;1105 1166 11BE;B81F;1105 1166 11BE; 
    // (렟; 렟; 렟; 렟; 렟; ) HANGUL SYLLABLE REC
    {
        std::array<char32_t, 1> const c1 = {{ 0xB81F }};
        std::array<char32_t, 1> const c2 = {{ 0xB81F }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xB81F }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_120)
{
    // B820;B820;1105 1166 11BF;B820;1105 1166 11BF; 
    // (렠; 렠; 렠; 렠; 렠; ) HANGUL SYLLABLE REK
    {
        std::array<char32_t, 1> const c1 = {{ 0xB820 }};
        std::array<char32_t, 1> const c2 = {{ 0xB820 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xB820 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_121)
{
    // B821;B821;1105 1166 11C0;B821;1105 1166 11C0; 
    // (렡; 렡; 렡; 렡; 렡; ) HANGUL SYLLABLE RET
    {
        std::array<char32_t, 1> const c1 = {{ 0xB821 }};
        std::array<char32_t, 1> const c2 = {{ 0xB821 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB821 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_122)
{
    // B822;B822;1105 1166 11C1;B822;1105 1166 11C1; 
    // (렢; 렢; 렢; 렢; 렢; ) HANGUL SYLLABLE REP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB822 }};
        std::array<char32_t, 1> const c2 = {{ 0xB822 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB822 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_123)
{
    // B823;B823;1105 1166 11C2;B823;1105 1166 11C2; 
    // (렣; 렣; 렣; 렣; 렣; ) HANGUL SYLLABLE REH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB823 }};
        std::array<char32_t, 1> const c2 = {{ 0xB823 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1166, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB823 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1166, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_124)
{
    // B824;B824;1105 1167;B824;1105 1167; 
    // (려; 려; 려; 려; 려; ) HANGUL SYLLABLE RYEO
    {
        std::array<char32_t, 1> const c1 = {{ 0xB824 }};
        std::array<char32_t, 1> const c2 = {{ 0xB824 }};
        std::array<char32_t, 2> const c3 = {{ 0x1105, 0x1167 }};
        std::array<char32_t, 1> const c4 = {{ 0xB824 }};
        std::array<char32_t, 2> const c5 = {{ 0x1105, 0x1167 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_125)
{
    // B825;B825;1105 1167 11A8;B825;1105 1167 11A8; 
    // (력; 력; 력; 력; 력; ) HANGUL SYLLABLE RYEOG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB825 }};
        std::array<char32_t, 1> const c2 = {{ 0xB825 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB825 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_126)
{
    // B826;B826;1105 1167 11A9;B826;1105 1167 11A9; 
    // (렦; 렦; 렦; 렦; 렦; ) HANGUL SYLLABLE RYEOGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB826 }};
        std::array<char32_t, 1> const c2 = {{ 0xB826 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB826 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_127)
{
    // B827;B827;1105 1167 11AA;B827;1105 1167 11AA; 
    // (렧; 렧; 렧; 렧; 렧; ) HANGUL SYLLABLE RYEOGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB827 }};
        std::array<char32_t, 1> const c2 = {{ 0xB827 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xB827 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_128)
{
    // B828;B828;1105 1167 11AB;B828;1105 1167 11AB; 
    // (련; 련; 련; 련; 련; ) HANGUL SYLLABLE RYEON
    {
        std::array<char32_t, 1> const c1 = {{ 0xB828 }};
        std::array<char32_t, 1> const c2 = {{ 0xB828 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xB828 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_129)
{
    // B829;B829;1105 1167 11AC;B829;1105 1167 11AC; 
    // (렩; 렩; 렩; 렩; 렩; ) HANGUL SYLLABLE RYEONJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB829 }};
        std::array<char32_t, 1> const c2 = {{ 0xB829 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xB829 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_130)
{
    // B82A;B82A;1105 1167 11AD;B82A;1105 1167 11AD; 
    // (렪; 렪; 렪; 렪; 렪; ) HANGUL SYLLABLE RYEONH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB82A }};
        std::array<char32_t, 1> const c2 = {{ 0xB82A }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xB82A }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_131)
{
    // B82B;B82B;1105 1167 11AE;B82B;1105 1167 11AE; 
    // (렫; 렫; 렫; 렫; 렫; ) HANGUL SYLLABLE RYEOD
    {
        std::array<char32_t, 1> const c1 = {{ 0xB82B }};
        std::array<char32_t, 1> const c2 = {{ 0xB82B }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xB82B }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_132)
{
    // B82C;B82C;1105 1167 11AF;B82C;1105 1167 11AF; 
    // (렬; 렬; 렬; 렬; 렬; ) HANGUL SYLLABLE RYEOL
    {
        std::array<char32_t, 1> const c1 = {{ 0xB82C }};
        std::array<char32_t, 1> const c2 = {{ 0xB82C }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xB82C }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_133)
{
    // B82D;B82D;1105 1167 11B0;B82D;1105 1167 11B0; 
    // (렭; 렭; 렭; 렭; 렭; ) HANGUL SYLLABLE RYEOLG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB82D }};
        std::array<char32_t, 1> const c2 = {{ 0xB82D }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB82D }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_134)
{
    // B82E;B82E;1105 1167 11B1;B82E;1105 1167 11B1; 
    // (렮; 렮; 렮; 렮; 렮; ) HANGUL SYLLABLE RYEOLM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB82E }};
        std::array<char32_t, 1> const c2 = {{ 0xB82E }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB82E }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_135)
{
    // B82F;B82F;1105 1167 11B2;B82F;1105 1167 11B2; 
    // (렯; 렯; 렯; 렯; 렯; ) HANGUL SYLLABLE RYEOLB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB82F }};
        std::array<char32_t, 1> const c2 = {{ 0xB82F }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB82F }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_136)
{
    // B830;B830;1105 1167 11B3;B830;1105 1167 11B3; 
    // (렰; 렰; 렰; 렰; 렰; ) HANGUL SYLLABLE RYEOLS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB830 }};
        std::array<char32_t, 1> const c2 = {{ 0xB830 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xB830 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_137)
{
    // B831;B831;1105 1167 11B4;B831;1105 1167 11B4; 
    // (렱; 렱; 렱; 렱; 렱; ) HANGUL SYLLABLE RYEOLT
    {
        std::array<char32_t, 1> const c1 = {{ 0xB831 }};
        std::array<char32_t, 1> const c2 = {{ 0xB831 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xB831 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_138)
{
    // B832;B832;1105 1167 11B5;B832;1105 1167 11B5; 
    // (렲; 렲; 렲; 렲; 렲; ) HANGUL SYLLABLE RYEOLP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB832 }};
        std::array<char32_t, 1> const c2 = {{ 0xB832 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xB832 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_139)
{
    // B833;B833;1105 1167 11B6;B833;1105 1167 11B6; 
    // (렳; 렳; 렳; 렳; 렳; ) HANGUL SYLLABLE RYEOLH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB833 }};
        std::array<char32_t, 1> const c2 = {{ 0xB833 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xB833 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_140)
{
    // B834;B834;1105 1167 11B7;B834;1105 1167 11B7; 
    // (렴; 렴; 렴; 렴; 렴; ) HANGUL SYLLABLE RYEOM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB834 }};
        std::array<char32_t, 1> const c2 = {{ 0xB834 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xB834 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_141)
{
    // B835;B835;1105 1167 11B8;B835;1105 1167 11B8; 
    // (렵; 렵; 렵; 렵; 렵; ) HANGUL SYLLABLE RYEOB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB835 }};
        std::array<char32_t, 1> const c2 = {{ 0xB835 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB835 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_142)
{
    // B836;B836;1105 1167 11B9;B836;1105 1167 11B9; 
    // (렶; 렶; 렶; 렶; 렶; ) HANGUL SYLLABLE RYEOBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB836 }};
        std::array<char32_t, 1> const c2 = {{ 0xB836 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB836 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_143)
{
    // B837;B837;1105 1167 11BA;B837;1105 1167 11BA; 
    // (렷; 렷; 렷; 렷; 렷; ) HANGUL SYLLABLE RYEOS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB837 }};
        std::array<char32_t, 1> const c2 = {{ 0xB837 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xB837 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_144)
{
    // B838;B838;1105 1167 11BB;B838;1105 1167 11BB; 
    // (렸; 렸; 렸; 렸; 렸; ) HANGUL SYLLABLE RYEOSS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB838 }};
        std::array<char32_t, 1> const c2 = {{ 0xB838 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xB838 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_145)
{
    // B839;B839;1105 1167 11BC;B839;1105 1167 11BC; 
    // (령; 령; 령; 령; 령; ) HANGUL SYLLABLE RYEONG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB839 }};
        std::array<char32_t, 1> const c2 = {{ 0xB839 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xB839 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_146)
{
    // B83A;B83A;1105 1167 11BD;B83A;1105 1167 11BD; 
    // (렺; 렺; 렺; 렺; 렺; ) HANGUL SYLLABLE RYEOJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB83A }};
        std::array<char32_t, 1> const c2 = {{ 0xB83A }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xB83A }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_147)
{
    // B83B;B83B;1105 1167 11BE;B83B;1105 1167 11BE; 
    // (렻; 렻; 렻; 렻; 렻; ) HANGUL SYLLABLE RYEOC
    {
        std::array<char32_t, 1> const c1 = {{ 0xB83B }};
        std::array<char32_t, 1> const c2 = {{ 0xB83B }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xB83B }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_148)
{
    // B83C;B83C;1105 1167 11BF;B83C;1105 1167 11BF; 
    // (렼; 렼; 렼; 렼; 렼; ) HANGUL SYLLABLE RYEOK
    {
        std::array<char32_t, 1> const c1 = {{ 0xB83C }};
        std::array<char32_t, 1> const c2 = {{ 0xB83C }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xB83C }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_149)
{
    // B83D;B83D;1105 1167 11C0;B83D;1105 1167 11C0; 
    // (렽; 렽; 렽; 렽; 렽; ) HANGUL SYLLABLE RYEOT
    {
        std::array<char32_t, 1> const c1 = {{ 0xB83D }};
        std::array<char32_t, 1> const c2 = {{ 0xB83D }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB83D }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_150)
{
    // B83E;B83E;1105 1167 11C1;B83E;1105 1167 11C1; 
    // (렾; 렾; 렾; 렾; 렾; ) HANGUL SYLLABLE RYEOP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB83E }};
        std::array<char32_t, 1> const c2 = {{ 0xB83E }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB83E }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_151)
{
    // B83F;B83F;1105 1167 11C2;B83F;1105 1167 11C2; 
    // (렿; 렿; 렿; 렿; 렿; ) HANGUL SYLLABLE RYEOH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB83F }};
        std::array<char32_t, 1> const c2 = {{ 0xB83F }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1167, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB83F }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1167, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_152)
{
    // B840;B840;1105 1168;B840;1105 1168; 
    // (례; 례; 례; 례; 례; ) HANGUL SYLLABLE RYE
    {
        std::array<char32_t, 1> const c1 = {{ 0xB840 }};
        std::array<char32_t, 1> const c2 = {{ 0xB840 }};
        std::array<char32_t, 2> const c3 = {{ 0x1105, 0x1168 }};
        std::array<char32_t, 1> const c4 = {{ 0xB840 }};
        std::array<char32_t, 2> const c5 = {{ 0x1105, 0x1168 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_153)
{
    // B841;B841;1105 1168 11A8;B841;1105 1168 11A8; 
    // (롁; 롁; 롁; 롁; 롁; ) HANGUL SYLLABLE RYEG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB841 }};
        std::array<char32_t, 1> const c2 = {{ 0xB841 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB841 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_154)
{
    // B842;B842;1105 1168 11A9;B842;1105 1168 11A9; 
    // (롂; 롂; 롂; 롂; 롂; ) HANGUL SYLLABLE RYEGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB842 }};
        std::array<char32_t, 1> const c2 = {{ 0xB842 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB842 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_155)
{
    // B843;B843;1105 1168 11AA;B843;1105 1168 11AA; 
    // (롃; 롃; 롃; 롃; 롃; ) HANGUL SYLLABLE RYEGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB843 }};
        std::array<char32_t, 1> const c2 = {{ 0xB843 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xB843 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_156)
{
    // B844;B844;1105 1168 11AB;B844;1105 1168 11AB; 
    // (롄; 롄; 롄; 롄; 롄; ) HANGUL SYLLABLE RYEN
    {
        std::array<char32_t, 1> const c1 = {{ 0xB844 }};
        std::array<char32_t, 1> const c2 = {{ 0xB844 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xB844 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_157)
{
    // B845;B845;1105 1168 11AC;B845;1105 1168 11AC; 
    // (롅; 롅; 롅; 롅; 롅; ) HANGUL SYLLABLE RYENJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB845 }};
        std::array<char32_t, 1> const c2 = {{ 0xB845 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xB845 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_158)
{
    // B846;B846;1105 1168 11AD;B846;1105 1168 11AD; 
    // (롆; 롆; 롆; 롆; 롆; ) HANGUL SYLLABLE RYENH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB846 }};
        std::array<char32_t, 1> const c2 = {{ 0xB846 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xB846 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_159)
{
    // B847;B847;1105 1168 11AE;B847;1105 1168 11AE; 
    // (롇; 롇; 롇; 롇; 롇; ) HANGUL SYLLABLE RYED
    {
        std::array<char32_t, 1> const c1 = {{ 0xB847 }};
        std::array<char32_t, 1> const c2 = {{ 0xB847 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xB847 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_160)
{
    // B848;B848;1105 1168 11AF;B848;1105 1168 11AF; 
    // (롈; 롈; 롈; 롈; 롈; ) HANGUL SYLLABLE RYEL
    {
        std::array<char32_t, 1> const c1 = {{ 0xB848 }};
        std::array<char32_t, 1> const c2 = {{ 0xB848 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xB848 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_161)
{
    // B849;B849;1105 1168 11B0;B849;1105 1168 11B0; 
    // (롉; 롉; 롉; 롉; 롉; ) HANGUL SYLLABLE RYELG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB849 }};
        std::array<char32_t, 1> const c2 = {{ 0xB849 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB849 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_162)
{
    // B84A;B84A;1105 1168 11B1;B84A;1105 1168 11B1; 
    // (롊; 롊; 롊; 롊; 롊; ) HANGUL SYLLABLE RYELM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB84A }};
        std::array<char32_t, 1> const c2 = {{ 0xB84A }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB84A }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_163)
{
    // B84B;B84B;1105 1168 11B2;B84B;1105 1168 11B2; 
    // (롋; 롋; 롋; 롋; 롋; ) HANGUL SYLLABLE RYELB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB84B }};
        std::array<char32_t, 1> const c2 = {{ 0xB84B }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB84B }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_164)
{
    // B84C;B84C;1105 1168 11B3;B84C;1105 1168 11B3; 
    // (롌; 롌; 롌; 롌; 롌; ) HANGUL SYLLABLE RYELS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB84C }};
        std::array<char32_t, 1> const c2 = {{ 0xB84C }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xB84C }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_165)
{
    // B84D;B84D;1105 1168 11B4;B84D;1105 1168 11B4; 
    // (롍; 롍; 롍; 롍; 롍; ) HANGUL SYLLABLE RYELT
    {
        std::array<char32_t, 1> const c1 = {{ 0xB84D }};
        std::array<char32_t, 1> const c2 = {{ 0xB84D }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xB84D }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_166)
{
    // B84E;B84E;1105 1168 11B5;B84E;1105 1168 11B5; 
    // (롎; 롎; 롎; 롎; 롎; ) HANGUL SYLLABLE RYELP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB84E }};
        std::array<char32_t, 1> const c2 = {{ 0xB84E }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xB84E }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_167)
{
    // B84F;B84F;1105 1168 11B6;B84F;1105 1168 11B6; 
    // (롏; 롏; 롏; 롏; 롏; ) HANGUL SYLLABLE RYELH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB84F }};
        std::array<char32_t, 1> const c2 = {{ 0xB84F }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xB84F }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_168)
{
    // B850;B850;1105 1168 11B7;B850;1105 1168 11B7; 
    // (롐; 롐; 롐; 롐; 롐; ) HANGUL SYLLABLE RYEM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB850 }};
        std::array<char32_t, 1> const c2 = {{ 0xB850 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xB850 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_169)
{
    // B851;B851;1105 1168 11B8;B851;1105 1168 11B8; 
    // (롑; 롑; 롑; 롑; 롑; ) HANGUL SYLLABLE RYEB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB851 }};
        std::array<char32_t, 1> const c2 = {{ 0xB851 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB851 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_170)
{
    // B852;B852;1105 1168 11B9;B852;1105 1168 11B9; 
    // (롒; 롒; 롒; 롒; 롒; ) HANGUL SYLLABLE RYEBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB852 }};
        std::array<char32_t, 1> const c2 = {{ 0xB852 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB852 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_171)
{
    // B853;B853;1105 1168 11BA;B853;1105 1168 11BA; 
    // (롓; 롓; 롓; 롓; 롓; ) HANGUL SYLLABLE RYES
    {
        std::array<char32_t, 1> const c1 = {{ 0xB853 }};
        std::array<char32_t, 1> const c2 = {{ 0xB853 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xB853 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_172)
{
    // B854;B854;1105 1168 11BB;B854;1105 1168 11BB; 
    // (롔; 롔; 롔; 롔; 롔; ) HANGUL SYLLABLE RYESS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB854 }};
        std::array<char32_t, 1> const c2 = {{ 0xB854 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xB854 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_173)
{
    // B855;B855;1105 1168 11BC;B855;1105 1168 11BC; 
    // (롕; 롕; 롕; 롕; 롕; ) HANGUL SYLLABLE RYENG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB855 }};
        std::array<char32_t, 1> const c2 = {{ 0xB855 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xB855 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_174)
{
    // B856;B856;1105 1168 11BD;B856;1105 1168 11BD; 
    // (롖; 롖; 롖; 롖; 롖; ) HANGUL SYLLABLE RYEJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB856 }};
        std::array<char32_t, 1> const c2 = {{ 0xB856 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xB856 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_175)
{
    // B857;B857;1105 1168 11BE;B857;1105 1168 11BE; 
    // (롗; 롗; 롗; 롗; 롗; ) HANGUL SYLLABLE RYEC
    {
        std::array<char32_t, 1> const c1 = {{ 0xB857 }};
        std::array<char32_t, 1> const c2 = {{ 0xB857 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xB857 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_176)
{
    // B858;B858;1105 1168 11BF;B858;1105 1168 11BF; 
    // (롘; 롘; 롘; 롘; 롘; ) HANGUL SYLLABLE RYEK
    {
        std::array<char32_t, 1> const c1 = {{ 0xB858 }};
        std::array<char32_t, 1> const c2 = {{ 0xB858 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xB858 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_177)
{
    // B859;B859;1105 1168 11C0;B859;1105 1168 11C0; 
    // (롙; 롙; 롙; 롙; 롙; ) HANGUL SYLLABLE RYET
    {
        std::array<char32_t, 1> const c1 = {{ 0xB859 }};
        std::array<char32_t, 1> const c2 = {{ 0xB859 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB859 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_178)
{
    // B85A;B85A;1105 1168 11C1;B85A;1105 1168 11C1; 
    // (롚; 롚; 롚; 롚; 롚; ) HANGUL SYLLABLE RYEP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB85A }};
        std::array<char32_t, 1> const c2 = {{ 0xB85A }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB85A }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_179)
{
    // B85B;B85B;1105 1168 11C2;B85B;1105 1168 11C2; 
    // (롛; 롛; 롛; 롛; 롛; ) HANGUL SYLLABLE RYEH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB85B }};
        std::array<char32_t, 1> const c2 = {{ 0xB85B }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1168, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB85B }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1168, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_180)
{
    // B85C;B85C;1105 1169;B85C;1105 1169; 
    // (로; 로; 로; 로; 로; ) HANGUL SYLLABLE RO
    {
        std::array<char32_t, 1> const c1 = {{ 0xB85C }};
        std::array<char32_t, 1> const c2 = {{ 0xB85C }};
        std::array<char32_t, 2> const c3 = {{ 0x1105, 0x1169 }};
        std::array<char32_t, 1> const c4 = {{ 0xB85C }};
        std::array<char32_t, 2> const c5 = {{ 0x1105, 0x1169 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_181)
{
    // B85D;B85D;1105 1169 11A8;B85D;1105 1169 11A8; 
    // (록; 록; 록; 록; 록; ) HANGUL SYLLABLE ROG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB85D }};
        std::array<char32_t, 1> const c2 = {{ 0xB85D }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1169, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB85D }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1169, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_182)
{
    // B85E;B85E;1105 1169 11A9;B85E;1105 1169 11A9; 
    // (롞; 롞; 롞; 롞; 롞; ) HANGUL SYLLABLE ROGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB85E }};
        std::array<char32_t, 1> const c2 = {{ 0xB85E }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1169, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB85E }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1169, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_183)
{
    // B85F;B85F;1105 1169 11AA;B85F;1105 1169 11AA; 
    // (롟; 롟; 롟; 롟; 롟; ) HANGUL SYLLABLE ROGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB85F }};
        std::array<char32_t, 1> const c2 = {{ 0xB85F }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1169, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xB85F }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1169, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_184)
{
    // B860;B860;1105 1169 11AB;B860;1105 1169 11AB; 
    // (론; 론; 론; 론; 론; ) HANGUL SYLLABLE RON
    {
        std::array<char32_t, 1> const c1 = {{ 0xB860 }};
        std::array<char32_t, 1> const c2 = {{ 0xB860 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1169, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xB860 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1169, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_185)
{
    // B861;B861;1105 1169 11AC;B861;1105 1169 11AC; 
    // (롡; 롡; 롡; 롡; 롡; ) HANGUL SYLLABLE RONJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xB861 }};
        std::array<char32_t, 1> const c2 = {{ 0xB861 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1169, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xB861 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1169, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_186)
{
    // B862;B862;1105 1169 11AD;B862;1105 1169 11AD; 
    // (롢; 롢; 롢; 롢; 롢; ) HANGUL SYLLABLE RONH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB862 }};
        std::array<char32_t, 1> const c2 = {{ 0xB862 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1169, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xB862 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1169, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_187)
{
    // B863;B863;1105 1169 11AE;B863;1105 1169 11AE; 
    // (롣; 롣; 롣; 롣; 롣; ) HANGUL SYLLABLE ROD
    {
        std::array<char32_t, 1> const c1 = {{ 0xB863 }};
        std::array<char32_t, 1> const c2 = {{ 0xB863 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1169, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xB863 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1169, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_188)
{
    // B864;B864;1105 1169 11AF;B864;1105 1169 11AF; 
    // (롤; 롤; 롤; 롤; 롤; ) HANGUL SYLLABLE ROL
    {
        std::array<char32_t, 1> const c1 = {{ 0xB864 }};
        std::array<char32_t, 1> const c2 = {{ 0xB864 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1169, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xB864 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1169, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_189)
{
    // B865;B865;1105 1169 11B0;B865;1105 1169 11B0; 
    // (롥; 롥; 롥; 롥; 롥; ) HANGUL SYLLABLE ROLG
    {
        std::array<char32_t, 1> const c1 = {{ 0xB865 }};
        std::array<char32_t, 1> const c2 = {{ 0xB865 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1169, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xB865 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1169, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_190)
{
    // B866;B866;1105 1169 11B1;B866;1105 1169 11B1; 
    // (롦; 롦; 롦; 롦; 롦; ) HANGUL SYLLABLE ROLM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB866 }};
        std::array<char32_t, 1> const c2 = {{ 0xB866 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1169, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xB866 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1169, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_191)
{
    // B867;B867;1105 1169 11B2;B867;1105 1169 11B2; 
    // (롧; 롧; 롧; 롧; 롧; ) HANGUL SYLLABLE ROLB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB867 }};
        std::array<char32_t, 1> const c2 = {{ 0xB867 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1169, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xB867 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1169, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_192)
{
    // B868;B868;1105 1169 11B3;B868;1105 1169 11B3; 
    // (롨; 롨; 롨; 롨; 롨; ) HANGUL SYLLABLE ROLS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB868 }};
        std::array<char32_t, 1> const c2 = {{ 0xB868 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1169, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xB868 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1169, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_193)
{
    // B869;B869;1105 1169 11B4;B869;1105 1169 11B4; 
    // (롩; 롩; 롩; 롩; 롩; ) HANGUL SYLLABLE ROLT
    {
        std::array<char32_t, 1> const c1 = {{ 0xB869 }};
        std::array<char32_t, 1> const c2 = {{ 0xB869 }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1169, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xB869 }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1169, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_194)
{
    // B86A;B86A;1105 1169 11B5;B86A;1105 1169 11B5; 
    // (롪; 롪; 롪; 롪; 롪; ) HANGUL SYLLABLE ROLP
    {
        std::array<char32_t, 1> const c1 = {{ 0xB86A }};
        std::array<char32_t, 1> const c2 = {{ 0xB86A }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1169, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xB86A }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1169, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_195)
{
    // B86B;B86B;1105 1169 11B6;B86B;1105 1169 11B6; 
    // (롫; 롫; 롫; 롫; 롫; ) HANGUL SYLLABLE ROLH
    {
        std::array<char32_t, 1> const c1 = {{ 0xB86B }};
        std::array<char32_t, 1> const c2 = {{ 0xB86B }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1169, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xB86B }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1169, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_196)
{
    // B86C;B86C;1105 1169 11B7;B86C;1105 1169 11B7; 
    // (롬; 롬; 롬; 롬; 롬; ) HANGUL SYLLABLE ROM
    {
        std::array<char32_t, 1> const c1 = {{ 0xB86C }};
        std::array<char32_t, 1> const c2 = {{ 0xB86C }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1169, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xB86C }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1169, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_197)
{
    // B86D;B86D;1105 1169 11B8;B86D;1105 1169 11B8; 
    // (롭; 롭; 롭; 롭; 롭; ) HANGUL SYLLABLE ROB
    {
        std::array<char32_t, 1> const c1 = {{ 0xB86D }};
        std::array<char32_t, 1> const c2 = {{ 0xB86D }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1169, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xB86D }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1169, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_198)
{
    // B86E;B86E;1105 1169 11B9;B86E;1105 1169 11B9; 
    // (롮; 롮; 롮; 롮; 롮; ) HANGUL SYLLABLE ROBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB86E }};
        std::array<char32_t, 1> const c2 = {{ 0xB86E }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1169, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xB86E }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1169, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkd_027_199)
{
    // B86F;B86F;1105 1169 11BA;B86F;1105 1169 11BA; 
    // (롯; 롯; 롯; 롯; 롯; ) HANGUL SYLLABLE ROS
    {
        std::array<char32_t, 1> const c1 = {{ 0xB86F }};
        std::array<char32_t, 1> const c2 = {{ 0xB86F }};
        std::array<char32_t, 3> const c3 = {{ 0x1105, 0x1169, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xB86F }};
        std::array<char32_t, 3> const c5 = {{ 0x1105, 0x1169, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::kd>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


