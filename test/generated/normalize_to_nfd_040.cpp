// Copyright (C) 2020 T. Zachary Laine
//
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
// Warning! This file is autogenerated.
#include <boost/text/normalize_string.hpp>
#include <boost/text/transcode_view.hpp>
#include <boost/text/string_utility.hpp>

#include <gtest/gtest.h>

#include <algorithm>



TEST(normalization, nfd_040_000)
{
    // C1D0;C1D0;1109 116B 11B3;C1D0;1109 116B 11B3; 
    // (쇐; 쇐; 쇐; 쇐; 쇐; ) HANGUL SYLLABLE SWAELS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1D0 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1D0 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1D0 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_001)
{
    // C1D1;C1D1;1109 116B 11B4;C1D1;1109 116B 11B4; 
    // (쇑; 쇑; 쇑; 쇑; 쇑; ) HANGUL SYLLABLE SWAELT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1D1 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1D1 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1D1 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_002)
{
    // C1D2;C1D2;1109 116B 11B5;C1D2;1109 116B 11B5; 
    // (쇒; 쇒; 쇒; 쇒; 쇒; ) HANGUL SYLLABLE SWAELP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1D2 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1D2 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1D2 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_003)
{
    // C1D3;C1D3;1109 116B 11B6;C1D3;1109 116B 11B6; 
    // (쇓; 쇓; 쇓; 쇓; 쇓; ) HANGUL SYLLABLE SWAELH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1D3 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1D3 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1D3 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_004)
{
    // C1D4;C1D4;1109 116B 11B7;C1D4;1109 116B 11B7; 
    // (쇔; 쇔; 쇔; 쇔; 쇔; ) HANGUL SYLLABLE SWAEM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1D4 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1D4 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1D4 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_005)
{
    // C1D5;C1D5;1109 116B 11B8;C1D5;1109 116B 11B8; 
    // (쇕; 쇕; 쇕; 쇕; 쇕; ) HANGUL SYLLABLE SWAEB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1D5 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1D5 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1D5 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_006)
{
    // C1D6;C1D6;1109 116B 11B9;C1D6;1109 116B 11B9; 
    // (쇖; 쇖; 쇖; 쇖; 쇖; ) HANGUL SYLLABLE SWAEBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1D6 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1D6 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1D6 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_007)
{
    // C1D7;C1D7;1109 116B 11BA;C1D7;1109 116B 11BA; 
    // (쇗; 쇗; 쇗; 쇗; 쇗; ) HANGUL SYLLABLE SWAES
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1D7 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1D7 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1D7 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_008)
{
    // C1D8;C1D8;1109 116B 11BB;C1D8;1109 116B 11BB; 
    // (쇘; 쇘; 쇘; 쇘; 쇘; ) HANGUL SYLLABLE SWAESS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1D8 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1D8 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1D8 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_009)
{
    // C1D9;C1D9;1109 116B 11BC;C1D9;1109 116B 11BC; 
    // (쇙; 쇙; 쇙; 쇙; 쇙; ) HANGUL SYLLABLE SWAENG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1D9 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1D9 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1D9 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_010)
{
    // C1DA;C1DA;1109 116B 11BD;C1DA;1109 116B 11BD; 
    // (쇚; 쇚; 쇚; 쇚; 쇚; ) HANGUL SYLLABLE SWAEJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1DA }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1DA }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1DA }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_011)
{
    // C1DB;C1DB;1109 116B 11BE;C1DB;1109 116B 11BE; 
    // (쇛; 쇛; 쇛; 쇛; 쇛; ) HANGUL SYLLABLE SWAEC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1DB }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1DB }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1DB }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_012)
{
    // C1DC;C1DC;1109 116B 11BF;C1DC;1109 116B 11BF; 
    // (쇜; 쇜; 쇜; 쇜; 쇜; ) HANGUL SYLLABLE SWAEK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1DC }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1DC }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1DC }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_013)
{
    // C1DD;C1DD;1109 116B 11C0;C1DD;1109 116B 11C0; 
    // (쇝; 쇝; 쇝; 쇝; 쇝; ) HANGUL SYLLABLE SWAET
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1DD }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1DD }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1DD }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_014)
{
    // C1DE;C1DE;1109 116B 11C1;C1DE;1109 116B 11C1; 
    // (쇞; 쇞; 쇞; 쇞; 쇞; ) HANGUL SYLLABLE SWAEP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1DE }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1DE }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1DE }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_015)
{
    // C1DF;C1DF;1109 116B 11C2;C1DF;1109 116B 11C2; 
    // (쇟; 쇟; 쇟; 쇟; 쇟; ) HANGUL SYLLABLE SWAEH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1DF }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1DF }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116B, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1DF }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116B, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_016)
{
    // C1E0;C1E0;1109 116C;C1E0;1109 116C; 
    // (쇠; 쇠; 쇠; 쇠; 쇠; ) HANGUL SYLLABLE SOE
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1E0 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1E0 }};
        std::array<uint32_t, 2> const c3 = {{ 0x1109, 0x116C }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1E0 }};
        std::array<uint32_t, 2> const c5 = {{ 0x1109, 0x116C }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_017)
{
    // C1E1;C1E1;1109 116C 11A8;C1E1;1109 116C 11A8; 
    // (쇡; 쇡; 쇡; 쇡; 쇡; ) HANGUL SYLLABLE SOEG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1E1 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1E1 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1E1 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_018)
{
    // C1E2;C1E2;1109 116C 11A9;C1E2;1109 116C 11A9; 
    // (쇢; 쇢; 쇢; 쇢; 쇢; ) HANGUL SYLLABLE SOEGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1E2 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1E2 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1E2 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_019)
{
    // C1E3;C1E3;1109 116C 11AA;C1E3;1109 116C 11AA; 
    // (쇣; 쇣; 쇣; 쇣; 쇣; ) HANGUL SYLLABLE SOEGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1E3 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1E3 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1E3 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_020)
{
    // C1E4;C1E4;1109 116C 11AB;C1E4;1109 116C 11AB; 
    // (쇤; 쇤; 쇤; 쇤; 쇤; ) HANGUL SYLLABLE SOEN
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1E4 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1E4 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1E4 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_021)
{
    // C1E5;C1E5;1109 116C 11AC;C1E5;1109 116C 11AC; 
    // (쇥; 쇥; 쇥; 쇥; 쇥; ) HANGUL SYLLABLE SOENJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1E5 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1E5 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1E5 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_022)
{
    // C1E6;C1E6;1109 116C 11AD;C1E6;1109 116C 11AD; 
    // (쇦; 쇦; 쇦; 쇦; 쇦; ) HANGUL SYLLABLE SOENH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1E6 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1E6 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1E6 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_023)
{
    // C1E7;C1E7;1109 116C 11AE;C1E7;1109 116C 11AE; 
    // (쇧; 쇧; 쇧; 쇧; 쇧; ) HANGUL SYLLABLE SOED
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1E7 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1E7 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1E7 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_024)
{
    // C1E8;C1E8;1109 116C 11AF;C1E8;1109 116C 11AF; 
    // (쇨; 쇨; 쇨; 쇨; 쇨; ) HANGUL SYLLABLE SOEL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1E8 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1E8 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1E8 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_025)
{
    // C1E9;C1E9;1109 116C 11B0;C1E9;1109 116C 11B0; 
    // (쇩; 쇩; 쇩; 쇩; 쇩; ) HANGUL SYLLABLE SOELG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1E9 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1E9 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1E9 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_026)
{
    // C1EA;C1EA;1109 116C 11B1;C1EA;1109 116C 11B1; 
    // (쇪; 쇪; 쇪; 쇪; 쇪; ) HANGUL SYLLABLE SOELM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1EA }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1EA }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1EA }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_027)
{
    // C1EB;C1EB;1109 116C 11B2;C1EB;1109 116C 11B2; 
    // (쇫; 쇫; 쇫; 쇫; 쇫; ) HANGUL SYLLABLE SOELB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1EB }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1EB }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1EB }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_028)
{
    // C1EC;C1EC;1109 116C 11B3;C1EC;1109 116C 11B3; 
    // (쇬; 쇬; 쇬; 쇬; 쇬; ) HANGUL SYLLABLE SOELS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1EC }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1EC }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1EC }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_029)
{
    // C1ED;C1ED;1109 116C 11B4;C1ED;1109 116C 11B4; 
    // (쇭; 쇭; 쇭; 쇭; 쇭; ) HANGUL SYLLABLE SOELT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1ED }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1ED }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1ED }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_030)
{
    // C1EE;C1EE;1109 116C 11B5;C1EE;1109 116C 11B5; 
    // (쇮; 쇮; 쇮; 쇮; 쇮; ) HANGUL SYLLABLE SOELP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1EE }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1EE }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1EE }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_031)
{
    // C1EF;C1EF;1109 116C 11B6;C1EF;1109 116C 11B6; 
    // (쇯; 쇯; 쇯; 쇯; 쇯; ) HANGUL SYLLABLE SOELH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1EF }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1EF }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1EF }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_032)
{
    // C1F0;C1F0;1109 116C 11B7;C1F0;1109 116C 11B7; 
    // (쇰; 쇰; 쇰; 쇰; 쇰; ) HANGUL SYLLABLE SOEM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1F0 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1F0 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1F0 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_033)
{
    // C1F1;C1F1;1109 116C 11B8;C1F1;1109 116C 11B8; 
    // (쇱; 쇱; 쇱; 쇱; 쇱; ) HANGUL SYLLABLE SOEB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1F1 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1F1 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1F1 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_034)
{
    // C1F2;C1F2;1109 116C 11B9;C1F2;1109 116C 11B9; 
    // (쇲; 쇲; 쇲; 쇲; 쇲; ) HANGUL SYLLABLE SOEBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1F2 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1F2 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1F2 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_035)
{
    // C1F3;C1F3;1109 116C 11BA;C1F3;1109 116C 11BA; 
    // (쇳; 쇳; 쇳; 쇳; 쇳; ) HANGUL SYLLABLE SOES
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1F3 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1F3 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1F3 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_036)
{
    // C1F4;C1F4;1109 116C 11BB;C1F4;1109 116C 11BB; 
    // (쇴; 쇴; 쇴; 쇴; 쇴; ) HANGUL SYLLABLE SOESS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1F4 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1F4 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1F4 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_037)
{
    // C1F5;C1F5;1109 116C 11BC;C1F5;1109 116C 11BC; 
    // (쇵; 쇵; 쇵; 쇵; 쇵; ) HANGUL SYLLABLE SOENG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1F5 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1F5 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1F5 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_038)
{
    // C1F6;C1F6;1109 116C 11BD;C1F6;1109 116C 11BD; 
    // (쇶; 쇶; 쇶; 쇶; 쇶; ) HANGUL SYLLABLE SOEJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1F6 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1F6 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1F6 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_039)
{
    // C1F7;C1F7;1109 116C 11BE;C1F7;1109 116C 11BE; 
    // (쇷; 쇷; 쇷; 쇷; 쇷; ) HANGUL SYLLABLE SOEC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1F7 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1F7 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1F7 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_040)
{
    // C1F8;C1F8;1109 116C 11BF;C1F8;1109 116C 11BF; 
    // (쇸; 쇸; 쇸; 쇸; 쇸; ) HANGUL SYLLABLE SOEK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1F8 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1F8 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1F8 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_041)
{
    // C1F9;C1F9;1109 116C 11C0;C1F9;1109 116C 11C0; 
    // (쇹; 쇹; 쇹; 쇹; 쇹; ) HANGUL SYLLABLE SOET
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1F9 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1F9 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1F9 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_042)
{
    // C1FA;C1FA;1109 116C 11C1;C1FA;1109 116C 11C1; 
    // (쇺; 쇺; 쇺; 쇺; 쇺; ) HANGUL SYLLABLE SOEP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1FA }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1FA }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1FA }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_043)
{
    // C1FB;C1FB;1109 116C 11C2;C1FB;1109 116C 11C2; 
    // (쇻; 쇻; 쇻; 쇻; 쇻; ) HANGUL SYLLABLE SOEH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1FB }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1FB }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116C, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1FB }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116C, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_044)
{
    // C1FC;C1FC;1109 116D;C1FC;1109 116D; 
    // (쇼; 쇼; 쇼; 쇼; 쇼; ) HANGUL SYLLABLE SYO
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1FC }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1FC }};
        std::array<uint32_t, 2> const c3 = {{ 0x1109, 0x116D }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1FC }};
        std::array<uint32_t, 2> const c5 = {{ 0x1109, 0x116D }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_045)
{
    // C1FD;C1FD;1109 116D 11A8;C1FD;1109 116D 11A8; 
    // (쇽; 쇽; 쇽; 쇽; 쇽; ) HANGUL SYLLABLE SYOG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1FD }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1FD }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1FD }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_046)
{
    // C1FE;C1FE;1109 116D 11A9;C1FE;1109 116D 11A9; 
    // (쇾; 쇾; 쇾; 쇾; 쇾; ) HANGUL SYLLABLE SYOGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1FE }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1FE }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1FE }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_047)
{
    // C1FF;C1FF;1109 116D 11AA;C1FF;1109 116D 11AA; 
    // (쇿; 쇿; 쇿; 쇿; 쇿; ) HANGUL SYLLABLE SYOGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC1FF }};
        std::array<uint32_t, 1> const c2 = {{ 0xC1FF }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xC1FF }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_048)
{
    // C200;C200;1109 116D 11AB;C200;1109 116D 11AB; 
    // (숀; 숀; 숀; 숀; 숀; ) HANGUL SYLLABLE SYON
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC200 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC200 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xC200 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_049)
{
    // C201;C201;1109 116D 11AC;C201;1109 116D 11AC; 
    // (숁; 숁; 숁; 숁; 숁; ) HANGUL SYLLABLE SYONJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC201 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC201 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xC201 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_050)
{
    // C202;C202;1109 116D 11AD;C202;1109 116D 11AD; 
    // (숂; 숂; 숂; 숂; 숂; ) HANGUL SYLLABLE SYONH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC202 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC202 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xC202 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_051)
{
    // C203;C203;1109 116D 11AE;C203;1109 116D 11AE; 
    // (숃; 숃; 숃; 숃; 숃; ) HANGUL SYLLABLE SYOD
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC203 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC203 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xC203 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_052)
{
    // C204;C204;1109 116D 11AF;C204;1109 116D 11AF; 
    // (숄; 숄; 숄; 숄; 숄; ) HANGUL SYLLABLE SYOL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC204 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC204 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xC204 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_053)
{
    // C205;C205;1109 116D 11B0;C205;1109 116D 11B0; 
    // (숅; 숅; 숅; 숅; 숅; ) HANGUL SYLLABLE SYOLG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC205 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC205 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC205 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_054)
{
    // C206;C206;1109 116D 11B1;C206;1109 116D 11B1; 
    // (숆; 숆; 숆; 숆; 숆; ) HANGUL SYLLABLE SYOLM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC206 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC206 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC206 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_055)
{
    // C207;C207;1109 116D 11B2;C207;1109 116D 11B2; 
    // (숇; 숇; 숇; 숇; 숇; ) HANGUL SYLLABLE SYOLB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC207 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC207 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC207 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_056)
{
    // C208;C208;1109 116D 11B3;C208;1109 116D 11B3; 
    // (숈; 숈; 숈; 숈; 숈; ) HANGUL SYLLABLE SYOLS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC208 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC208 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC208 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_057)
{
    // C209;C209;1109 116D 11B4;C209;1109 116D 11B4; 
    // (숉; 숉; 숉; 숉; 숉; ) HANGUL SYLLABLE SYOLT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC209 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC209 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC209 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_058)
{
    // C20A;C20A;1109 116D 11B5;C20A;1109 116D 11B5; 
    // (숊; 숊; 숊; 숊; 숊; ) HANGUL SYLLABLE SYOLP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC20A }};
        std::array<uint32_t, 1> const c2 = {{ 0xC20A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC20A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_059)
{
    // C20B;C20B;1109 116D 11B6;C20B;1109 116D 11B6; 
    // (숋; 숋; 숋; 숋; 숋; ) HANGUL SYLLABLE SYOLH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC20B }};
        std::array<uint32_t, 1> const c2 = {{ 0xC20B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC20B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_060)
{
    // C20C;C20C;1109 116D 11B7;C20C;1109 116D 11B7; 
    // (숌; 숌; 숌; 숌; 숌; ) HANGUL SYLLABLE SYOM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC20C }};
        std::array<uint32_t, 1> const c2 = {{ 0xC20C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC20C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_061)
{
    // C20D;C20D;1109 116D 11B8;C20D;1109 116D 11B8; 
    // (숍; 숍; 숍; 숍; 숍; ) HANGUL SYLLABLE SYOB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC20D }};
        std::array<uint32_t, 1> const c2 = {{ 0xC20D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC20D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_062)
{
    // C20E;C20E;1109 116D 11B9;C20E;1109 116D 11B9; 
    // (숎; 숎; 숎; 숎; 숎; ) HANGUL SYLLABLE SYOBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC20E }};
        std::array<uint32_t, 1> const c2 = {{ 0xC20E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC20E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_063)
{
    // C20F;C20F;1109 116D 11BA;C20F;1109 116D 11BA; 
    // (숏; 숏; 숏; 숏; 숏; ) HANGUL SYLLABLE SYOS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC20F }};
        std::array<uint32_t, 1> const c2 = {{ 0xC20F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xC20F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_064)
{
    // C210;C210;1109 116D 11BB;C210;1109 116D 11BB; 
    // (숐; 숐; 숐; 숐; 숐; ) HANGUL SYLLABLE SYOSS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC210 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC210 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xC210 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_065)
{
    // C211;C211;1109 116D 11BC;C211;1109 116D 11BC; 
    // (숑; 숑; 숑; 숑; 숑; ) HANGUL SYLLABLE SYONG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC211 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC211 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xC211 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_066)
{
    // C212;C212;1109 116D 11BD;C212;1109 116D 11BD; 
    // (숒; 숒; 숒; 숒; 숒; ) HANGUL SYLLABLE SYOJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC212 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC212 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xC212 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_067)
{
    // C213;C213;1109 116D 11BE;C213;1109 116D 11BE; 
    // (숓; 숓; 숓; 숓; 숓; ) HANGUL SYLLABLE SYOC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC213 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC213 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xC213 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_068)
{
    // C214;C214;1109 116D 11BF;C214;1109 116D 11BF; 
    // (숔; 숔; 숔; 숔; 숔; ) HANGUL SYLLABLE SYOK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC214 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC214 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xC214 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_069)
{
    // C215;C215;1109 116D 11C0;C215;1109 116D 11C0; 
    // (숕; 숕; 숕; 숕; 숕; ) HANGUL SYLLABLE SYOT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC215 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC215 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC215 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_070)
{
    // C216;C216;1109 116D 11C1;C216;1109 116D 11C1; 
    // (숖; 숖; 숖; 숖; 숖; ) HANGUL SYLLABLE SYOP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC216 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC216 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC216 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_071)
{
    // C217;C217;1109 116D 11C2;C217;1109 116D 11C2; 
    // (숗; 숗; 숗; 숗; 숗; ) HANGUL SYLLABLE SYOH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC217 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC217 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116D, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC217 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116D, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_072)
{
    // C218;C218;1109 116E;C218;1109 116E; 
    // (수; 수; 수; 수; 수; ) HANGUL SYLLABLE SU
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC218 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC218 }};
        std::array<uint32_t, 2> const c3 = {{ 0x1109, 0x116E }};
        std::array<uint32_t, 1> const c4 = {{ 0xC218 }};
        std::array<uint32_t, 2> const c5 = {{ 0x1109, 0x116E }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_073)
{
    // C219;C219;1109 116E 11A8;C219;1109 116E 11A8; 
    // (숙; 숙; 숙; 숙; 숙; ) HANGUL SYLLABLE SUG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC219 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC219 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC219 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_074)
{
    // C21A;C21A;1109 116E 11A9;C21A;1109 116E 11A9; 
    // (숚; 숚; 숚; 숚; 숚; ) HANGUL SYLLABLE SUGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC21A }};
        std::array<uint32_t, 1> const c2 = {{ 0xC21A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC21A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_075)
{
    // C21B;C21B;1109 116E 11AA;C21B;1109 116E 11AA; 
    // (숛; 숛; 숛; 숛; 숛; ) HANGUL SYLLABLE SUGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC21B }};
        std::array<uint32_t, 1> const c2 = {{ 0xC21B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xC21B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_076)
{
    // C21C;C21C;1109 116E 11AB;C21C;1109 116E 11AB; 
    // (순; 순; 순; 순; 순; ) HANGUL SYLLABLE SUN
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC21C }};
        std::array<uint32_t, 1> const c2 = {{ 0xC21C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xC21C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_077)
{
    // C21D;C21D;1109 116E 11AC;C21D;1109 116E 11AC; 
    // (숝; 숝; 숝; 숝; 숝; ) HANGUL SYLLABLE SUNJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC21D }};
        std::array<uint32_t, 1> const c2 = {{ 0xC21D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xC21D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_078)
{
    // C21E;C21E;1109 116E 11AD;C21E;1109 116E 11AD; 
    // (숞; 숞; 숞; 숞; 숞; ) HANGUL SYLLABLE SUNH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC21E }};
        std::array<uint32_t, 1> const c2 = {{ 0xC21E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xC21E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_079)
{
    // C21F;C21F;1109 116E 11AE;C21F;1109 116E 11AE; 
    // (숟; 숟; 숟; 숟; 숟; ) HANGUL SYLLABLE SUD
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC21F }};
        std::array<uint32_t, 1> const c2 = {{ 0xC21F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xC21F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_080)
{
    // C220;C220;1109 116E 11AF;C220;1109 116E 11AF; 
    // (술; 술; 술; 술; 술; ) HANGUL SYLLABLE SUL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC220 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC220 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xC220 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_081)
{
    // C221;C221;1109 116E 11B0;C221;1109 116E 11B0; 
    // (숡; 숡; 숡; 숡; 숡; ) HANGUL SYLLABLE SULG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC221 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC221 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC221 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_082)
{
    // C222;C222;1109 116E 11B1;C222;1109 116E 11B1; 
    // (숢; 숢; 숢; 숢; 숢; ) HANGUL SYLLABLE SULM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC222 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC222 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC222 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_083)
{
    // C223;C223;1109 116E 11B2;C223;1109 116E 11B2; 
    // (숣; 숣; 숣; 숣; 숣; ) HANGUL SYLLABLE SULB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC223 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC223 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC223 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_084)
{
    // C224;C224;1109 116E 11B3;C224;1109 116E 11B3; 
    // (숤; 숤; 숤; 숤; 숤; ) HANGUL SYLLABLE SULS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC224 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC224 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC224 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_085)
{
    // C225;C225;1109 116E 11B4;C225;1109 116E 11B4; 
    // (숥; 숥; 숥; 숥; 숥; ) HANGUL SYLLABLE SULT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC225 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC225 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC225 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_086)
{
    // C226;C226;1109 116E 11B5;C226;1109 116E 11B5; 
    // (숦; 숦; 숦; 숦; 숦; ) HANGUL SYLLABLE SULP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC226 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC226 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC226 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_087)
{
    // C227;C227;1109 116E 11B6;C227;1109 116E 11B6; 
    // (숧; 숧; 숧; 숧; 숧; ) HANGUL SYLLABLE SULH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC227 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC227 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC227 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_088)
{
    // C228;C228;1109 116E 11B7;C228;1109 116E 11B7; 
    // (숨; 숨; 숨; 숨; 숨; ) HANGUL SYLLABLE SUM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC228 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC228 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC228 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_089)
{
    // C229;C229;1109 116E 11B8;C229;1109 116E 11B8; 
    // (숩; 숩; 숩; 숩; 숩; ) HANGUL SYLLABLE SUB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC229 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC229 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC229 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_090)
{
    // C22A;C22A;1109 116E 11B9;C22A;1109 116E 11B9; 
    // (숪; 숪; 숪; 숪; 숪; ) HANGUL SYLLABLE SUBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC22A }};
        std::array<uint32_t, 1> const c2 = {{ 0xC22A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC22A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_091)
{
    // C22B;C22B;1109 116E 11BA;C22B;1109 116E 11BA; 
    // (숫; 숫; 숫; 숫; 숫; ) HANGUL SYLLABLE SUS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC22B }};
        std::array<uint32_t, 1> const c2 = {{ 0xC22B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xC22B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_092)
{
    // C22C;C22C;1109 116E 11BB;C22C;1109 116E 11BB; 
    // (숬; 숬; 숬; 숬; 숬; ) HANGUL SYLLABLE SUSS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC22C }};
        std::array<uint32_t, 1> const c2 = {{ 0xC22C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xC22C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_093)
{
    // C22D;C22D;1109 116E 11BC;C22D;1109 116E 11BC; 
    // (숭; 숭; 숭; 숭; 숭; ) HANGUL SYLLABLE SUNG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC22D }};
        std::array<uint32_t, 1> const c2 = {{ 0xC22D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xC22D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_094)
{
    // C22E;C22E;1109 116E 11BD;C22E;1109 116E 11BD; 
    // (숮; 숮; 숮; 숮; 숮; ) HANGUL SYLLABLE SUJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC22E }};
        std::array<uint32_t, 1> const c2 = {{ 0xC22E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xC22E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_095)
{
    // C22F;C22F;1109 116E 11BE;C22F;1109 116E 11BE; 
    // (숯; 숯; 숯; 숯; 숯; ) HANGUL SYLLABLE SUC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC22F }};
        std::array<uint32_t, 1> const c2 = {{ 0xC22F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xC22F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_096)
{
    // C230;C230;1109 116E 11BF;C230;1109 116E 11BF; 
    // (숰; 숰; 숰; 숰; 숰; ) HANGUL SYLLABLE SUK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC230 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC230 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xC230 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_097)
{
    // C231;C231;1109 116E 11C0;C231;1109 116E 11C0; 
    // (숱; 숱; 숱; 숱; 숱; ) HANGUL SYLLABLE SUT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC231 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC231 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC231 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_098)
{
    // C232;C232;1109 116E 11C1;C232;1109 116E 11C1; 
    // (숲; 숲; 숲; 숲; 숲; ) HANGUL SYLLABLE SUP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC232 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC232 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC232 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_099)
{
    // C233;C233;1109 116E 11C2;C233;1109 116E 11C2; 
    // (숳; 숳; 숳; 숳; 숳; ) HANGUL SYLLABLE SUH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC233 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC233 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116E, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC233 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116E, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_100)
{
    // C234;C234;1109 116F;C234;1109 116F; 
    // (숴; 숴; 숴; 숴; 숴; ) HANGUL SYLLABLE SWEO
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC234 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC234 }};
        std::array<uint32_t, 2> const c3 = {{ 0x1109, 0x116F }};
        std::array<uint32_t, 1> const c4 = {{ 0xC234 }};
        std::array<uint32_t, 2> const c5 = {{ 0x1109, 0x116F }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_101)
{
    // C235;C235;1109 116F 11A8;C235;1109 116F 11A8; 
    // (숵; 숵; 숵; 숵; 숵; ) HANGUL SYLLABLE SWEOG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC235 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC235 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC235 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_102)
{
    // C236;C236;1109 116F 11A9;C236;1109 116F 11A9; 
    // (숶; 숶; 숶; 숶; 숶; ) HANGUL SYLLABLE SWEOGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC236 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC236 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC236 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_103)
{
    // C237;C237;1109 116F 11AA;C237;1109 116F 11AA; 
    // (숷; 숷; 숷; 숷; 숷; ) HANGUL SYLLABLE SWEOGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC237 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC237 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xC237 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_104)
{
    // C238;C238;1109 116F 11AB;C238;1109 116F 11AB; 
    // (숸; 숸; 숸; 숸; 숸; ) HANGUL SYLLABLE SWEON
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC238 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC238 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xC238 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_105)
{
    // C239;C239;1109 116F 11AC;C239;1109 116F 11AC; 
    // (숹; 숹; 숹; 숹; 숹; ) HANGUL SYLLABLE SWEONJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC239 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC239 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xC239 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_106)
{
    // C23A;C23A;1109 116F 11AD;C23A;1109 116F 11AD; 
    // (숺; 숺; 숺; 숺; 숺; ) HANGUL SYLLABLE SWEONH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC23A }};
        std::array<uint32_t, 1> const c2 = {{ 0xC23A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xC23A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_107)
{
    // C23B;C23B;1109 116F 11AE;C23B;1109 116F 11AE; 
    // (숻; 숻; 숻; 숻; 숻; ) HANGUL SYLLABLE SWEOD
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC23B }};
        std::array<uint32_t, 1> const c2 = {{ 0xC23B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xC23B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_108)
{
    // C23C;C23C;1109 116F 11AF;C23C;1109 116F 11AF; 
    // (숼; 숼; 숼; 숼; 숼; ) HANGUL SYLLABLE SWEOL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC23C }};
        std::array<uint32_t, 1> const c2 = {{ 0xC23C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xC23C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_109)
{
    // C23D;C23D;1109 116F 11B0;C23D;1109 116F 11B0; 
    // (숽; 숽; 숽; 숽; 숽; ) HANGUL SYLLABLE SWEOLG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC23D }};
        std::array<uint32_t, 1> const c2 = {{ 0xC23D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC23D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_110)
{
    // C23E;C23E;1109 116F 11B1;C23E;1109 116F 11B1; 
    // (숾; 숾; 숾; 숾; 숾; ) HANGUL SYLLABLE SWEOLM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC23E }};
        std::array<uint32_t, 1> const c2 = {{ 0xC23E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC23E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_111)
{
    // C23F;C23F;1109 116F 11B2;C23F;1109 116F 11B2; 
    // (숿; 숿; 숿; 숿; 숿; ) HANGUL SYLLABLE SWEOLB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC23F }};
        std::array<uint32_t, 1> const c2 = {{ 0xC23F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC23F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_112)
{
    // C240;C240;1109 116F 11B3;C240;1109 116F 11B3; 
    // (쉀; 쉀; 쉀; 쉀; 쉀; ) HANGUL SYLLABLE SWEOLS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC240 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC240 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC240 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_113)
{
    // C241;C241;1109 116F 11B4;C241;1109 116F 11B4; 
    // (쉁; 쉁; 쉁; 쉁; 쉁; ) HANGUL SYLLABLE SWEOLT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC241 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC241 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC241 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_114)
{
    // C242;C242;1109 116F 11B5;C242;1109 116F 11B5; 
    // (쉂; 쉂; 쉂; 쉂; 쉂; ) HANGUL SYLLABLE SWEOLP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC242 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC242 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC242 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_115)
{
    // C243;C243;1109 116F 11B6;C243;1109 116F 11B6; 
    // (쉃; 쉃; 쉃; 쉃; 쉃; ) HANGUL SYLLABLE SWEOLH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC243 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC243 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC243 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_116)
{
    // C244;C244;1109 116F 11B7;C244;1109 116F 11B7; 
    // (쉄; 쉄; 쉄; 쉄; 쉄; ) HANGUL SYLLABLE SWEOM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC244 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC244 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC244 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_117)
{
    // C245;C245;1109 116F 11B8;C245;1109 116F 11B8; 
    // (쉅; 쉅; 쉅; 쉅; 쉅; ) HANGUL SYLLABLE SWEOB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC245 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC245 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC245 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_118)
{
    // C246;C246;1109 116F 11B9;C246;1109 116F 11B9; 
    // (쉆; 쉆; 쉆; 쉆; 쉆; ) HANGUL SYLLABLE SWEOBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC246 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC246 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC246 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_119)
{
    // C247;C247;1109 116F 11BA;C247;1109 116F 11BA; 
    // (쉇; 쉇; 쉇; 쉇; 쉇; ) HANGUL SYLLABLE SWEOS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC247 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC247 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xC247 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_120)
{
    // C248;C248;1109 116F 11BB;C248;1109 116F 11BB; 
    // (쉈; 쉈; 쉈; 쉈; 쉈; ) HANGUL SYLLABLE SWEOSS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC248 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC248 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xC248 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_121)
{
    // C249;C249;1109 116F 11BC;C249;1109 116F 11BC; 
    // (쉉; 쉉; 쉉; 쉉; 쉉; ) HANGUL SYLLABLE SWEONG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC249 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC249 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xC249 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_122)
{
    // C24A;C24A;1109 116F 11BD;C24A;1109 116F 11BD; 
    // (쉊; 쉊; 쉊; 쉊; 쉊; ) HANGUL SYLLABLE SWEOJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC24A }};
        std::array<uint32_t, 1> const c2 = {{ 0xC24A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xC24A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_123)
{
    // C24B;C24B;1109 116F 11BE;C24B;1109 116F 11BE; 
    // (쉋; 쉋; 쉋; 쉋; 쉋; ) HANGUL SYLLABLE SWEOC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC24B }};
        std::array<uint32_t, 1> const c2 = {{ 0xC24B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xC24B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_124)
{
    // C24C;C24C;1109 116F 11BF;C24C;1109 116F 11BF; 
    // (쉌; 쉌; 쉌; 쉌; 쉌; ) HANGUL SYLLABLE SWEOK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC24C }};
        std::array<uint32_t, 1> const c2 = {{ 0xC24C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xC24C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_125)
{
    // C24D;C24D;1109 116F 11C0;C24D;1109 116F 11C0; 
    // (쉍; 쉍; 쉍; 쉍; 쉍; ) HANGUL SYLLABLE SWEOT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC24D }};
        std::array<uint32_t, 1> const c2 = {{ 0xC24D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC24D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_126)
{
    // C24E;C24E;1109 116F 11C1;C24E;1109 116F 11C1; 
    // (쉎; 쉎; 쉎; 쉎; 쉎; ) HANGUL SYLLABLE SWEOP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC24E }};
        std::array<uint32_t, 1> const c2 = {{ 0xC24E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC24E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_127)
{
    // C24F;C24F;1109 116F 11C2;C24F;1109 116F 11C2; 
    // (쉏; 쉏; 쉏; 쉏; 쉏; ) HANGUL SYLLABLE SWEOH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC24F }};
        std::array<uint32_t, 1> const c2 = {{ 0xC24F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x116F, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC24F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x116F, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_128)
{
    // C250;C250;1109 1170;C250;1109 1170; 
    // (쉐; 쉐; 쉐; 쉐; 쉐; ) HANGUL SYLLABLE SWE
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC250 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC250 }};
        std::array<uint32_t, 2> const c3 = {{ 0x1109, 0x1170 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC250 }};
        std::array<uint32_t, 2> const c5 = {{ 0x1109, 0x1170 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_129)
{
    // C251;C251;1109 1170 11A8;C251;1109 1170 11A8; 
    // (쉑; 쉑; 쉑; 쉑; 쉑; ) HANGUL SYLLABLE SWEG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC251 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC251 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC251 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_130)
{
    // C252;C252;1109 1170 11A9;C252;1109 1170 11A9; 
    // (쉒; 쉒; 쉒; 쉒; 쉒; ) HANGUL SYLLABLE SWEGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC252 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC252 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC252 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_131)
{
    // C253;C253;1109 1170 11AA;C253;1109 1170 11AA; 
    // (쉓; 쉓; 쉓; 쉓; 쉓; ) HANGUL SYLLABLE SWEGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC253 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC253 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xC253 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_132)
{
    // C254;C254;1109 1170 11AB;C254;1109 1170 11AB; 
    // (쉔; 쉔; 쉔; 쉔; 쉔; ) HANGUL SYLLABLE SWEN
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC254 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC254 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xC254 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_133)
{
    // C255;C255;1109 1170 11AC;C255;1109 1170 11AC; 
    // (쉕; 쉕; 쉕; 쉕; 쉕; ) HANGUL SYLLABLE SWENJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC255 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC255 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xC255 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_134)
{
    // C256;C256;1109 1170 11AD;C256;1109 1170 11AD; 
    // (쉖; 쉖; 쉖; 쉖; 쉖; ) HANGUL SYLLABLE SWENH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC256 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC256 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xC256 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_135)
{
    // C257;C257;1109 1170 11AE;C257;1109 1170 11AE; 
    // (쉗; 쉗; 쉗; 쉗; 쉗; ) HANGUL SYLLABLE SWED
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC257 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC257 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xC257 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_136)
{
    // C258;C258;1109 1170 11AF;C258;1109 1170 11AF; 
    // (쉘; 쉘; 쉘; 쉘; 쉘; ) HANGUL SYLLABLE SWEL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC258 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC258 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xC258 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_137)
{
    // C259;C259;1109 1170 11B0;C259;1109 1170 11B0; 
    // (쉙; 쉙; 쉙; 쉙; 쉙; ) HANGUL SYLLABLE SWELG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC259 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC259 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC259 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_138)
{
    // C25A;C25A;1109 1170 11B1;C25A;1109 1170 11B1; 
    // (쉚; 쉚; 쉚; 쉚; 쉚; ) HANGUL SYLLABLE SWELM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC25A }};
        std::array<uint32_t, 1> const c2 = {{ 0xC25A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC25A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_139)
{
    // C25B;C25B;1109 1170 11B2;C25B;1109 1170 11B2; 
    // (쉛; 쉛; 쉛; 쉛; 쉛; ) HANGUL SYLLABLE SWELB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC25B }};
        std::array<uint32_t, 1> const c2 = {{ 0xC25B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC25B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_140)
{
    // C25C;C25C;1109 1170 11B3;C25C;1109 1170 11B3; 
    // (쉜; 쉜; 쉜; 쉜; 쉜; ) HANGUL SYLLABLE SWELS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC25C }};
        std::array<uint32_t, 1> const c2 = {{ 0xC25C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC25C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_141)
{
    // C25D;C25D;1109 1170 11B4;C25D;1109 1170 11B4; 
    // (쉝; 쉝; 쉝; 쉝; 쉝; ) HANGUL SYLLABLE SWELT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC25D }};
        std::array<uint32_t, 1> const c2 = {{ 0xC25D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC25D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_142)
{
    // C25E;C25E;1109 1170 11B5;C25E;1109 1170 11B5; 
    // (쉞; 쉞; 쉞; 쉞; 쉞; ) HANGUL SYLLABLE SWELP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC25E }};
        std::array<uint32_t, 1> const c2 = {{ 0xC25E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC25E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_143)
{
    // C25F;C25F;1109 1170 11B6;C25F;1109 1170 11B6; 
    // (쉟; 쉟; 쉟; 쉟; 쉟; ) HANGUL SYLLABLE SWELH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC25F }};
        std::array<uint32_t, 1> const c2 = {{ 0xC25F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC25F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_144)
{
    // C260;C260;1109 1170 11B7;C260;1109 1170 11B7; 
    // (쉠; 쉠; 쉠; 쉠; 쉠; ) HANGUL SYLLABLE SWEM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC260 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC260 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC260 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_145)
{
    // C261;C261;1109 1170 11B8;C261;1109 1170 11B8; 
    // (쉡; 쉡; 쉡; 쉡; 쉡; ) HANGUL SYLLABLE SWEB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC261 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC261 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC261 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_146)
{
    // C262;C262;1109 1170 11B9;C262;1109 1170 11B9; 
    // (쉢; 쉢; 쉢; 쉢; 쉢; ) HANGUL SYLLABLE SWEBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC262 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC262 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC262 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_147)
{
    // C263;C263;1109 1170 11BA;C263;1109 1170 11BA; 
    // (쉣; 쉣; 쉣; 쉣; 쉣; ) HANGUL SYLLABLE SWES
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC263 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC263 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xC263 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_148)
{
    // C264;C264;1109 1170 11BB;C264;1109 1170 11BB; 
    // (쉤; 쉤; 쉤; 쉤; 쉤; ) HANGUL SYLLABLE SWESS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC264 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC264 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xC264 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_149)
{
    // C265;C265;1109 1170 11BC;C265;1109 1170 11BC; 
    // (쉥; 쉥; 쉥; 쉥; 쉥; ) HANGUL SYLLABLE SWENG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC265 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC265 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xC265 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_150)
{
    // C266;C266;1109 1170 11BD;C266;1109 1170 11BD; 
    // (쉦; 쉦; 쉦; 쉦; 쉦; ) HANGUL SYLLABLE SWEJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC266 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC266 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xC266 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_151)
{
    // C267;C267;1109 1170 11BE;C267;1109 1170 11BE; 
    // (쉧; 쉧; 쉧; 쉧; 쉧; ) HANGUL SYLLABLE SWEC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC267 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC267 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xC267 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_152)
{
    // C268;C268;1109 1170 11BF;C268;1109 1170 11BF; 
    // (쉨; 쉨; 쉨; 쉨; 쉨; ) HANGUL SYLLABLE SWEK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC268 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC268 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xC268 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_153)
{
    // C269;C269;1109 1170 11C0;C269;1109 1170 11C0; 
    // (쉩; 쉩; 쉩; 쉩; 쉩; ) HANGUL SYLLABLE SWET
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC269 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC269 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC269 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_154)
{
    // C26A;C26A;1109 1170 11C1;C26A;1109 1170 11C1; 
    // (쉪; 쉪; 쉪; 쉪; 쉪; ) HANGUL SYLLABLE SWEP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC26A }};
        std::array<uint32_t, 1> const c2 = {{ 0xC26A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC26A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_155)
{
    // C26B;C26B;1109 1170 11C2;C26B;1109 1170 11C2; 
    // (쉫; 쉫; 쉫; 쉫; 쉫; ) HANGUL SYLLABLE SWEH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC26B }};
        std::array<uint32_t, 1> const c2 = {{ 0xC26B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1170, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC26B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1170, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_156)
{
    // C26C;C26C;1109 1171;C26C;1109 1171; 
    // (쉬; 쉬; 쉬; 쉬; 쉬; ) HANGUL SYLLABLE SWI
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC26C }};
        std::array<uint32_t, 1> const c2 = {{ 0xC26C }};
        std::array<uint32_t, 2> const c3 = {{ 0x1109, 0x1171 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC26C }};
        std::array<uint32_t, 2> const c5 = {{ 0x1109, 0x1171 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_157)
{
    // C26D;C26D;1109 1171 11A8;C26D;1109 1171 11A8; 
    // (쉭; 쉭; 쉭; 쉭; 쉭; ) HANGUL SYLLABLE SWIG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC26D }};
        std::array<uint32_t, 1> const c2 = {{ 0xC26D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC26D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_158)
{
    // C26E;C26E;1109 1171 11A9;C26E;1109 1171 11A9; 
    // (쉮; 쉮; 쉮; 쉮; 쉮; ) HANGUL SYLLABLE SWIGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC26E }};
        std::array<uint32_t, 1> const c2 = {{ 0xC26E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC26E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_159)
{
    // C26F;C26F;1109 1171 11AA;C26F;1109 1171 11AA; 
    // (쉯; 쉯; 쉯; 쉯; 쉯; ) HANGUL SYLLABLE SWIGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC26F }};
        std::array<uint32_t, 1> const c2 = {{ 0xC26F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xC26F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_160)
{
    // C270;C270;1109 1171 11AB;C270;1109 1171 11AB; 
    // (쉰; 쉰; 쉰; 쉰; 쉰; ) HANGUL SYLLABLE SWIN
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC270 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC270 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xC270 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_161)
{
    // C271;C271;1109 1171 11AC;C271;1109 1171 11AC; 
    // (쉱; 쉱; 쉱; 쉱; 쉱; ) HANGUL SYLLABLE SWINJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC271 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC271 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xC271 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_162)
{
    // C272;C272;1109 1171 11AD;C272;1109 1171 11AD; 
    // (쉲; 쉲; 쉲; 쉲; 쉲; ) HANGUL SYLLABLE SWINH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC272 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC272 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xC272 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_163)
{
    // C273;C273;1109 1171 11AE;C273;1109 1171 11AE; 
    // (쉳; 쉳; 쉳; 쉳; 쉳; ) HANGUL SYLLABLE SWID
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC273 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC273 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xC273 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_164)
{
    // C274;C274;1109 1171 11AF;C274;1109 1171 11AF; 
    // (쉴; 쉴; 쉴; 쉴; 쉴; ) HANGUL SYLLABLE SWIL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC274 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC274 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xC274 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_165)
{
    // C275;C275;1109 1171 11B0;C275;1109 1171 11B0; 
    // (쉵; 쉵; 쉵; 쉵; 쉵; ) HANGUL SYLLABLE SWILG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC275 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC275 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC275 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_166)
{
    // C276;C276;1109 1171 11B1;C276;1109 1171 11B1; 
    // (쉶; 쉶; 쉶; 쉶; 쉶; ) HANGUL SYLLABLE SWILM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC276 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC276 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC276 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_167)
{
    // C277;C277;1109 1171 11B2;C277;1109 1171 11B2; 
    // (쉷; 쉷; 쉷; 쉷; 쉷; ) HANGUL SYLLABLE SWILB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC277 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC277 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC277 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_168)
{
    // C278;C278;1109 1171 11B3;C278;1109 1171 11B3; 
    // (쉸; 쉸; 쉸; 쉸; 쉸; ) HANGUL SYLLABLE SWILS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC278 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC278 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC278 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_169)
{
    // C279;C279;1109 1171 11B4;C279;1109 1171 11B4; 
    // (쉹; 쉹; 쉹; 쉹; 쉹; ) HANGUL SYLLABLE SWILT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC279 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC279 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC279 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_170)
{
    // C27A;C27A;1109 1171 11B5;C27A;1109 1171 11B5; 
    // (쉺; 쉺; 쉺; 쉺; 쉺; ) HANGUL SYLLABLE SWILP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC27A }};
        std::array<uint32_t, 1> const c2 = {{ 0xC27A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC27A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_171)
{
    // C27B;C27B;1109 1171 11B6;C27B;1109 1171 11B6; 
    // (쉻; 쉻; 쉻; 쉻; 쉻; ) HANGUL SYLLABLE SWILH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC27B }};
        std::array<uint32_t, 1> const c2 = {{ 0xC27B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC27B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_172)
{
    // C27C;C27C;1109 1171 11B7;C27C;1109 1171 11B7; 
    // (쉼; 쉼; 쉼; 쉼; 쉼; ) HANGUL SYLLABLE SWIM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC27C }};
        std::array<uint32_t, 1> const c2 = {{ 0xC27C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC27C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_173)
{
    // C27D;C27D;1109 1171 11B8;C27D;1109 1171 11B8; 
    // (쉽; 쉽; 쉽; 쉽; 쉽; ) HANGUL SYLLABLE SWIB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC27D }};
        std::array<uint32_t, 1> const c2 = {{ 0xC27D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC27D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_174)
{
    // C27E;C27E;1109 1171 11B9;C27E;1109 1171 11B9; 
    // (쉾; 쉾; 쉾; 쉾; 쉾; ) HANGUL SYLLABLE SWIBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC27E }};
        std::array<uint32_t, 1> const c2 = {{ 0xC27E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC27E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_175)
{
    // C27F;C27F;1109 1171 11BA;C27F;1109 1171 11BA; 
    // (쉿; 쉿; 쉿; 쉿; 쉿; ) HANGUL SYLLABLE SWIS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC27F }};
        std::array<uint32_t, 1> const c2 = {{ 0xC27F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xC27F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_176)
{
    // C280;C280;1109 1171 11BB;C280;1109 1171 11BB; 
    // (슀; 슀; 슀; 슀; 슀; ) HANGUL SYLLABLE SWISS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC280 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC280 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xC280 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_177)
{
    // C281;C281;1109 1171 11BC;C281;1109 1171 11BC; 
    // (슁; 슁; 슁; 슁; 슁; ) HANGUL SYLLABLE SWING
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC281 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC281 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xC281 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_178)
{
    // C282;C282;1109 1171 11BD;C282;1109 1171 11BD; 
    // (슂; 슂; 슂; 슂; 슂; ) HANGUL SYLLABLE SWIJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC282 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC282 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xC282 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_179)
{
    // C283;C283;1109 1171 11BE;C283;1109 1171 11BE; 
    // (슃; 슃; 슃; 슃; 슃; ) HANGUL SYLLABLE SWIC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC283 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC283 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xC283 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_180)
{
    // C284;C284;1109 1171 11BF;C284;1109 1171 11BF; 
    // (슄; 슄; 슄; 슄; 슄; ) HANGUL SYLLABLE SWIK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC284 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC284 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xC284 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_181)
{
    // C285;C285;1109 1171 11C0;C285;1109 1171 11C0; 
    // (슅; 슅; 슅; 슅; 슅; ) HANGUL SYLLABLE SWIT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC285 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC285 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC285 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_182)
{
    // C286;C286;1109 1171 11C1;C286;1109 1171 11C1; 
    // (슆; 슆; 슆; 슆; 슆; ) HANGUL SYLLABLE SWIP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC286 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC286 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC286 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_183)
{
    // C287;C287;1109 1171 11C2;C287;1109 1171 11C2; 
    // (슇; 슇; 슇; 슇; 슇; ) HANGUL SYLLABLE SWIH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC287 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC287 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1171, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC287 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1171, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_184)
{
    // C288;C288;1109 1172;C288;1109 1172; 
    // (슈; 슈; 슈; 슈; 슈; ) HANGUL SYLLABLE SYU
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC288 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC288 }};
        std::array<uint32_t, 2> const c3 = {{ 0x1109, 0x1172 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC288 }};
        std::array<uint32_t, 2> const c5 = {{ 0x1109, 0x1172 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_185)
{
    // C289;C289;1109 1172 11A8;C289;1109 1172 11A8; 
    // (슉; 슉; 슉; 슉; 슉; ) HANGUL SYLLABLE SYUG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC289 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC289 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1172, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC289 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1172, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_186)
{
    // C28A;C28A;1109 1172 11A9;C28A;1109 1172 11A9; 
    // (슊; 슊; 슊; 슊; 슊; ) HANGUL SYLLABLE SYUGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC28A }};
        std::array<uint32_t, 1> const c2 = {{ 0xC28A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1172, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC28A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1172, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_187)
{
    // C28B;C28B;1109 1172 11AA;C28B;1109 1172 11AA; 
    // (슋; 슋; 슋; 슋; 슋; ) HANGUL SYLLABLE SYUGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC28B }};
        std::array<uint32_t, 1> const c2 = {{ 0xC28B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1172, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xC28B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1172, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_188)
{
    // C28C;C28C;1109 1172 11AB;C28C;1109 1172 11AB; 
    // (슌; 슌; 슌; 슌; 슌; ) HANGUL SYLLABLE SYUN
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC28C }};
        std::array<uint32_t, 1> const c2 = {{ 0xC28C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1172, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xC28C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1172, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_189)
{
    // C28D;C28D;1109 1172 11AC;C28D;1109 1172 11AC; 
    // (슍; 슍; 슍; 슍; 슍; ) HANGUL SYLLABLE SYUNJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC28D }};
        std::array<uint32_t, 1> const c2 = {{ 0xC28D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1172, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xC28D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1172, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_190)
{
    // C28E;C28E;1109 1172 11AD;C28E;1109 1172 11AD; 
    // (슎; 슎; 슎; 슎; 슎; ) HANGUL SYLLABLE SYUNH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC28E }};
        std::array<uint32_t, 1> const c2 = {{ 0xC28E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1172, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xC28E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1172, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_191)
{
    // C28F;C28F;1109 1172 11AE;C28F;1109 1172 11AE; 
    // (슏; 슏; 슏; 슏; 슏; ) HANGUL SYLLABLE SYUD
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC28F }};
        std::array<uint32_t, 1> const c2 = {{ 0xC28F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1172, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xC28F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1172, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_192)
{
    // C290;C290;1109 1172 11AF;C290;1109 1172 11AF; 
    // (슐; 슐; 슐; 슐; 슐; ) HANGUL SYLLABLE SYUL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC290 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC290 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1172, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xC290 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1172, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_193)
{
    // C291;C291;1109 1172 11B0;C291;1109 1172 11B0; 
    // (슑; 슑; 슑; 슑; 슑; ) HANGUL SYLLABLE SYULG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC291 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC291 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1172, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC291 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1172, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_194)
{
    // C292;C292;1109 1172 11B1;C292;1109 1172 11B1; 
    // (슒; 슒; 슒; 슒; 슒; ) HANGUL SYLLABLE SYULM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC292 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC292 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1172, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC292 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1172, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_195)
{
    // C293;C293;1109 1172 11B2;C293;1109 1172 11B2; 
    // (슓; 슓; 슓; 슓; 슓; ) HANGUL SYLLABLE SYULB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC293 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC293 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1172, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC293 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1172, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_196)
{
    // C294;C294;1109 1172 11B3;C294;1109 1172 11B3; 
    // (슔; 슔; 슔; 슔; 슔; ) HANGUL SYLLABLE SYULS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC294 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC294 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1172, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC294 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1172, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_197)
{
    // C295;C295;1109 1172 11B4;C295;1109 1172 11B4; 
    // (슕; 슕; 슕; 슕; 슕; ) HANGUL SYLLABLE SYULT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC295 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC295 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1172, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC295 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1172, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_198)
{
    // C296;C296;1109 1172 11B5;C296;1109 1172 11B5; 
    // (슖; 슖; 슖; 슖; 슖; ) HANGUL SYLLABLE SYULP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC296 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC296 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1172, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC296 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1172, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_040_199)
{
    // C297;C297;1109 1172 11B6;C297;1109 1172 11B6; 
    // (슗; 슗; 슗; 슗; 슗; ) HANGUL SYLLABLE SYULH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xC297 }};
        std::array<uint32_t, 1> const c2 = {{ 0xC297 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1109, 0x1172, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xC297 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1109, 0x1172, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized_nfc(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized_nfc(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized_nfkc(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized_nfd(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized_nfkd(c5.begin(), c5.end()));



        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


