// Copyright (C) 2020 T. Zachary Laine
//
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

// Warning! This file is autogenerated.
#include <boost/text/normalize_string.hpp>
#include <boost/text/transcode_view.hpp>
#include <boost/text/string_utility.hpp>

#include <gtest/gtest.h>

#include <algorithm>



TEST(normalization, nfd_071_000)
{
    // FBAF;FBAF;FBAF;06D2;06D2; 
    // (ﮯ; ﮯ; ﮯ; ے; ے; ) ARABIC LETTER YEH BARREE FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBAF }};
        std::array<char32_t, 1> const c2 = {{ 0xFBAF }};
        std::array<char32_t, 1> const c3 = {{ 0xFBAF }};
        std::array<char32_t, 1> const c4 = {{ 0x06D2 }};
        std::array<char32_t, 1> const c5 = {{ 0x06D2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_001)
{
    // FBB0;FBB0;FBB0;06D3;06D2 0654; 
    // (ﮰ; ﮰ; ﮰ; ۓ; ے◌ٔ; ) ARABIC LETTER YEH BARREE WITH HAMZA ABOVE ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBB0 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBB0 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBB0 }};
        std::array<char32_t, 1> const c4 = {{ 0x06D3 }};
        std::array<char32_t, 2> const c5 = {{ 0x06D2, 0x0654 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_002)
{
    // FBB1;FBB1;FBB1;06D3;06D2 0654; 
    // (ﮱ; ﮱ; ﮱ; ۓ; ے◌ٔ; ) ARABIC LETTER YEH BARREE WITH HAMZA ABOVE FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBB1 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBB1 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBB1 }};
        std::array<char32_t, 1> const c4 = {{ 0x06D3 }};
        std::array<char32_t, 2> const c5 = {{ 0x06D2, 0x0654 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_003)
{
    // FBD3;FBD3;FBD3;06AD;06AD; 
    // (ﯓ; ﯓ; ﯓ; ڭ; ڭ; ) ARABIC LETTER NG ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBD3 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBD3 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBD3 }};
        std::array<char32_t, 1> const c4 = {{ 0x06AD }};
        std::array<char32_t, 1> const c5 = {{ 0x06AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_004)
{
    // FBD4;FBD4;FBD4;06AD;06AD; 
    // (ﯔ; ﯔ; ﯔ; ڭ; ڭ; ) ARABIC LETTER NG FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBD4 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBD4 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBD4 }};
        std::array<char32_t, 1> const c4 = {{ 0x06AD }};
        std::array<char32_t, 1> const c5 = {{ 0x06AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_005)
{
    // FBD5;FBD5;FBD5;06AD;06AD; 
    // (ﯕ; ﯕ; ﯕ; ڭ; ڭ; ) ARABIC LETTER NG INITIAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBD5 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBD5 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBD5 }};
        std::array<char32_t, 1> const c4 = {{ 0x06AD }};
        std::array<char32_t, 1> const c5 = {{ 0x06AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_006)
{
    // FBD6;FBD6;FBD6;06AD;06AD; 
    // (ﯖ; ﯖ; ﯖ; ڭ; ڭ; ) ARABIC LETTER NG MEDIAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBD6 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBD6 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBD6 }};
        std::array<char32_t, 1> const c4 = {{ 0x06AD }};
        std::array<char32_t, 1> const c5 = {{ 0x06AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_007)
{
    // FBD7;FBD7;FBD7;06C7;06C7; 
    // (ﯗ; ﯗ; ﯗ; ۇ; ۇ; ) ARABIC LETTER U ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBD7 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBD7 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBD7 }};
        std::array<char32_t, 1> const c4 = {{ 0x06C7 }};
        std::array<char32_t, 1> const c5 = {{ 0x06C7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_008)
{
    // FBD8;FBD8;FBD8;06C7;06C7; 
    // (ﯘ; ﯘ; ﯘ; ۇ; ۇ; ) ARABIC LETTER U FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBD8 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBD8 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBD8 }};
        std::array<char32_t, 1> const c4 = {{ 0x06C7 }};
        std::array<char32_t, 1> const c5 = {{ 0x06C7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_009)
{
    // FBD9;FBD9;FBD9;06C6;06C6; 
    // (ﯙ; ﯙ; ﯙ; ۆ; ۆ; ) ARABIC LETTER OE ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBD9 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBD9 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBD9 }};
        std::array<char32_t, 1> const c4 = {{ 0x06C6 }};
        std::array<char32_t, 1> const c5 = {{ 0x06C6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_010)
{
    // FBDA;FBDA;FBDA;06C6;06C6; 
    // (ﯚ; ﯚ; ﯚ; ۆ; ۆ; ) ARABIC LETTER OE FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBDA }};
        std::array<char32_t, 1> const c2 = {{ 0xFBDA }};
        std::array<char32_t, 1> const c3 = {{ 0xFBDA }};
        std::array<char32_t, 1> const c4 = {{ 0x06C6 }};
        std::array<char32_t, 1> const c5 = {{ 0x06C6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_011)
{
    // FBDB;FBDB;FBDB;06C8;06C8; 
    // (ﯛ; ﯛ; ﯛ; ۈ; ۈ; ) ARABIC LETTER YU ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBDB }};
        std::array<char32_t, 1> const c2 = {{ 0xFBDB }};
        std::array<char32_t, 1> const c3 = {{ 0xFBDB }};
        std::array<char32_t, 1> const c4 = {{ 0x06C8 }};
        std::array<char32_t, 1> const c5 = {{ 0x06C8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_012)
{
    // FBDC;FBDC;FBDC;06C8;06C8; 
    // (ﯜ; ﯜ; ﯜ; ۈ; ۈ; ) ARABIC LETTER YU FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBDC }};
        std::array<char32_t, 1> const c2 = {{ 0xFBDC }};
        std::array<char32_t, 1> const c3 = {{ 0xFBDC }};
        std::array<char32_t, 1> const c4 = {{ 0x06C8 }};
        std::array<char32_t, 1> const c5 = {{ 0x06C8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_013)
{
    // FBDD;FBDD;FBDD;06C7 0674;06C7 0674; 
    // (ﯝ; ﯝ; ﯝ; ۇٴ; ۇٴ; ) ARABIC LETTER U WITH HAMZA ABOVE ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBDD }};
        std::array<char32_t, 1> const c2 = {{ 0xFBDD }};
        std::array<char32_t, 1> const c3 = {{ 0xFBDD }};
        std::array<char32_t, 2> const c4 = {{ 0x06C7, 0x0674 }};
        std::array<char32_t, 2> const c5 = {{ 0x06C7, 0x0674 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_014)
{
    // FBDE;FBDE;FBDE;06CB;06CB; 
    // (ﯞ; ﯞ; ﯞ; ۋ; ۋ; ) ARABIC LETTER VE ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBDE }};
        std::array<char32_t, 1> const c2 = {{ 0xFBDE }};
        std::array<char32_t, 1> const c3 = {{ 0xFBDE }};
        std::array<char32_t, 1> const c4 = {{ 0x06CB }};
        std::array<char32_t, 1> const c5 = {{ 0x06CB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_015)
{
    // FBDF;FBDF;FBDF;06CB;06CB; 
    // (ﯟ; ﯟ; ﯟ; ۋ; ۋ; ) ARABIC LETTER VE FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBDF }};
        std::array<char32_t, 1> const c2 = {{ 0xFBDF }};
        std::array<char32_t, 1> const c3 = {{ 0xFBDF }};
        std::array<char32_t, 1> const c4 = {{ 0x06CB }};
        std::array<char32_t, 1> const c5 = {{ 0x06CB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_016)
{
    // FBE0;FBE0;FBE0;06C5;06C5; 
    // (ﯠ; ﯠ; ﯠ; ۅ; ۅ; ) ARABIC LETTER KIRGHIZ OE ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBE0 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBE0 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBE0 }};
        std::array<char32_t, 1> const c4 = {{ 0x06C5 }};
        std::array<char32_t, 1> const c5 = {{ 0x06C5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_017)
{
    // FBE1;FBE1;FBE1;06C5;06C5; 
    // (ﯡ; ﯡ; ﯡ; ۅ; ۅ; ) ARABIC LETTER KIRGHIZ OE FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBE1 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBE1 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBE1 }};
        std::array<char32_t, 1> const c4 = {{ 0x06C5 }};
        std::array<char32_t, 1> const c5 = {{ 0x06C5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_018)
{
    // FBE2;FBE2;FBE2;06C9;06C9; 
    // (ﯢ; ﯢ; ﯢ; ۉ; ۉ; ) ARABIC LETTER KIRGHIZ YU ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBE2 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBE2 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBE2 }};
        std::array<char32_t, 1> const c4 = {{ 0x06C9 }};
        std::array<char32_t, 1> const c5 = {{ 0x06C9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_019)
{
    // FBE3;FBE3;FBE3;06C9;06C9; 
    // (ﯣ; ﯣ; ﯣ; ۉ; ۉ; ) ARABIC LETTER KIRGHIZ YU FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBE3 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBE3 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBE3 }};
        std::array<char32_t, 1> const c4 = {{ 0x06C9 }};
        std::array<char32_t, 1> const c5 = {{ 0x06C9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_020)
{
    // FBE4;FBE4;FBE4;06D0;06D0; 
    // (ﯤ; ﯤ; ﯤ; ې; ې; ) ARABIC LETTER E ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBE4 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBE4 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBE4 }};
        std::array<char32_t, 1> const c4 = {{ 0x06D0 }};
        std::array<char32_t, 1> const c5 = {{ 0x06D0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_021)
{
    // FBE5;FBE5;FBE5;06D0;06D0; 
    // (ﯥ; ﯥ; ﯥ; ې; ې; ) ARABIC LETTER E FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBE5 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBE5 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBE5 }};
        std::array<char32_t, 1> const c4 = {{ 0x06D0 }};
        std::array<char32_t, 1> const c5 = {{ 0x06D0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_022)
{
    // FBE6;FBE6;FBE6;06D0;06D0; 
    // (ﯦ; ﯦ; ﯦ; ې; ې; ) ARABIC LETTER E INITIAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBE6 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBE6 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBE6 }};
        std::array<char32_t, 1> const c4 = {{ 0x06D0 }};
        std::array<char32_t, 1> const c5 = {{ 0x06D0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_023)
{
    // FBE7;FBE7;FBE7;06D0;06D0; 
    // (ﯧ; ﯧ; ﯧ; ې; ې; ) ARABIC LETTER E MEDIAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBE7 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBE7 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBE7 }};
        std::array<char32_t, 1> const c4 = {{ 0x06D0 }};
        std::array<char32_t, 1> const c5 = {{ 0x06D0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_024)
{
    // FBE8;FBE8;FBE8;0649;0649; 
    // (ﯨ; ﯨ; ﯨ; ى; ى; ) ARABIC LETTER UIGHUR KAZAKH KIRGHIZ ALEF MAKSURA INITIAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBE8 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBE8 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBE8 }};
        std::array<char32_t, 1> const c4 = {{ 0x0649 }};
        std::array<char32_t, 1> const c5 = {{ 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_025)
{
    // FBE9;FBE9;FBE9;0649;0649; 
    // (ﯩ; ﯩ; ﯩ; ى; ى; ) ARABIC LETTER UIGHUR KAZAKH KIRGHIZ ALEF MAKSURA MEDIAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBE9 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBE9 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBE9 }};
        std::array<char32_t, 1> const c4 = {{ 0x0649 }};
        std::array<char32_t, 1> const c5 = {{ 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_026)
{
    // FBEA;FBEA;FBEA;0626 0627;064A 0654 0627; 
    // (ﯪ; ﯪ; ﯪ; ئا; ي◌ٔا; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH ALEF ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBEA }};
        std::array<char32_t, 1> const c2 = {{ 0xFBEA }};
        std::array<char32_t, 1> const c3 = {{ 0xFBEA }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x0627 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x0627 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_027)
{
    // FBEB;FBEB;FBEB;0626 0627;064A 0654 0627; 
    // (ﯫ; ﯫ; ﯫ; ئا; ي◌ٔا; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH ALEF FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBEB }};
        std::array<char32_t, 1> const c2 = {{ 0xFBEB }};
        std::array<char32_t, 1> const c3 = {{ 0xFBEB }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x0627 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x0627 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_028)
{
    // FBEC;FBEC;FBEC;0626 06D5;064A 0654 06D5; 
    // (ﯬ; ﯬ; ﯬ; ئە; ي◌ٔە; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH AE ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBEC }};
        std::array<char32_t, 1> const c2 = {{ 0xFBEC }};
        std::array<char32_t, 1> const c3 = {{ 0xFBEC }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x06D5 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x06D5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_029)
{
    // FBED;FBED;FBED;0626 06D5;064A 0654 06D5; 
    // (ﯭ; ﯭ; ﯭ; ئە; ي◌ٔە; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH AE FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBED }};
        std::array<char32_t, 1> const c2 = {{ 0xFBED }};
        std::array<char32_t, 1> const c3 = {{ 0xFBED }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x06D5 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x06D5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_030)
{
    // FBEE;FBEE;FBEE;0626 0648;064A 0654 0648; 
    // (ﯮ; ﯮ; ﯮ; ئو; ي◌ٔو; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH WAW ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBEE }};
        std::array<char32_t, 1> const c2 = {{ 0xFBEE }};
        std::array<char32_t, 1> const c3 = {{ 0xFBEE }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x0648 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x0648 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_031)
{
    // FBEF;FBEF;FBEF;0626 0648;064A 0654 0648; 
    // (ﯯ; ﯯ; ﯯ; ئو; ي◌ٔو; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH WAW FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBEF }};
        std::array<char32_t, 1> const c2 = {{ 0xFBEF }};
        std::array<char32_t, 1> const c3 = {{ 0xFBEF }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x0648 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x0648 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_032)
{
    // FBF0;FBF0;FBF0;0626 06C7;064A 0654 06C7; 
    // (ﯰ; ﯰ; ﯰ; ئۇ; ي◌ٔۇ; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH U ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBF0 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBF0 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBF0 }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x06C7 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x06C7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_033)
{
    // FBF1;FBF1;FBF1;0626 06C7;064A 0654 06C7; 
    // (ﯱ; ﯱ; ﯱ; ئۇ; ي◌ٔۇ; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH U FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBF1 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBF1 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBF1 }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x06C7 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x06C7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_034)
{
    // FBF2;FBF2;FBF2;0626 06C6;064A 0654 06C6; 
    // (ﯲ; ﯲ; ﯲ; ئۆ; ي◌ٔۆ; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH OE ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBF2 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBF2 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBF2 }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x06C6 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x06C6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_035)
{
    // FBF3;FBF3;FBF3;0626 06C6;064A 0654 06C6; 
    // (ﯳ; ﯳ; ﯳ; ئۆ; ي◌ٔۆ; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH OE FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBF3 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBF3 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBF3 }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x06C6 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x06C6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_036)
{
    // FBF4;FBF4;FBF4;0626 06C8;064A 0654 06C8; 
    // (ﯴ; ﯴ; ﯴ; ئۈ; ي◌ٔۈ; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH YU ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBF4 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBF4 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBF4 }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x06C8 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x06C8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_037)
{
    // FBF5;FBF5;FBF5;0626 06C8;064A 0654 06C8; 
    // (ﯵ; ﯵ; ﯵ; ئۈ; ي◌ٔۈ; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH YU FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBF5 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBF5 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBF5 }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x06C8 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x06C8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_038)
{
    // FBF6;FBF6;FBF6;0626 06D0;064A 0654 06D0; 
    // (ﯶ; ﯶ; ﯶ; ئې; ي◌ٔې; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH E ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBF6 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBF6 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBF6 }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x06D0 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x06D0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_039)
{
    // FBF7;FBF7;FBF7;0626 06D0;064A 0654 06D0; 
    // (ﯷ; ﯷ; ﯷ; ئې; ي◌ٔې; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH E FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBF7 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBF7 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBF7 }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x06D0 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x06D0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_040)
{
    // FBF8;FBF8;FBF8;0626 06D0;064A 0654 06D0; 
    // (ﯸ; ﯸ; ﯸ; ئې; ي◌ٔې; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH E INITIAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBF8 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBF8 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBF8 }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x06D0 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x06D0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_041)
{
    // FBF9;FBF9;FBF9;0626 0649;064A 0654 0649; 
    // (ﯹ; ﯹ; ﯹ; ئى; ي◌ٔى; ) ARABIC LIGATURE UIGHUR KIRGHIZ YEH WITH HAMZA ABOVE WITH ALEF MAKSURA ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBF9 }};
        std::array<char32_t, 1> const c2 = {{ 0xFBF9 }};
        std::array<char32_t, 1> const c3 = {{ 0xFBF9 }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x0649 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_042)
{
    // FBFA;FBFA;FBFA;0626 0649;064A 0654 0649; 
    // (ﯺ; ﯺ; ﯺ; ئى; ي◌ٔى; ) ARABIC LIGATURE UIGHUR KIRGHIZ YEH WITH HAMZA ABOVE WITH ALEF MAKSURA FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBFA }};
        std::array<char32_t, 1> const c2 = {{ 0xFBFA }};
        std::array<char32_t, 1> const c3 = {{ 0xFBFA }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x0649 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_043)
{
    // FBFB;FBFB;FBFB;0626 0649;064A 0654 0649; 
    // (ﯻ; ﯻ; ﯻ; ئى; ي◌ٔى; ) ARABIC LIGATURE UIGHUR KIRGHIZ YEH WITH HAMZA ABOVE WITH ALEF MAKSURA INITIAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBFB }};
        std::array<char32_t, 1> const c2 = {{ 0xFBFB }};
        std::array<char32_t, 1> const c3 = {{ 0xFBFB }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x0649 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_044)
{
    // FBFC;FBFC;FBFC;06CC;06CC; 
    // (ﯼ; ﯼ; ﯼ; ی; ی; ) ARABIC LETTER FARSI YEH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBFC }};
        std::array<char32_t, 1> const c2 = {{ 0xFBFC }};
        std::array<char32_t, 1> const c3 = {{ 0xFBFC }};
        std::array<char32_t, 1> const c4 = {{ 0x06CC }};
        std::array<char32_t, 1> const c5 = {{ 0x06CC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_045)
{
    // FBFD;FBFD;FBFD;06CC;06CC; 
    // (ﯽ; ﯽ; ﯽ; ی; ی; ) ARABIC LETTER FARSI YEH FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBFD }};
        std::array<char32_t, 1> const c2 = {{ 0xFBFD }};
        std::array<char32_t, 1> const c3 = {{ 0xFBFD }};
        std::array<char32_t, 1> const c4 = {{ 0x06CC }};
        std::array<char32_t, 1> const c5 = {{ 0x06CC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_046)
{
    // FBFE;FBFE;FBFE;06CC;06CC; 
    // (ﯾ; ﯾ; ﯾ; ی; ی; ) ARABIC LETTER FARSI YEH INITIAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBFE }};
        std::array<char32_t, 1> const c2 = {{ 0xFBFE }};
        std::array<char32_t, 1> const c3 = {{ 0xFBFE }};
        std::array<char32_t, 1> const c4 = {{ 0x06CC }};
        std::array<char32_t, 1> const c5 = {{ 0x06CC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_047)
{
    // FBFF;FBFF;FBFF;06CC;06CC; 
    // (ﯿ; ﯿ; ﯿ; ی; ی; ) ARABIC LETTER FARSI YEH MEDIAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFBFF }};
        std::array<char32_t, 1> const c2 = {{ 0xFBFF }};
        std::array<char32_t, 1> const c3 = {{ 0xFBFF }};
        std::array<char32_t, 1> const c4 = {{ 0x06CC }};
        std::array<char32_t, 1> const c5 = {{ 0x06CC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_048)
{
    // FC00;FC00;FC00;0626 062C;064A 0654 062C; 
    // (ﰀ; ﰀ; ﰀ; ئج; ي◌ٔج; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH JEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC00 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC00 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC00 }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x062C }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x062C }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_049)
{
    // FC01;FC01;FC01;0626 062D;064A 0654 062D; 
    // (ﰁ; ﰁ; ﰁ; ئح; ي◌ٔح; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH HAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC01 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC01 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC01 }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x062D }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x062D }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_050)
{
    // FC02;FC02;FC02;0626 0645;064A 0654 0645; 
    // (ﰂ; ﰂ; ﰂ; ئم; ي◌ٔم; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH MEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC02 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC02 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC02 }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x0645 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_051)
{
    // FC03;FC03;FC03;0626 0649;064A 0654 0649; 
    // (ﰃ; ﰃ; ﰃ; ئى; ي◌ٔى; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH ALEF MAKSURA ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC03 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC03 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC03 }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x0649 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_052)
{
    // FC04;FC04;FC04;0626 064A;064A 0654 064A; 
    // (ﰄ; ﰄ; ﰄ; ئي; ي◌ٔي; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH YEH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC04 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC04 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC04 }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x064A }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x064A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_053)
{
    // FC05;FC05;FC05;0628 062C;0628 062C; 
    // (ﰅ; ﰅ; ﰅ; بج; بج; ) ARABIC LIGATURE BEH WITH JEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC05 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC05 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC05 }};
        std::array<char32_t, 2> const c4 = {{ 0x0628, 0x062C }};
        std::array<char32_t, 2> const c5 = {{ 0x0628, 0x062C }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_054)
{
    // FC06;FC06;FC06;0628 062D;0628 062D; 
    // (ﰆ; ﰆ; ﰆ; بح; بح; ) ARABIC LIGATURE BEH WITH HAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC06 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC06 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC06 }};
        std::array<char32_t, 2> const c4 = {{ 0x0628, 0x062D }};
        std::array<char32_t, 2> const c5 = {{ 0x0628, 0x062D }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_055)
{
    // FC07;FC07;FC07;0628 062E;0628 062E; 
    // (ﰇ; ﰇ; ﰇ; بخ; بخ; ) ARABIC LIGATURE BEH WITH KHAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC07 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC07 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC07 }};
        std::array<char32_t, 2> const c4 = {{ 0x0628, 0x062E }};
        std::array<char32_t, 2> const c5 = {{ 0x0628, 0x062E }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_056)
{
    // FC08;FC08;FC08;0628 0645;0628 0645; 
    // (ﰈ; ﰈ; ﰈ; بم; بم; ) ARABIC LIGATURE BEH WITH MEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC08 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC08 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC08 }};
        std::array<char32_t, 2> const c4 = {{ 0x0628, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x0628, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_057)
{
    // FC09;FC09;FC09;0628 0649;0628 0649; 
    // (ﰉ; ﰉ; ﰉ; بى; بى; ) ARABIC LIGATURE BEH WITH ALEF MAKSURA ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC09 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC09 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC09 }};
        std::array<char32_t, 2> const c4 = {{ 0x0628, 0x0649 }};
        std::array<char32_t, 2> const c5 = {{ 0x0628, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_058)
{
    // FC0A;FC0A;FC0A;0628 064A;0628 064A; 
    // (ﰊ; ﰊ; ﰊ; بي; بي; ) ARABIC LIGATURE BEH WITH YEH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC0A }};
        std::array<char32_t, 1> const c2 = {{ 0xFC0A }};
        std::array<char32_t, 1> const c3 = {{ 0xFC0A }};
        std::array<char32_t, 2> const c4 = {{ 0x0628, 0x064A }};
        std::array<char32_t, 2> const c5 = {{ 0x0628, 0x064A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_059)
{
    // FC0B;FC0B;FC0B;062A 062C;062A 062C; 
    // (ﰋ; ﰋ; ﰋ; تج; تج; ) ARABIC LIGATURE TEH WITH JEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC0B }};
        std::array<char32_t, 1> const c2 = {{ 0xFC0B }};
        std::array<char32_t, 1> const c3 = {{ 0xFC0B }};
        std::array<char32_t, 2> const c4 = {{ 0x062A, 0x062C }};
        std::array<char32_t, 2> const c5 = {{ 0x062A, 0x062C }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_060)
{
    // FC0C;FC0C;FC0C;062A 062D;062A 062D; 
    // (ﰌ; ﰌ; ﰌ; تح; تح; ) ARABIC LIGATURE TEH WITH HAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC0C }};
        std::array<char32_t, 1> const c2 = {{ 0xFC0C }};
        std::array<char32_t, 1> const c3 = {{ 0xFC0C }};
        std::array<char32_t, 2> const c4 = {{ 0x062A, 0x062D }};
        std::array<char32_t, 2> const c5 = {{ 0x062A, 0x062D }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_061)
{
    // FC0D;FC0D;FC0D;062A 062E;062A 062E; 
    // (ﰍ; ﰍ; ﰍ; تخ; تخ; ) ARABIC LIGATURE TEH WITH KHAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC0D }};
        std::array<char32_t, 1> const c2 = {{ 0xFC0D }};
        std::array<char32_t, 1> const c3 = {{ 0xFC0D }};
        std::array<char32_t, 2> const c4 = {{ 0x062A, 0x062E }};
        std::array<char32_t, 2> const c5 = {{ 0x062A, 0x062E }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_062)
{
    // FC0E;FC0E;FC0E;062A 0645;062A 0645; 
    // (ﰎ; ﰎ; ﰎ; تم; تم; ) ARABIC LIGATURE TEH WITH MEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC0E }};
        std::array<char32_t, 1> const c2 = {{ 0xFC0E }};
        std::array<char32_t, 1> const c3 = {{ 0xFC0E }};
        std::array<char32_t, 2> const c4 = {{ 0x062A, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x062A, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_063)
{
    // FC0F;FC0F;FC0F;062A 0649;062A 0649; 
    // (ﰏ; ﰏ; ﰏ; تى; تى; ) ARABIC LIGATURE TEH WITH ALEF MAKSURA ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC0F }};
        std::array<char32_t, 1> const c2 = {{ 0xFC0F }};
        std::array<char32_t, 1> const c3 = {{ 0xFC0F }};
        std::array<char32_t, 2> const c4 = {{ 0x062A, 0x0649 }};
        std::array<char32_t, 2> const c5 = {{ 0x062A, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_064)
{
    // FC10;FC10;FC10;062A 064A;062A 064A; 
    // (ﰐ; ﰐ; ﰐ; تي; تي; ) ARABIC LIGATURE TEH WITH YEH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC10 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC10 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC10 }};
        std::array<char32_t, 2> const c4 = {{ 0x062A, 0x064A }};
        std::array<char32_t, 2> const c5 = {{ 0x062A, 0x064A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_065)
{
    // FC11;FC11;FC11;062B 062C;062B 062C; 
    // (ﰑ; ﰑ; ﰑ; ثج; ثج; ) ARABIC LIGATURE THEH WITH JEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC11 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC11 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC11 }};
        std::array<char32_t, 2> const c4 = {{ 0x062B, 0x062C }};
        std::array<char32_t, 2> const c5 = {{ 0x062B, 0x062C }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_066)
{
    // FC12;FC12;FC12;062B 0645;062B 0645; 
    // (ﰒ; ﰒ; ﰒ; ثم; ثم; ) ARABIC LIGATURE THEH WITH MEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC12 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC12 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC12 }};
        std::array<char32_t, 2> const c4 = {{ 0x062B, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x062B, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_067)
{
    // FC13;FC13;FC13;062B 0649;062B 0649; 
    // (ﰓ; ﰓ; ﰓ; ثى; ثى; ) ARABIC LIGATURE THEH WITH ALEF MAKSURA ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC13 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC13 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC13 }};
        std::array<char32_t, 2> const c4 = {{ 0x062B, 0x0649 }};
        std::array<char32_t, 2> const c5 = {{ 0x062B, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_068)
{
    // FC14;FC14;FC14;062B 064A;062B 064A; 
    // (ﰔ; ﰔ; ﰔ; ثي; ثي; ) ARABIC LIGATURE THEH WITH YEH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC14 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC14 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC14 }};
        std::array<char32_t, 2> const c4 = {{ 0x062B, 0x064A }};
        std::array<char32_t, 2> const c5 = {{ 0x062B, 0x064A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_069)
{
    // FC15;FC15;FC15;062C 062D;062C 062D; 
    // (ﰕ; ﰕ; ﰕ; جح; جح; ) ARABIC LIGATURE JEEM WITH HAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC15 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC15 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC15 }};
        std::array<char32_t, 2> const c4 = {{ 0x062C, 0x062D }};
        std::array<char32_t, 2> const c5 = {{ 0x062C, 0x062D }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_070)
{
    // FC16;FC16;FC16;062C 0645;062C 0645; 
    // (ﰖ; ﰖ; ﰖ; جم; جم; ) ARABIC LIGATURE JEEM WITH MEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC16 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC16 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC16 }};
        std::array<char32_t, 2> const c4 = {{ 0x062C, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x062C, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_071)
{
    // FC17;FC17;FC17;062D 062C;062D 062C; 
    // (ﰗ; ﰗ; ﰗ; حج; حج; ) ARABIC LIGATURE HAH WITH JEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC17 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC17 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC17 }};
        std::array<char32_t, 2> const c4 = {{ 0x062D, 0x062C }};
        std::array<char32_t, 2> const c5 = {{ 0x062D, 0x062C }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_072)
{
    // FC18;FC18;FC18;062D 0645;062D 0645; 
    // (ﰘ; ﰘ; ﰘ; حم; حم; ) ARABIC LIGATURE HAH WITH MEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC18 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC18 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC18 }};
        std::array<char32_t, 2> const c4 = {{ 0x062D, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x062D, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_073)
{
    // FC19;FC19;FC19;062E 062C;062E 062C; 
    // (ﰙ; ﰙ; ﰙ; خج; خج; ) ARABIC LIGATURE KHAH WITH JEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC19 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC19 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC19 }};
        std::array<char32_t, 2> const c4 = {{ 0x062E, 0x062C }};
        std::array<char32_t, 2> const c5 = {{ 0x062E, 0x062C }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_074)
{
    // FC1A;FC1A;FC1A;062E 062D;062E 062D; 
    // (ﰚ; ﰚ; ﰚ; خح; خح; ) ARABIC LIGATURE KHAH WITH HAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC1A }};
        std::array<char32_t, 1> const c2 = {{ 0xFC1A }};
        std::array<char32_t, 1> const c3 = {{ 0xFC1A }};
        std::array<char32_t, 2> const c4 = {{ 0x062E, 0x062D }};
        std::array<char32_t, 2> const c5 = {{ 0x062E, 0x062D }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_075)
{
    // FC1B;FC1B;FC1B;062E 0645;062E 0645; 
    // (ﰛ; ﰛ; ﰛ; خم; خم; ) ARABIC LIGATURE KHAH WITH MEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC1B }};
        std::array<char32_t, 1> const c2 = {{ 0xFC1B }};
        std::array<char32_t, 1> const c3 = {{ 0xFC1B }};
        std::array<char32_t, 2> const c4 = {{ 0x062E, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x062E, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_076)
{
    // FC1C;FC1C;FC1C;0633 062C;0633 062C; 
    // (ﰜ; ﰜ; ﰜ; سج; سج; ) ARABIC LIGATURE SEEN WITH JEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC1C }};
        std::array<char32_t, 1> const c2 = {{ 0xFC1C }};
        std::array<char32_t, 1> const c3 = {{ 0xFC1C }};
        std::array<char32_t, 2> const c4 = {{ 0x0633, 0x062C }};
        std::array<char32_t, 2> const c5 = {{ 0x0633, 0x062C }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_077)
{
    // FC1D;FC1D;FC1D;0633 062D;0633 062D; 
    // (ﰝ; ﰝ; ﰝ; سح; سح; ) ARABIC LIGATURE SEEN WITH HAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC1D }};
        std::array<char32_t, 1> const c2 = {{ 0xFC1D }};
        std::array<char32_t, 1> const c3 = {{ 0xFC1D }};
        std::array<char32_t, 2> const c4 = {{ 0x0633, 0x062D }};
        std::array<char32_t, 2> const c5 = {{ 0x0633, 0x062D }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_078)
{
    // FC1E;FC1E;FC1E;0633 062E;0633 062E; 
    // (ﰞ; ﰞ; ﰞ; سخ; سخ; ) ARABIC LIGATURE SEEN WITH KHAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC1E }};
        std::array<char32_t, 1> const c2 = {{ 0xFC1E }};
        std::array<char32_t, 1> const c3 = {{ 0xFC1E }};
        std::array<char32_t, 2> const c4 = {{ 0x0633, 0x062E }};
        std::array<char32_t, 2> const c5 = {{ 0x0633, 0x062E }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_079)
{
    // FC1F;FC1F;FC1F;0633 0645;0633 0645; 
    // (ﰟ; ﰟ; ﰟ; سم; سم; ) ARABIC LIGATURE SEEN WITH MEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC1F }};
        std::array<char32_t, 1> const c2 = {{ 0xFC1F }};
        std::array<char32_t, 1> const c3 = {{ 0xFC1F }};
        std::array<char32_t, 2> const c4 = {{ 0x0633, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x0633, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_080)
{
    // FC20;FC20;FC20;0635 062D;0635 062D; 
    // (ﰠ; ﰠ; ﰠ; صح; صح; ) ARABIC LIGATURE SAD WITH HAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC20 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC20 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC20 }};
        std::array<char32_t, 2> const c4 = {{ 0x0635, 0x062D }};
        std::array<char32_t, 2> const c5 = {{ 0x0635, 0x062D }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_081)
{
    // FC21;FC21;FC21;0635 0645;0635 0645; 
    // (ﰡ; ﰡ; ﰡ; صم; صم; ) ARABIC LIGATURE SAD WITH MEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC21 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC21 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC21 }};
        std::array<char32_t, 2> const c4 = {{ 0x0635, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x0635, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_082)
{
    // FC22;FC22;FC22;0636 062C;0636 062C; 
    // (ﰢ; ﰢ; ﰢ; ضج; ضج; ) ARABIC LIGATURE DAD WITH JEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC22 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC22 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC22 }};
        std::array<char32_t, 2> const c4 = {{ 0x0636, 0x062C }};
        std::array<char32_t, 2> const c5 = {{ 0x0636, 0x062C }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_083)
{
    // FC23;FC23;FC23;0636 062D;0636 062D; 
    // (ﰣ; ﰣ; ﰣ; ضح; ضح; ) ARABIC LIGATURE DAD WITH HAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC23 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC23 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC23 }};
        std::array<char32_t, 2> const c4 = {{ 0x0636, 0x062D }};
        std::array<char32_t, 2> const c5 = {{ 0x0636, 0x062D }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_084)
{
    // FC24;FC24;FC24;0636 062E;0636 062E; 
    // (ﰤ; ﰤ; ﰤ; ضخ; ضخ; ) ARABIC LIGATURE DAD WITH KHAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC24 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC24 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC24 }};
        std::array<char32_t, 2> const c4 = {{ 0x0636, 0x062E }};
        std::array<char32_t, 2> const c5 = {{ 0x0636, 0x062E }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_085)
{
    // FC25;FC25;FC25;0636 0645;0636 0645; 
    // (ﰥ; ﰥ; ﰥ; ضم; ضم; ) ARABIC LIGATURE DAD WITH MEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC25 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC25 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC25 }};
        std::array<char32_t, 2> const c4 = {{ 0x0636, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x0636, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_086)
{
    // FC26;FC26;FC26;0637 062D;0637 062D; 
    // (ﰦ; ﰦ; ﰦ; طح; طح; ) ARABIC LIGATURE TAH WITH HAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC26 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC26 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC26 }};
        std::array<char32_t, 2> const c4 = {{ 0x0637, 0x062D }};
        std::array<char32_t, 2> const c5 = {{ 0x0637, 0x062D }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_087)
{
    // FC27;FC27;FC27;0637 0645;0637 0645; 
    // (ﰧ; ﰧ; ﰧ; طم; طم; ) ARABIC LIGATURE TAH WITH MEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC27 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC27 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC27 }};
        std::array<char32_t, 2> const c4 = {{ 0x0637, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x0637, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_088)
{
    // FC28;FC28;FC28;0638 0645;0638 0645; 
    // (ﰨ; ﰨ; ﰨ; ظم; ظم; ) ARABIC LIGATURE ZAH WITH MEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC28 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC28 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC28 }};
        std::array<char32_t, 2> const c4 = {{ 0x0638, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x0638, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_089)
{
    // FC29;FC29;FC29;0639 062C;0639 062C; 
    // (ﰩ; ﰩ; ﰩ; عج; عج; ) ARABIC LIGATURE AIN WITH JEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC29 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC29 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC29 }};
        std::array<char32_t, 2> const c4 = {{ 0x0639, 0x062C }};
        std::array<char32_t, 2> const c5 = {{ 0x0639, 0x062C }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_090)
{
    // FC2A;FC2A;FC2A;0639 0645;0639 0645; 
    // (ﰪ; ﰪ; ﰪ; عم; عم; ) ARABIC LIGATURE AIN WITH MEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC2A }};
        std::array<char32_t, 1> const c2 = {{ 0xFC2A }};
        std::array<char32_t, 1> const c3 = {{ 0xFC2A }};
        std::array<char32_t, 2> const c4 = {{ 0x0639, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x0639, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_091)
{
    // FC2B;FC2B;FC2B;063A 062C;063A 062C; 
    // (ﰫ; ﰫ; ﰫ; غج; غج; ) ARABIC LIGATURE GHAIN WITH JEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC2B }};
        std::array<char32_t, 1> const c2 = {{ 0xFC2B }};
        std::array<char32_t, 1> const c3 = {{ 0xFC2B }};
        std::array<char32_t, 2> const c4 = {{ 0x063A, 0x062C }};
        std::array<char32_t, 2> const c5 = {{ 0x063A, 0x062C }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_092)
{
    // FC2C;FC2C;FC2C;063A 0645;063A 0645; 
    // (ﰬ; ﰬ; ﰬ; غم; غم; ) ARABIC LIGATURE GHAIN WITH MEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC2C }};
        std::array<char32_t, 1> const c2 = {{ 0xFC2C }};
        std::array<char32_t, 1> const c3 = {{ 0xFC2C }};
        std::array<char32_t, 2> const c4 = {{ 0x063A, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x063A, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_093)
{
    // FC2D;FC2D;FC2D;0641 062C;0641 062C; 
    // (ﰭ; ﰭ; ﰭ; فج; فج; ) ARABIC LIGATURE FEH WITH JEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC2D }};
        std::array<char32_t, 1> const c2 = {{ 0xFC2D }};
        std::array<char32_t, 1> const c3 = {{ 0xFC2D }};
        std::array<char32_t, 2> const c4 = {{ 0x0641, 0x062C }};
        std::array<char32_t, 2> const c5 = {{ 0x0641, 0x062C }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_094)
{
    // FC2E;FC2E;FC2E;0641 062D;0641 062D; 
    // (ﰮ; ﰮ; ﰮ; فح; فح; ) ARABIC LIGATURE FEH WITH HAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC2E }};
        std::array<char32_t, 1> const c2 = {{ 0xFC2E }};
        std::array<char32_t, 1> const c3 = {{ 0xFC2E }};
        std::array<char32_t, 2> const c4 = {{ 0x0641, 0x062D }};
        std::array<char32_t, 2> const c5 = {{ 0x0641, 0x062D }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_095)
{
    // FC2F;FC2F;FC2F;0641 062E;0641 062E; 
    // (ﰯ; ﰯ; ﰯ; فخ; فخ; ) ARABIC LIGATURE FEH WITH KHAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC2F }};
        std::array<char32_t, 1> const c2 = {{ 0xFC2F }};
        std::array<char32_t, 1> const c3 = {{ 0xFC2F }};
        std::array<char32_t, 2> const c4 = {{ 0x0641, 0x062E }};
        std::array<char32_t, 2> const c5 = {{ 0x0641, 0x062E }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_096)
{
    // FC30;FC30;FC30;0641 0645;0641 0645; 
    // (ﰰ; ﰰ; ﰰ; فم; فم; ) ARABIC LIGATURE FEH WITH MEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC30 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC30 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC30 }};
        std::array<char32_t, 2> const c4 = {{ 0x0641, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x0641, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_097)
{
    // FC31;FC31;FC31;0641 0649;0641 0649; 
    // (ﰱ; ﰱ; ﰱ; فى; فى; ) ARABIC LIGATURE FEH WITH ALEF MAKSURA ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC31 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC31 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC31 }};
        std::array<char32_t, 2> const c4 = {{ 0x0641, 0x0649 }};
        std::array<char32_t, 2> const c5 = {{ 0x0641, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_098)
{
    // FC32;FC32;FC32;0641 064A;0641 064A; 
    // (ﰲ; ﰲ; ﰲ; في; في; ) ARABIC LIGATURE FEH WITH YEH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC32 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC32 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC32 }};
        std::array<char32_t, 2> const c4 = {{ 0x0641, 0x064A }};
        std::array<char32_t, 2> const c5 = {{ 0x0641, 0x064A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_099)
{
    // FC33;FC33;FC33;0642 062D;0642 062D; 
    // (ﰳ; ﰳ; ﰳ; قح; قح; ) ARABIC LIGATURE QAF WITH HAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC33 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC33 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC33 }};
        std::array<char32_t, 2> const c4 = {{ 0x0642, 0x062D }};
        std::array<char32_t, 2> const c5 = {{ 0x0642, 0x062D }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_100)
{
    // FC34;FC34;FC34;0642 0645;0642 0645; 
    // (ﰴ; ﰴ; ﰴ; قم; قم; ) ARABIC LIGATURE QAF WITH MEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC34 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC34 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC34 }};
        std::array<char32_t, 2> const c4 = {{ 0x0642, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x0642, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_101)
{
    // FC35;FC35;FC35;0642 0649;0642 0649; 
    // (ﰵ; ﰵ; ﰵ; قى; قى; ) ARABIC LIGATURE QAF WITH ALEF MAKSURA ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC35 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC35 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC35 }};
        std::array<char32_t, 2> const c4 = {{ 0x0642, 0x0649 }};
        std::array<char32_t, 2> const c5 = {{ 0x0642, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_102)
{
    // FC36;FC36;FC36;0642 064A;0642 064A; 
    // (ﰶ; ﰶ; ﰶ; قي; قي; ) ARABIC LIGATURE QAF WITH YEH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC36 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC36 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC36 }};
        std::array<char32_t, 2> const c4 = {{ 0x0642, 0x064A }};
        std::array<char32_t, 2> const c5 = {{ 0x0642, 0x064A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_103)
{
    // FC37;FC37;FC37;0643 0627;0643 0627; 
    // (ﰷ; ﰷ; ﰷ; كا; كا; ) ARABIC LIGATURE KAF WITH ALEF ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC37 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC37 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC37 }};
        std::array<char32_t, 2> const c4 = {{ 0x0643, 0x0627 }};
        std::array<char32_t, 2> const c5 = {{ 0x0643, 0x0627 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_104)
{
    // FC38;FC38;FC38;0643 062C;0643 062C; 
    // (ﰸ; ﰸ; ﰸ; كج; كج; ) ARABIC LIGATURE KAF WITH JEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC38 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC38 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC38 }};
        std::array<char32_t, 2> const c4 = {{ 0x0643, 0x062C }};
        std::array<char32_t, 2> const c5 = {{ 0x0643, 0x062C }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_105)
{
    // FC39;FC39;FC39;0643 062D;0643 062D; 
    // (ﰹ; ﰹ; ﰹ; كح; كح; ) ARABIC LIGATURE KAF WITH HAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC39 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC39 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC39 }};
        std::array<char32_t, 2> const c4 = {{ 0x0643, 0x062D }};
        std::array<char32_t, 2> const c5 = {{ 0x0643, 0x062D }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_106)
{
    // FC3A;FC3A;FC3A;0643 062E;0643 062E; 
    // (ﰺ; ﰺ; ﰺ; كخ; كخ; ) ARABIC LIGATURE KAF WITH KHAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC3A }};
        std::array<char32_t, 1> const c2 = {{ 0xFC3A }};
        std::array<char32_t, 1> const c3 = {{ 0xFC3A }};
        std::array<char32_t, 2> const c4 = {{ 0x0643, 0x062E }};
        std::array<char32_t, 2> const c5 = {{ 0x0643, 0x062E }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_107)
{
    // FC3B;FC3B;FC3B;0643 0644;0643 0644; 
    // (ﰻ; ﰻ; ﰻ; كل; كل; ) ARABIC LIGATURE KAF WITH LAM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC3B }};
        std::array<char32_t, 1> const c2 = {{ 0xFC3B }};
        std::array<char32_t, 1> const c3 = {{ 0xFC3B }};
        std::array<char32_t, 2> const c4 = {{ 0x0643, 0x0644 }};
        std::array<char32_t, 2> const c5 = {{ 0x0643, 0x0644 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_108)
{
    // FC3C;FC3C;FC3C;0643 0645;0643 0645; 
    // (ﰼ; ﰼ; ﰼ; كم; كم; ) ARABIC LIGATURE KAF WITH MEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC3C }};
        std::array<char32_t, 1> const c2 = {{ 0xFC3C }};
        std::array<char32_t, 1> const c3 = {{ 0xFC3C }};
        std::array<char32_t, 2> const c4 = {{ 0x0643, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x0643, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_109)
{
    // FC3D;FC3D;FC3D;0643 0649;0643 0649; 
    // (ﰽ; ﰽ; ﰽ; كى; كى; ) ARABIC LIGATURE KAF WITH ALEF MAKSURA ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC3D }};
        std::array<char32_t, 1> const c2 = {{ 0xFC3D }};
        std::array<char32_t, 1> const c3 = {{ 0xFC3D }};
        std::array<char32_t, 2> const c4 = {{ 0x0643, 0x0649 }};
        std::array<char32_t, 2> const c5 = {{ 0x0643, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_110)
{
    // FC3E;FC3E;FC3E;0643 064A;0643 064A; 
    // (ﰾ; ﰾ; ﰾ; كي; كي; ) ARABIC LIGATURE KAF WITH YEH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC3E }};
        std::array<char32_t, 1> const c2 = {{ 0xFC3E }};
        std::array<char32_t, 1> const c3 = {{ 0xFC3E }};
        std::array<char32_t, 2> const c4 = {{ 0x0643, 0x064A }};
        std::array<char32_t, 2> const c5 = {{ 0x0643, 0x064A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_111)
{
    // FC3F;FC3F;FC3F;0644 062C;0644 062C; 
    // (ﰿ; ﰿ; ﰿ; لج; لج; ) ARABIC LIGATURE LAM WITH JEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC3F }};
        std::array<char32_t, 1> const c2 = {{ 0xFC3F }};
        std::array<char32_t, 1> const c3 = {{ 0xFC3F }};
        std::array<char32_t, 2> const c4 = {{ 0x0644, 0x062C }};
        std::array<char32_t, 2> const c5 = {{ 0x0644, 0x062C }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_112)
{
    // FC40;FC40;FC40;0644 062D;0644 062D; 
    // (ﱀ; ﱀ; ﱀ; لح; لح; ) ARABIC LIGATURE LAM WITH HAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC40 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC40 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC40 }};
        std::array<char32_t, 2> const c4 = {{ 0x0644, 0x062D }};
        std::array<char32_t, 2> const c5 = {{ 0x0644, 0x062D }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_113)
{
    // FC41;FC41;FC41;0644 062E;0644 062E; 
    // (ﱁ; ﱁ; ﱁ; لخ; لخ; ) ARABIC LIGATURE LAM WITH KHAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC41 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC41 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC41 }};
        std::array<char32_t, 2> const c4 = {{ 0x0644, 0x062E }};
        std::array<char32_t, 2> const c5 = {{ 0x0644, 0x062E }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_114)
{
    // FC42;FC42;FC42;0644 0645;0644 0645; 
    // (ﱂ; ﱂ; ﱂ; لم; لم; ) ARABIC LIGATURE LAM WITH MEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC42 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC42 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC42 }};
        std::array<char32_t, 2> const c4 = {{ 0x0644, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x0644, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_115)
{
    // FC43;FC43;FC43;0644 0649;0644 0649; 
    // (ﱃ; ﱃ; ﱃ; لى; لى; ) ARABIC LIGATURE LAM WITH ALEF MAKSURA ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC43 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC43 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC43 }};
        std::array<char32_t, 2> const c4 = {{ 0x0644, 0x0649 }};
        std::array<char32_t, 2> const c5 = {{ 0x0644, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_116)
{
    // FC44;FC44;FC44;0644 064A;0644 064A; 
    // (ﱄ; ﱄ; ﱄ; لي; لي; ) ARABIC LIGATURE LAM WITH YEH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC44 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC44 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC44 }};
        std::array<char32_t, 2> const c4 = {{ 0x0644, 0x064A }};
        std::array<char32_t, 2> const c5 = {{ 0x0644, 0x064A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_117)
{
    // FC45;FC45;FC45;0645 062C;0645 062C; 
    // (ﱅ; ﱅ; ﱅ; مج; مج; ) ARABIC LIGATURE MEEM WITH JEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC45 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC45 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC45 }};
        std::array<char32_t, 2> const c4 = {{ 0x0645, 0x062C }};
        std::array<char32_t, 2> const c5 = {{ 0x0645, 0x062C }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_118)
{
    // FC46;FC46;FC46;0645 062D;0645 062D; 
    // (ﱆ; ﱆ; ﱆ; مح; مح; ) ARABIC LIGATURE MEEM WITH HAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC46 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC46 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC46 }};
        std::array<char32_t, 2> const c4 = {{ 0x0645, 0x062D }};
        std::array<char32_t, 2> const c5 = {{ 0x0645, 0x062D }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_119)
{
    // FC47;FC47;FC47;0645 062E;0645 062E; 
    // (ﱇ; ﱇ; ﱇ; مخ; مخ; ) ARABIC LIGATURE MEEM WITH KHAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC47 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC47 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC47 }};
        std::array<char32_t, 2> const c4 = {{ 0x0645, 0x062E }};
        std::array<char32_t, 2> const c5 = {{ 0x0645, 0x062E }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_120)
{
    // FC48;FC48;FC48;0645 0645;0645 0645; 
    // (ﱈ; ﱈ; ﱈ; مم; مم; ) ARABIC LIGATURE MEEM WITH MEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC48 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC48 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC48 }};
        std::array<char32_t, 2> const c4 = {{ 0x0645, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x0645, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_121)
{
    // FC49;FC49;FC49;0645 0649;0645 0649; 
    // (ﱉ; ﱉ; ﱉ; مى; مى; ) ARABIC LIGATURE MEEM WITH ALEF MAKSURA ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC49 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC49 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC49 }};
        std::array<char32_t, 2> const c4 = {{ 0x0645, 0x0649 }};
        std::array<char32_t, 2> const c5 = {{ 0x0645, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_122)
{
    // FC4A;FC4A;FC4A;0645 064A;0645 064A; 
    // (ﱊ; ﱊ; ﱊ; مي; مي; ) ARABIC LIGATURE MEEM WITH YEH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC4A }};
        std::array<char32_t, 1> const c2 = {{ 0xFC4A }};
        std::array<char32_t, 1> const c3 = {{ 0xFC4A }};
        std::array<char32_t, 2> const c4 = {{ 0x0645, 0x064A }};
        std::array<char32_t, 2> const c5 = {{ 0x0645, 0x064A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_123)
{
    // FC4B;FC4B;FC4B;0646 062C;0646 062C; 
    // (ﱋ; ﱋ; ﱋ; نج; نج; ) ARABIC LIGATURE NOON WITH JEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC4B }};
        std::array<char32_t, 1> const c2 = {{ 0xFC4B }};
        std::array<char32_t, 1> const c3 = {{ 0xFC4B }};
        std::array<char32_t, 2> const c4 = {{ 0x0646, 0x062C }};
        std::array<char32_t, 2> const c5 = {{ 0x0646, 0x062C }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_124)
{
    // FC4C;FC4C;FC4C;0646 062D;0646 062D; 
    // (ﱌ; ﱌ; ﱌ; نح; نح; ) ARABIC LIGATURE NOON WITH HAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC4C }};
        std::array<char32_t, 1> const c2 = {{ 0xFC4C }};
        std::array<char32_t, 1> const c3 = {{ 0xFC4C }};
        std::array<char32_t, 2> const c4 = {{ 0x0646, 0x062D }};
        std::array<char32_t, 2> const c5 = {{ 0x0646, 0x062D }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_125)
{
    // FC4D;FC4D;FC4D;0646 062E;0646 062E; 
    // (ﱍ; ﱍ; ﱍ; نخ; نخ; ) ARABIC LIGATURE NOON WITH KHAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC4D }};
        std::array<char32_t, 1> const c2 = {{ 0xFC4D }};
        std::array<char32_t, 1> const c3 = {{ 0xFC4D }};
        std::array<char32_t, 2> const c4 = {{ 0x0646, 0x062E }};
        std::array<char32_t, 2> const c5 = {{ 0x0646, 0x062E }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_126)
{
    // FC4E;FC4E;FC4E;0646 0645;0646 0645; 
    // (ﱎ; ﱎ; ﱎ; نم; نم; ) ARABIC LIGATURE NOON WITH MEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC4E }};
        std::array<char32_t, 1> const c2 = {{ 0xFC4E }};
        std::array<char32_t, 1> const c3 = {{ 0xFC4E }};
        std::array<char32_t, 2> const c4 = {{ 0x0646, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x0646, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_127)
{
    // FC4F;FC4F;FC4F;0646 0649;0646 0649; 
    // (ﱏ; ﱏ; ﱏ; نى; نى; ) ARABIC LIGATURE NOON WITH ALEF MAKSURA ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC4F }};
        std::array<char32_t, 1> const c2 = {{ 0xFC4F }};
        std::array<char32_t, 1> const c3 = {{ 0xFC4F }};
        std::array<char32_t, 2> const c4 = {{ 0x0646, 0x0649 }};
        std::array<char32_t, 2> const c5 = {{ 0x0646, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_128)
{
    // FC50;FC50;FC50;0646 064A;0646 064A; 
    // (ﱐ; ﱐ; ﱐ; ني; ني; ) ARABIC LIGATURE NOON WITH YEH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC50 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC50 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC50 }};
        std::array<char32_t, 2> const c4 = {{ 0x0646, 0x064A }};
        std::array<char32_t, 2> const c5 = {{ 0x0646, 0x064A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_129)
{
    // FC51;FC51;FC51;0647 062C;0647 062C; 
    // (ﱑ; ﱑ; ﱑ; هج; هج; ) ARABIC LIGATURE HEH WITH JEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC51 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC51 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC51 }};
        std::array<char32_t, 2> const c4 = {{ 0x0647, 0x062C }};
        std::array<char32_t, 2> const c5 = {{ 0x0647, 0x062C }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_130)
{
    // FC52;FC52;FC52;0647 0645;0647 0645; 
    // (ﱒ; ﱒ; ﱒ; هم; هم; ) ARABIC LIGATURE HEH WITH MEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC52 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC52 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC52 }};
        std::array<char32_t, 2> const c4 = {{ 0x0647, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x0647, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_131)
{
    // FC53;FC53;FC53;0647 0649;0647 0649; 
    // (ﱓ; ﱓ; ﱓ; هى; هى; ) ARABIC LIGATURE HEH WITH ALEF MAKSURA ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC53 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC53 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC53 }};
        std::array<char32_t, 2> const c4 = {{ 0x0647, 0x0649 }};
        std::array<char32_t, 2> const c5 = {{ 0x0647, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_132)
{
    // FC54;FC54;FC54;0647 064A;0647 064A; 
    // (ﱔ; ﱔ; ﱔ; هي; هي; ) ARABIC LIGATURE HEH WITH YEH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC54 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC54 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC54 }};
        std::array<char32_t, 2> const c4 = {{ 0x0647, 0x064A }};
        std::array<char32_t, 2> const c5 = {{ 0x0647, 0x064A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_133)
{
    // FC55;FC55;FC55;064A 062C;064A 062C; 
    // (ﱕ; ﱕ; ﱕ; يج; يج; ) ARABIC LIGATURE YEH WITH JEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC55 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC55 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC55 }};
        std::array<char32_t, 2> const c4 = {{ 0x064A, 0x062C }};
        std::array<char32_t, 2> const c5 = {{ 0x064A, 0x062C }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_134)
{
    // FC56;FC56;FC56;064A 062D;064A 062D; 
    // (ﱖ; ﱖ; ﱖ; يح; يح; ) ARABIC LIGATURE YEH WITH HAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC56 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC56 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC56 }};
        std::array<char32_t, 2> const c4 = {{ 0x064A, 0x062D }};
        std::array<char32_t, 2> const c5 = {{ 0x064A, 0x062D }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_135)
{
    // FC57;FC57;FC57;064A 062E;064A 062E; 
    // (ﱗ; ﱗ; ﱗ; يخ; يخ; ) ARABIC LIGATURE YEH WITH KHAH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC57 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC57 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC57 }};
        std::array<char32_t, 2> const c4 = {{ 0x064A, 0x062E }};
        std::array<char32_t, 2> const c5 = {{ 0x064A, 0x062E }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_136)
{
    // FC58;FC58;FC58;064A 0645;064A 0645; 
    // (ﱘ; ﱘ; ﱘ; يم; يم; ) ARABIC LIGATURE YEH WITH MEEM ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC58 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC58 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC58 }};
        std::array<char32_t, 2> const c4 = {{ 0x064A, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x064A, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_137)
{
    // FC59;FC59;FC59;064A 0649;064A 0649; 
    // (ﱙ; ﱙ; ﱙ; يى; يى; ) ARABIC LIGATURE YEH WITH ALEF MAKSURA ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC59 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC59 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC59 }};
        std::array<char32_t, 2> const c4 = {{ 0x064A, 0x0649 }};
        std::array<char32_t, 2> const c5 = {{ 0x064A, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_138)
{
    // FC5A;FC5A;FC5A;064A 064A;064A 064A; 
    // (ﱚ; ﱚ; ﱚ; يي; يي; ) ARABIC LIGATURE YEH WITH YEH ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC5A }};
        std::array<char32_t, 1> const c2 = {{ 0xFC5A }};
        std::array<char32_t, 1> const c3 = {{ 0xFC5A }};
        std::array<char32_t, 2> const c4 = {{ 0x064A, 0x064A }};
        std::array<char32_t, 2> const c5 = {{ 0x064A, 0x064A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_139)
{
    // FC5B;FC5B;FC5B;0630 0670;0630 0670; 
    // (ﱛ; ﱛ; ﱛ; ذ◌ٰ; ذ◌ٰ; ) ARABIC LIGATURE THAL WITH SUPERSCRIPT ALEF ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC5B }};
        std::array<char32_t, 1> const c2 = {{ 0xFC5B }};
        std::array<char32_t, 1> const c3 = {{ 0xFC5B }};
        std::array<char32_t, 2> const c4 = {{ 0x0630, 0x0670 }};
        std::array<char32_t, 2> const c5 = {{ 0x0630, 0x0670 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_140)
{
    // FC5C;FC5C;FC5C;0631 0670;0631 0670; 
    // (ﱜ; ﱜ; ﱜ; ر◌ٰ; ر◌ٰ; ) ARABIC LIGATURE REH WITH SUPERSCRIPT ALEF ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC5C }};
        std::array<char32_t, 1> const c2 = {{ 0xFC5C }};
        std::array<char32_t, 1> const c3 = {{ 0xFC5C }};
        std::array<char32_t, 2> const c4 = {{ 0x0631, 0x0670 }};
        std::array<char32_t, 2> const c5 = {{ 0x0631, 0x0670 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_141)
{
    // FC5D;FC5D;FC5D;0649 0670;0649 0670; 
    // (ﱝ; ﱝ; ﱝ; ى◌ٰ; ى◌ٰ; ) ARABIC LIGATURE ALEF MAKSURA WITH SUPERSCRIPT ALEF ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC5D }};
        std::array<char32_t, 1> const c2 = {{ 0xFC5D }};
        std::array<char32_t, 1> const c3 = {{ 0xFC5D }};
        std::array<char32_t, 2> const c4 = {{ 0x0649, 0x0670 }};
        std::array<char32_t, 2> const c5 = {{ 0x0649, 0x0670 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_142)
{
    // FC5E;FC5E;FC5E;0020 064C 0651;0020 064C 0651; 
    // (ﱞ; ﱞ; ﱞ;  ◌ٌ◌ّ;  ◌ٌ◌ّ; ) ARABIC LIGATURE SHADDA WITH DAMMATAN ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC5E }};
        std::array<char32_t, 1> const c2 = {{ 0xFC5E }};
        std::array<char32_t, 1> const c3 = {{ 0xFC5E }};
        std::array<char32_t, 3> const c4 = {{ 0x0020, 0x064C, 0x0651 }};
        std::array<char32_t, 3> const c5 = {{ 0x0020, 0x064C, 0x0651 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_143)
{
    // FC5F;FC5F;FC5F;0020 064D 0651;0020 064D 0651; 
    // (ﱟ; ﱟ; ﱟ;  ◌ٍ◌ّ;  ◌ٍ◌ّ; ) ARABIC LIGATURE SHADDA WITH KASRATAN ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC5F }};
        std::array<char32_t, 1> const c2 = {{ 0xFC5F }};
        std::array<char32_t, 1> const c3 = {{ 0xFC5F }};
        std::array<char32_t, 3> const c4 = {{ 0x0020, 0x064D, 0x0651 }};
        std::array<char32_t, 3> const c5 = {{ 0x0020, 0x064D, 0x0651 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_144)
{
    // FC60;FC60;FC60;0020 064E 0651;0020 064E 0651; 
    // (ﱠ; ﱠ; ﱠ;  ◌َ◌ّ;  ◌َ◌ّ; ) ARABIC LIGATURE SHADDA WITH FATHA ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC60 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC60 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC60 }};
        std::array<char32_t, 3> const c4 = {{ 0x0020, 0x064E, 0x0651 }};
        std::array<char32_t, 3> const c5 = {{ 0x0020, 0x064E, 0x0651 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_145)
{
    // FC61;FC61;FC61;0020 064F 0651;0020 064F 0651; 
    // (ﱡ; ﱡ; ﱡ;  ◌ُ◌ّ;  ◌ُ◌ّ; ) ARABIC LIGATURE SHADDA WITH DAMMA ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC61 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC61 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC61 }};
        std::array<char32_t, 3> const c4 = {{ 0x0020, 0x064F, 0x0651 }};
        std::array<char32_t, 3> const c5 = {{ 0x0020, 0x064F, 0x0651 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_146)
{
    // FC62;FC62;FC62;0020 0650 0651;0020 0650 0651; 
    // (ﱢ; ﱢ; ﱢ;  ◌ِ◌ّ;  ◌ِ◌ّ; ) ARABIC LIGATURE SHADDA WITH KASRA ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC62 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC62 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC62 }};
        std::array<char32_t, 3> const c4 = {{ 0x0020, 0x0650, 0x0651 }};
        std::array<char32_t, 3> const c5 = {{ 0x0020, 0x0650, 0x0651 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_147)
{
    // FC63;FC63;FC63;0020 0651 0670;0020 0651 0670; 
    // (ﱣ; ﱣ; ﱣ;  ◌ّ◌ٰ;  ◌ّ◌ٰ; ) ARABIC LIGATURE SHADDA WITH SUPERSCRIPT ALEF ISOLATED FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC63 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC63 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC63 }};
        std::array<char32_t, 3> const c4 = {{ 0x0020, 0x0651, 0x0670 }};
        std::array<char32_t, 3> const c5 = {{ 0x0020, 0x0651, 0x0670 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_148)
{
    // FC64;FC64;FC64;0626 0631;064A 0654 0631; 
    // (ﱤ; ﱤ; ﱤ; ئر; ي◌ٔر; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH REH FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC64 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC64 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC64 }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x0631 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x0631 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_149)
{
    // FC65;FC65;FC65;0626 0632;064A 0654 0632; 
    // (ﱥ; ﱥ; ﱥ; ئز; ي◌ٔز; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH ZAIN FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC65 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC65 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC65 }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x0632 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x0632 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_150)
{
    // FC66;FC66;FC66;0626 0645;064A 0654 0645; 
    // (ﱦ; ﱦ; ﱦ; ئم; ي◌ٔم; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH MEEM FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC66 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC66 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC66 }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x0645 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_151)
{
    // FC67;FC67;FC67;0626 0646;064A 0654 0646; 
    // (ﱧ; ﱧ; ﱧ; ئن; ي◌ٔن; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH NOON FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC67 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC67 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC67 }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x0646 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x0646 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_152)
{
    // FC68;FC68;FC68;0626 0649;064A 0654 0649; 
    // (ﱨ; ﱨ; ﱨ; ئى; ي◌ٔى; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH ALEF MAKSURA FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC68 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC68 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC68 }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x0649 }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_153)
{
    // FC69;FC69;FC69;0626 064A;064A 0654 064A; 
    // (ﱩ; ﱩ; ﱩ; ئي; ي◌ٔي; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH YEH FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC69 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC69 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC69 }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x064A }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x064A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_154)
{
    // FC6A;FC6A;FC6A;0628 0631;0628 0631; 
    // (ﱪ; ﱪ; ﱪ; بر; بر; ) ARABIC LIGATURE BEH WITH REH FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC6A }};
        std::array<char32_t, 1> const c2 = {{ 0xFC6A }};
        std::array<char32_t, 1> const c3 = {{ 0xFC6A }};
        std::array<char32_t, 2> const c4 = {{ 0x0628, 0x0631 }};
        std::array<char32_t, 2> const c5 = {{ 0x0628, 0x0631 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_155)
{
    // FC6B;FC6B;FC6B;0628 0632;0628 0632; 
    // (ﱫ; ﱫ; ﱫ; بز; بز; ) ARABIC LIGATURE BEH WITH ZAIN FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC6B }};
        std::array<char32_t, 1> const c2 = {{ 0xFC6B }};
        std::array<char32_t, 1> const c3 = {{ 0xFC6B }};
        std::array<char32_t, 2> const c4 = {{ 0x0628, 0x0632 }};
        std::array<char32_t, 2> const c5 = {{ 0x0628, 0x0632 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_156)
{
    // FC6C;FC6C;FC6C;0628 0645;0628 0645; 
    // (ﱬ; ﱬ; ﱬ; بم; بم; ) ARABIC LIGATURE BEH WITH MEEM FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC6C }};
        std::array<char32_t, 1> const c2 = {{ 0xFC6C }};
        std::array<char32_t, 1> const c3 = {{ 0xFC6C }};
        std::array<char32_t, 2> const c4 = {{ 0x0628, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x0628, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_157)
{
    // FC6D;FC6D;FC6D;0628 0646;0628 0646; 
    // (ﱭ; ﱭ; ﱭ; بن; بن; ) ARABIC LIGATURE BEH WITH NOON FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC6D }};
        std::array<char32_t, 1> const c2 = {{ 0xFC6D }};
        std::array<char32_t, 1> const c3 = {{ 0xFC6D }};
        std::array<char32_t, 2> const c4 = {{ 0x0628, 0x0646 }};
        std::array<char32_t, 2> const c5 = {{ 0x0628, 0x0646 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_158)
{
    // FC6E;FC6E;FC6E;0628 0649;0628 0649; 
    // (ﱮ; ﱮ; ﱮ; بى; بى; ) ARABIC LIGATURE BEH WITH ALEF MAKSURA FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC6E }};
        std::array<char32_t, 1> const c2 = {{ 0xFC6E }};
        std::array<char32_t, 1> const c3 = {{ 0xFC6E }};
        std::array<char32_t, 2> const c4 = {{ 0x0628, 0x0649 }};
        std::array<char32_t, 2> const c5 = {{ 0x0628, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_159)
{
    // FC6F;FC6F;FC6F;0628 064A;0628 064A; 
    // (ﱯ; ﱯ; ﱯ; بي; بي; ) ARABIC LIGATURE BEH WITH YEH FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC6F }};
        std::array<char32_t, 1> const c2 = {{ 0xFC6F }};
        std::array<char32_t, 1> const c3 = {{ 0xFC6F }};
        std::array<char32_t, 2> const c4 = {{ 0x0628, 0x064A }};
        std::array<char32_t, 2> const c5 = {{ 0x0628, 0x064A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_160)
{
    // FC70;FC70;FC70;062A 0631;062A 0631; 
    // (ﱰ; ﱰ; ﱰ; تر; تر; ) ARABIC LIGATURE TEH WITH REH FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC70 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC70 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC70 }};
        std::array<char32_t, 2> const c4 = {{ 0x062A, 0x0631 }};
        std::array<char32_t, 2> const c5 = {{ 0x062A, 0x0631 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_161)
{
    // FC71;FC71;FC71;062A 0632;062A 0632; 
    // (ﱱ; ﱱ; ﱱ; تز; تز; ) ARABIC LIGATURE TEH WITH ZAIN FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC71 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC71 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC71 }};
        std::array<char32_t, 2> const c4 = {{ 0x062A, 0x0632 }};
        std::array<char32_t, 2> const c5 = {{ 0x062A, 0x0632 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_162)
{
    // FC72;FC72;FC72;062A 0645;062A 0645; 
    // (ﱲ; ﱲ; ﱲ; تم; تم; ) ARABIC LIGATURE TEH WITH MEEM FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC72 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC72 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC72 }};
        std::array<char32_t, 2> const c4 = {{ 0x062A, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x062A, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_163)
{
    // FC73;FC73;FC73;062A 0646;062A 0646; 
    // (ﱳ; ﱳ; ﱳ; تن; تن; ) ARABIC LIGATURE TEH WITH NOON FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC73 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC73 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC73 }};
        std::array<char32_t, 2> const c4 = {{ 0x062A, 0x0646 }};
        std::array<char32_t, 2> const c5 = {{ 0x062A, 0x0646 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_164)
{
    // FC74;FC74;FC74;062A 0649;062A 0649; 
    // (ﱴ; ﱴ; ﱴ; تى; تى; ) ARABIC LIGATURE TEH WITH ALEF MAKSURA FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC74 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC74 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC74 }};
        std::array<char32_t, 2> const c4 = {{ 0x062A, 0x0649 }};
        std::array<char32_t, 2> const c5 = {{ 0x062A, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_165)
{
    // FC75;FC75;FC75;062A 064A;062A 064A; 
    // (ﱵ; ﱵ; ﱵ; تي; تي; ) ARABIC LIGATURE TEH WITH YEH FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC75 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC75 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC75 }};
        std::array<char32_t, 2> const c4 = {{ 0x062A, 0x064A }};
        std::array<char32_t, 2> const c5 = {{ 0x062A, 0x064A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_166)
{
    // FC76;FC76;FC76;062B 0631;062B 0631; 
    // (ﱶ; ﱶ; ﱶ; ثر; ثر; ) ARABIC LIGATURE THEH WITH REH FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC76 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC76 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC76 }};
        std::array<char32_t, 2> const c4 = {{ 0x062B, 0x0631 }};
        std::array<char32_t, 2> const c5 = {{ 0x062B, 0x0631 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_167)
{
    // FC77;FC77;FC77;062B 0632;062B 0632; 
    // (ﱷ; ﱷ; ﱷ; ثز; ثز; ) ARABIC LIGATURE THEH WITH ZAIN FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC77 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC77 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC77 }};
        std::array<char32_t, 2> const c4 = {{ 0x062B, 0x0632 }};
        std::array<char32_t, 2> const c5 = {{ 0x062B, 0x0632 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_168)
{
    // FC78;FC78;FC78;062B 0645;062B 0645; 
    // (ﱸ; ﱸ; ﱸ; ثم; ثم; ) ARABIC LIGATURE THEH WITH MEEM FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC78 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC78 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC78 }};
        std::array<char32_t, 2> const c4 = {{ 0x062B, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x062B, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_169)
{
    // FC79;FC79;FC79;062B 0646;062B 0646; 
    // (ﱹ; ﱹ; ﱹ; ثن; ثن; ) ARABIC LIGATURE THEH WITH NOON FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC79 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC79 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC79 }};
        std::array<char32_t, 2> const c4 = {{ 0x062B, 0x0646 }};
        std::array<char32_t, 2> const c5 = {{ 0x062B, 0x0646 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_170)
{
    // FC7A;FC7A;FC7A;062B 0649;062B 0649; 
    // (ﱺ; ﱺ; ﱺ; ثى; ثى; ) ARABIC LIGATURE THEH WITH ALEF MAKSURA FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC7A }};
        std::array<char32_t, 1> const c2 = {{ 0xFC7A }};
        std::array<char32_t, 1> const c3 = {{ 0xFC7A }};
        std::array<char32_t, 2> const c4 = {{ 0x062B, 0x0649 }};
        std::array<char32_t, 2> const c5 = {{ 0x062B, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_171)
{
    // FC7B;FC7B;FC7B;062B 064A;062B 064A; 
    // (ﱻ; ﱻ; ﱻ; ثي; ثي; ) ARABIC LIGATURE THEH WITH YEH FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC7B }};
        std::array<char32_t, 1> const c2 = {{ 0xFC7B }};
        std::array<char32_t, 1> const c3 = {{ 0xFC7B }};
        std::array<char32_t, 2> const c4 = {{ 0x062B, 0x064A }};
        std::array<char32_t, 2> const c5 = {{ 0x062B, 0x064A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_172)
{
    // FC7C;FC7C;FC7C;0641 0649;0641 0649; 
    // (ﱼ; ﱼ; ﱼ; فى; فى; ) ARABIC LIGATURE FEH WITH ALEF MAKSURA FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC7C }};
        std::array<char32_t, 1> const c2 = {{ 0xFC7C }};
        std::array<char32_t, 1> const c3 = {{ 0xFC7C }};
        std::array<char32_t, 2> const c4 = {{ 0x0641, 0x0649 }};
        std::array<char32_t, 2> const c5 = {{ 0x0641, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_173)
{
    // FC7D;FC7D;FC7D;0641 064A;0641 064A; 
    // (ﱽ; ﱽ; ﱽ; في; في; ) ARABIC LIGATURE FEH WITH YEH FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC7D }};
        std::array<char32_t, 1> const c2 = {{ 0xFC7D }};
        std::array<char32_t, 1> const c3 = {{ 0xFC7D }};
        std::array<char32_t, 2> const c4 = {{ 0x0641, 0x064A }};
        std::array<char32_t, 2> const c5 = {{ 0x0641, 0x064A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_174)
{
    // FC7E;FC7E;FC7E;0642 0649;0642 0649; 
    // (ﱾ; ﱾ; ﱾ; قى; قى; ) ARABIC LIGATURE QAF WITH ALEF MAKSURA FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC7E }};
        std::array<char32_t, 1> const c2 = {{ 0xFC7E }};
        std::array<char32_t, 1> const c3 = {{ 0xFC7E }};
        std::array<char32_t, 2> const c4 = {{ 0x0642, 0x0649 }};
        std::array<char32_t, 2> const c5 = {{ 0x0642, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_175)
{
    // FC7F;FC7F;FC7F;0642 064A;0642 064A; 
    // (ﱿ; ﱿ; ﱿ; قي; قي; ) ARABIC LIGATURE QAF WITH YEH FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC7F }};
        std::array<char32_t, 1> const c2 = {{ 0xFC7F }};
        std::array<char32_t, 1> const c3 = {{ 0xFC7F }};
        std::array<char32_t, 2> const c4 = {{ 0x0642, 0x064A }};
        std::array<char32_t, 2> const c5 = {{ 0x0642, 0x064A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_176)
{
    // FC80;FC80;FC80;0643 0627;0643 0627; 
    // (ﲀ; ﲀ; ﲀ; كا; كا; ) ARABIC LIGATURE KAF WITH ALEF FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC80 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC80 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC80 }};
        std::array<char32_t, 2> const c4 = {{ 0x0643, 0x0627 }};
        std::array<char32_t, 2> const c5 = {{ 0x0643, 0x0627 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_177)
{
    // FC81;FC81;FC81;0643 0644;0643 0644; 
    // (ﲁ; ﲁ; ﲁ; كل; كل; ) ARABIC LIGATURE KAF WITH LAM FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC81 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC81 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC81 }};
        std::array<char32_t, 2> const c4 = {{ 0x0643, 0x0644 }};
        std::array<char32_t, 2> const c5 = {{ 0x0643, 0x0644 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_178)
{
    // FC82;FC82;FC82;0643 0645;0643 0645; 
    // (ﲂ; ﲂ; ﲂ; كم; كم; ) ARABIC LIGATURE KAF WITH MEEM FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC82 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC82 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC82 }};
        std::array<char32_t, 2> const c4 = {{ 0x0643, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x0643, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_179)
{
    // FC83;FC83;FC83;0643 0649;0643 0649; 
    // (ﲃ; ﲃ; ﲃ; كى; كى; ) ARABIC LIGATURE KAF WITH ALEF MAKSURA FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC83 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC83 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC83 }};
        std::array<char32_t, 2> const c4 = {{ 0x0643, 0x0649 }};
        std::array<char32_t, 2> const c5 = {{ 0x0643, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_180)
{
    // FC84;FC84;FC84;0643 064A;0643 064A; 
    // (ﲄ; ﲄ; ﲄ; كي; كي; ) ARABIC LIGATURE KAF WITH YEH FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC84 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC84 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC84 }};
        std::array<char32_t, 2> const c4 = {{ 0x0643, 0x064A }};
        std::array<char32_t, 2> const c5 = {{ 0x0643, 0x064A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_181)
{
    // FC85;FC85;FC85;0644 0645;0644 0645; 
    // (ﲅ; ﲅ; ﲅ; لم; لم; ) ARABIC LIGATURE LAM WITH MEEM FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC85 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC85 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC85 }};
        std::array<char32_t, 2> const c4 = {{ 0x0644, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x0644, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_182)
{
    // FC86;FC86;FC86;0644 0649;0644 0649; 
    // (ﲆ; ﲆ; ﲆ; لى; لى; ) ARABIC LIGATURE LAM WITH ALEF MAKSURA FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC86 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC86 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC86 }};
        std::array<char32_t, 2> const c4 = {{ 0x0644, 0x0649 }};
        std::array<char32_t, 2> const c5 = {{ 0x0644, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_183)
{
    // FC87;FC87;FC87;0644 064A;0644 064A; 
    // (ﲇ; ﲇ; ﲇ; لي; لي; ) ARABIC LIGATURE LAM WITH YEH FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC87 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC87 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC87 }};
        std::array<char32_t, 2> const c4 = {{ 0x0644, 0x064A }};
        std::array<char32_t, 2> const c5 = {{ 0x0644, 0x064A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_184)
{
    // FC88;FC88;FC88;0645 0627;0645 0627; 
    // (ﲈ; ﲈ; ﲈ; ما; ما; ) ARABIC LIGATURE MEEM WITH ALEF FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC88 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC88 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC88 }};
        std::array<char32_t, 2> const c4 = {{ 0x0645, 0x0627 }};
        std::array<char32_t, 2> const c5 = {{ 0x0645, 0x0627 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_185)
{
    // FC89;FC89;FC89;0645 0645;0645 0645; 
    // (ﲉ; ﲉ; ﲉ; مم; مم; ) ARABIC LIGATURE MEEM WITH MEEM FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC89 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC89 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC89 }};
        std::array<char32_t, 2> const c4 = {{ 0x0645, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x0645, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_186)
{
    // FC8A;FC8A;FC8A;0646 0631;0646 0631; 
    // (ﲊ; ﲊ; ﲊ; نر; نر; ) ARABIC LIGATURE NOON WITH REH FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC8A }};
        std::array<char32_t, 1> const c2 = {{ 0xFC8A }};
        std::array<char32_t, 1> const c3 = {{ 0xFC8A }};
        std::array<char32_t, 2> const c4 = {{ 0x0646, 0x0631 }};
        std::array<char32_t, 2> const c5 = {{ 0x0646, 0x0631 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_187)
{
    // FC8B;FC8B;FC8B;0646 0632;0646 0632; 
    // (ﲋ; ﲋ; ﲋ; نز; نز; ) ARABIC LIGATURE NOON WITH ZAIN FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC8B }};
        std::array<char32_t, 1> const c2 = {{ 0xFC8B }};
        std::array<char32_t, 1> const c3 = {{ 0xFC8B }};
        std::array<char32_t, 2> const c4 = {{ 0x0646, 0x0632 }};
        std::array<char32_t, 2> const c5 = {{ 0x0646, 0x0632 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_188)
{
    // FC8C;FC8C;FC8C;0646 0645;0646 0645; 
    // (ﲌ; ﲌ; ﲌ; نم; نم; ) ARABIC LIGATURE NOON WITH MEEM FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC8C }};
        std::array<char32_t, 1> const c2 = {{ 0xFC8C }};
        std::array<char32_t, 1> const c3 = {{ 0xFC8C }};
        std::array<char32_t, 2> const c4 = {{ 0x0646, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x0646, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_189)
{
    // FC8D;FC8D;FC8D;0646 0646;0646 0646; 
    // (ﲍ; ﲍ; ﲍ; نن; نن; ) ARABIC LIGATURE NOON WITH NOON FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC8D }};
        std::array<char32_t, 1> const c2 = {{ 0xFC8D }};
        std::array<char32_t, 1> const c3 = {{ 0xFC8D }};
        std::array<char32_t, 2> const c4 = {{ 0x0646, 0x0646 }};
        std::array<char32_t, 2> const c5 = {{ 0x0646, 0x0646 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_190)
{
    // FC8E;FC8E;FC8E;0646 0649;0646 0649; 
    // (ﲎ; ﲎ; ﲎ; نى; نى; ) ARABIC LIGATURE NOON WITH ALEF MAKSURA FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC8E }};
        std::array<char32_t, 1> const c2 = {{ 0xFC8E }};
        std::array<char32_t, 1> const c3 = {{ 0xFC8E }};
        std::array<char32_t, 2> const c4 = {{ 0x0646, 0x0649 }};
        std::array<char32_t, 2> const c5 = {{ 0x0646, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_191)
{
    // FC8F;FC8F;FC8F;0646 064A;0646 064A; 
    // (ﲏ; ﲏ; ﲏ; ني; ني; ) ARABIC LIGATURE NOON WITH YEH FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC8F }};
        std::array<char32_t, 1> const c2 = {{ 0xFC8F }};
        std::array<char32_t, 1> const c3 = {{ 0xFC8F }};
        std::array<char32_t, 2> const c4 = {{ 0x0646, 0x064A }};
        std::array<char32_t, 2> const c5 = {{ 0x0646, 0x064A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_192)
{
    // FC90;FC90;FC90;0649 0670;0649 0670; 
    // (ﲐ; ﲐ; ﲐ; ى◌ٰ; ى◌ٰ; ) ARABIC LIGATURE ALEF MAKSURA WITH SUPERSCRIPT ALEF FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC90 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC90 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC90 }};
        std::array<char32_t, 2> const c4 = {{ 0x0649, 0x0670 }};
        std::array<char32_t, 2> const c5 = {{ 0x0649, 0x0670 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_193)
{
    // FC91;FC91;FC91;064A 0631;064A 0631; 
    // (ﲑ; ﲑ; ﲑ; ير; ير; ) ARABIC LIGATURE YEH WITH REH FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC91 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC91 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC91 }};
        std::array<char32_t, 2> const c4 = {{ 0x064A, 0x0631 }};
        std::array<char32_t, 2> const c5 = {{ 0x064A, 0x0631 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_194)
{
    // FC92;FC92;FC92;064A 0632;064A 0632; 
    // (ﲒ; ﲒ; ﲒ; يز; يز; ) ARABIC LIGATURE YEH WITH ZAIN FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC92 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC92 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC92 }};
        std::array<char32_t, 2> const c4 = {{ 0x064A, 0x0632 }};
        std::array<char32_t, 2> const c5 = {{ 0x064A, 0x0632 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_195)
{
    // FC93;FC93;FC93;064A 0645;064A 0645; 
    // (ﲓ; ﲓ; ﲓ; يم; يم; ) ARABIC LIGATURE YEH WITH MEEM FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC93 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC93 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC93 }};
        std::array<char32_t, 2> const c4 = {{ 0x064A, 0x0645 }};
        std::array<char32_t, 2> const c5 = {{ 0x064A, 0x0645 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_196)
{
    // FC94;FC94;FC94;064A 0646;064A 0646; 
    // (ﲔ; ﲔ; ﲔ; ين; ين; ) ARABIC LIGATURE YEH WITH NOON FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC94 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC94 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC94 }};
        std::array<char32_t, 2> const c4 = {{ 0x064A, 0x0646 }};
        std::array<char32_t, 2> const c5 = {{ 0x064A, 0x0646 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_197)
{
    // FC95;FC95;FC95;064A 0649;064A 0649; 
    // (ﲕ; ﲕ; ﲕ; يى; يى; ) ARABIC LIGATURE YEH WITH ALEF MAKSURA FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC95 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC95 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC95 }};
        std::array<char32_t, 2> const c4 = {{ 0x064A, 0x0649 }};
        std::array<char32_t, 2> const c5 = {{ 0x064A, 0x0649 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_198)
{
    // FC96;FC96;FC96;064A 064A;064A 064A; 
    // (ﲖ; ﲖ; ﲖ; يي; يي; ) ARABIC LIGATURE YEH WITH YEH FINAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC96 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC96 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC96 }};
        std::array<char32_t, 2> const c4 = {{ 0x064A, 0x064A }};
        std::array<char32_t, 2> const c5 = {{ 0x064A, 0x064A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfd_071_199)
{
    // FC97;FC97;FC97;0626 062C;064A 0654 062C; 
    // (ﲗ; ﲗ; ﲗ; ئج; ي◌ٔج; ) ARABIC LIGATURE YEH WITH HAMZA ABOVE WITH JEEM INITIAL FORM
    {
        std::array<char32_t, 1> const c1 = {{ 0xFC97 }};
        std::array<char32_t, 1> const c2 = {{ 0xFC97 }};
        std::array<char32_t, 1> const c3 = {{ 0xFC97 }};
        std::array<char32_t, 2> const c4 = {{ 0x0626, 0x062C }};
        std::array<char32_t, 3> const c5 = {{ 0x064A, 0x0654, 0x062C }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[2] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
                auto c3_it = c3.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c3_it) << "iteration " << i;
                    ++c3_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[2] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfd | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            boost::text::normalize<boost::text::nf::d>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
                auto c5_it = c5.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c5_it) << "iteration " << i;
                    ++c5_it;
                    ++i;
                }
            }
        }

    }
}


